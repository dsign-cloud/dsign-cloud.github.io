(function(){const A=document.createElement("link").relList;if(A&&A.supports&&A.supports("modulepreload"))return;for(const n of document.querySelectorAll('link[rel="modulepreload"]'))t(n);new MutationObserver(n=>{for(const s of n)if(s.type==="childList")for(const o of s.addedNodes)o.tagName==="LINK"&&o.rel==="modulepreload"&&t(o)}).observe(document,{childList:!0,subtree:!0});function e(n){const s={};return n.integrity&&(s.integrity=n.integrity),n.referrerPolicy&&(s.referrerPolicy=n.referrerPolicy),n.crossOrigin==="use-credentials"?s.credentials="include":n.crossOrigin==="anonymous"?s.credentials="omit":s.credentials="same-origin",s}function t(n){if(n.ep)return;n.ep=!0;const s=e(n);fetch(n.href,s)}})();/**
 * @license
 * Copyright 2010-2024 Three.js Authors
 * SPDX-License-Identifier: MIT
 */const na="171",VC=0,Pa=1,zC=2,nE=1,XC=2,Tt=3,ft=0,Je=1,Bt=2,ri=0,Ri=1,Oa=2,Ja=3,Ka=4,ZC=5,Di=100,jC=101,$C=102,AQ=103,eQ=104,tQ=200,iQ=201,nQ=202,sQ=203,sr=204,or=205,oQ=206,rQ=207,aQ=208,gQ=209,IQ=210,EQ=211,CQ=212,QQ=213,BQ=214,rr=0,ar=1,gr=2,nn=3,Ir=4,Er=5,Cr=6,Qr=7,sE=0,cQ=1,hQ=2,ai=0,lQ=1,dQ=2,uQ=3,fQ=4,pQ=5,DQ=6,mQ=7,Ya="attached",yQ="detached",oE=300,sn=301,on=302,Br=303,cr=304,eo=306,rn=1e3,ni=1001,Js=1002,Te=1003,rE=1004,xn=1005,ze=1006,Ls=1007,Ot=1008,qt=1009,aE=1010,gE=1011,Hn=1012,sa=1013,Oe=1014,lt=1015,qn=1016,oa=1017,ra=1018,an=1020,IE=35902,EE=1021,CE=1022,et=1023,QE=1024,BE=1025,$i=1026,gn=1027,aa=1028,ga=1029,cE=1030,Ia=1031,mt=1033,_s=33776,Us=33777,Gs=33778,vs=33779,hr=35840,lr=35841,dr=35842,ur=35843,fr=36196,pr=37492,Dr=37496,mr=37808,yr=37809,Rr=37810,wr=37811,Sr=37812,Mr=37813,Nr=37814,xr=37815,Fr=37816,Lr=37817,_r=37818,Ur=37819,Gr=37820,vr=37821,Ts=36492,Tr=36494,br=36495,hE=36283,kr=36284,Hr=36285,Pr=36286,Pn=2300,On=2301,Io=2302,qa=2400,Wa=2401,Va=2402,RQ=2500,wQ=0,lE=1,Or=2,SQ=3200,MQ=3201,Ea=0,NQ=1,ii="",De="srgb",be="srgb-linear",Ks="linear",ge="srgb",Fi=7680,za=519,xQ=512,FQ=513,LQ=514,dE=515,_Q=516,UQ=517,GQ=518,vQ=519,Jr=35044,TQ=35048,Xa="300 es",Jt=2e3,Ys=2001;class Si{addEventListener(A,e){this._listeners===void 0&&(this._listeners={});const t=this._listeners;t[A]===void 0&&(t[A]=[]),t[A].indexOf(e)===-1&&t[A].push(e)}hasEventListener(A,e){if(this._listeners===void 0)return!1;const t=this._listeners;return t[A]!==void 0&&t[A].indexOf(e)!==-1}removeEventListener(A,e){if(this._listeners===void 0)return;const n=this._listeners[A];if(n!==void 0){const s=n.indexOf(e);s!==-1&&n.splice(s,1)}}dispatchEvent(A){if(this._listeners===void 0)return;const t=this._listeners[A.type];if(t!==void 0){A.target=this;const n=t.slice(0);for(let s=0,o=n.length;s<o;s++)n[s].call(this,A);A.target=null}}}const Ne=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"];let Za=1234567;const Gn=Math.PI/180,In=180/Math.PI;function dt(){const i=Math.random()*4294967295|0,A=Math.random()*4294967295|0,e=Math.random()*4294967295|0,t=Math.random()*4294967295|0;return(Ne[i&255]+Ne[i>>8&255]+Ne[i>>16&255]+Ne[i>>24&255]+"-"+Ne[A&255]+Ne[A>>8&255]+"-"+Ne[A>>16&15|64]+Ne[A>>24&255]+"-"+Ne[e&63|128]+Ne[e>>8&255]+"-"+Ne[e>>16&255]+Ne[e>>24&255]+Ne[t&255]+Ne[t>>8&255]+Ne[t>>16&255]+Ne[t>>24&255]).toLowerCase()}function zA(i,A,e){return Math.max(A,Math.min(e,i))}function Ca(i,A){return(i%A+A)%A}function bQ(i,A,e,t,n){return t+(i-A)*(n-t)/(e-A)}function kQ(i,A,e){return i!==A?(e-i)/(A-i):0}function vn(i,A,e){return(1-e)*i+e*A}function HQ(i,A,e,t){return vn(i,A,1-Math.exp(-e*t))}function PQ(i,A=1){return A-Math.abs(Ca(i,A*2)-A)}function OQ(i,A,e){return i<=A?0:i>=e?1:(i=(i-A)/(e-A),i*i*(3-2*i))}function JQ(i,A,e){return i<=A?0:i>=e?1:(i=(i-A)/(e-A),i*i*i*(i*(i*6-15)+10))}function KQ(i,A){return i+Math.floor(Math.random()*(A-i+1))}function YQ(i,A){return i+Math.random()*(A-i)}function qQ(i){return i*(.5-Math.random())}function WQ(i){i!==void 0&&(Za=i);let A=Za+=1831565813;return A=Math.imul(A^A>>>15,A|1),A^=A+Math.imul(A^A>>>7,A|61),((A^A>>>14)>>>0)/4294967296}function VQ(i){return i*Gn}function zQ(i){return i*In}function XQ(i){return(i&i-1)===0&&i!==0}function ZQ(i){return Math.pow(2,Math.ceil(Math.log(i)/Math.LN2))}function jQ(i){return Math.pow(2,Math.floor(Math.log(i)/Math.LN2))}function $Q(i,A,e,t,n){const s=Math.cos,o=Math.sin,r=s(e/2),a=o(e/2),g=s((A+t)/2),I=o((A+t)/2),E=s((A-t)/2),C=o((A-t)/2),Q=s((t-A)/2),h=o((t-A)/2);switch(n){case"XYX":i.set(r*I,a*E,a*C,r*g);break;case"YZY":i.set(a*C,r*I,a*E,r*g);break;case"ZXZ":i.set(a*E,a*C,r*I,r*g);break;case"XZX":i.set(r*I,a*h,a*Q,r*g);break;case"YXY":i.set(a*Q,r*I,a*h,r*g);break;case"ZYZ":i.set(a*h,a*Q,r*I,r*g);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+n)}}function ct(i,A){switch(A.constructor){case Float32Array:return i;case Uint32Array:return i/4294967295;case Uint16Array:return i/65535;case Uint8Array:return i/255;case Int32Array:return Math.max(i/2147483647,-1);case Int16Array:return Math.max(i/32767,-1);case Int8Array:return Math.max(i/127,-1);default:throw new Error("Invalid component type.")}}function re(i,A){switch(A.constructor){case Float32Array:return i;case Uint32Array:return Math.round(i*4294967295);case Uint16Array:return Math.round(i*65535);case Uint8Array:return Math.round(i*255);case Int32Array:return Math.round(i*2147483647);case Int16Array:return Math.round(i*32767);case Int8Array:return Math.round(i*127);default:throw new Error("Invalid component type.")}}const Qa={DEG2RAD:Gn,RAD2DEG:In,generateUUID:dt,clamp:zA,euclideanModulo:Ca,mapLinear:bQ,inverseLerp:kQ,lerp:vn,damp:HQ,pingpong:PQ,smoothstep:OQ,smootherstep:JQ,randInt:KQ,randFloat:YQ,randFloatSpread:qQ,seededRandom:WQ,degToRad:VQ,radToDeg:zQ,isPowerOfTwo:XQ,ceilPowerOfTwo:ZQ,floorPowerOfTwo:jQ,setQuaternionFromProperEuler:$Q,normalize:re,denormalize:ct};class bA{constructor(A=0,e=0){bA.prototype.isVector2=!0,this.x=A,this.y=e}get width(){return this.x}set width(A){this.x=A}get height(){return this.y}set height(A){this.y=A}set(A,e){return this.x=A,this.y=e,this}setScalar(A){return this.x=A,this.y=A,this}setX(A){return this.x=A,this}setY(A){return this.y=A,this}setComponent(A,e){switch(A){case 0:this.x=e;break;case 1:this.y=e;break;default:throw new Error("index is out of range: "+A)}return this}getComponent(A){switch(A){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+A)}}clone(){return new this.constructor(this.x,this.y)}copy(A){return this.x=A.x,this.y=A.y,this}add(A){return this.x+=A.x,this.y+=A.y,this}addScalar(A){return this.x+=A,this.y+=A,this}addVectors(A,e){return this.x=A.x+e.x,this.y=A.y+e.y,this}addScaledVector(A,e){return this.x+=A.x*e,this.y+=A.y*e,this}sub(A){return this.x-=A.x,this.y-=A.y,this}subScalar(A){return this.x-=A,this.y-=A,this}subVectors(A,e){return this.x=A.x-e.x,this.y=A.y-e.y,this}multiply(A){return this.x*=A.x,this.y*=A.y,this}multiplyScalar(A){return this.x*=A,this.y*=A,this}divide(A){return this.x/=A.x,this.y/=A.y,this}divideScalar(A){return this.multiplyScalar(1/A)}applyMatrix3(A){const e=this.x,t=this.y,n=A.elements;return this.x=n[0]*e+n[3]*t+n[6],this.y=n[1]*e+n[4]*t+n[7],this}min(A){return this.x=Math.min(this.x,A.x),this.y=Math.min(this.y,A.y),this}max(A){return this.x=Math.max(this.x,A.x),this.y=Math.max(this.y,A.y),this}clamp(A,e){return this.x=zA(this.x,A.x,e.x),this.y=zA(this.y,A.y,e.y),this}clampScalar(A,e){return this.x=zA(this.x,A,e),this.y=zA(this.y,A,e),this}clampLength(A,e){const t=this.length();return this.divideScalar(t||1).multiplyScalar(zA(t,A,e))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(A){return this.x*A.x+this.y*A.y}cross(A){return this.x*A.y-this.y*A.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}angleTo(A){const e=Math.sqrt(this.lengthSq()*A.lengthSq());if(e===0)return Math.PI/2;const t=this.dot(A)/e;return Math.acos(zA(t,-1,1))}distanceTo(A){return Math.sqrt(this.distanceToSquared(A))}distanceToSquared(A){const e=this.x-A.x,t=this.y-A.y;return e*e+t*t}manhattanDistanceTo(A){return Math.abs(this.x-A.x)+Math.abs(this.y-A.y)}setLength(A){return this.normalize().multiplyScalar(A)}lerp(A,e){return this.x+=(A.x-this.x)*e,this.y+=(A.y-this.y)*e,this}lerpVectors(A,e,t){return this.x=A.x+(e.x-A.x)*t,this.y=A.y+(e.y-A.y)*t,this}equals(A){return A.x===this.x&&A.y===this.y}fromArray(A,e=0){return this.x=A[e],this.y=A[e+1],this}toArray(A=[],e=0){return A[e]=this.x,A[e+1]=this.y,A}fromBufferAttribute(A,e){return this.x=A.getX(e),this.y=A.getY(e),this}rotateAround(A,e){const t=Math.cos(e),n=Math.sin(e),s=this.x-A.x,o=this.y-A.y;return this.x=s*t-o*n+A.x,this.y=s*n+o*t+A.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}class PA{constructor(A,e,t,n,s,o,r,a,g){PA.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1],A!==void 0&&this.set(A,e,t,n,s,o,r,a,g)}set(A,e,t,n,s,o,r,a,g){const I=this.elements;return I[0]=A,I[1]=n,I[2]=r,I[3]=e,I[4]=s,I[5]=a,I[6]=t,I[7]=o,I[8]=g,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(A){const e=this.elements,t=A.elements;return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],this}extractBasis(A,e,t){return A.setFromMatrix3Column(this,0),e.setFromMatrix3Column(this,1),t.setFromMatrix3Column(this,2),this}setFromMatrix4(A){const e=A.elements;return this.set(e[0],e[4],e[8],e[1],e[5],e[9],e[2],e[6],e[10]),this}multiply(A){return this.multiplyMatrices(this,A)}premultiply(A){return this.multiplyMatrices(A,this)}multiplyMatrices(A,e){const t=A.elements,n=e.elements,s=this.elements,o=t[0],r=t[3],a=t[6],g=t[1],I=t[4],E=t[7],C=t[2],Q=t[5],h=t[8],l=n[0],B=n[3],c=n[6],R=n[1],p=n[4],d=n[7],w=n[2],S=n[5],F=n[8];return s[0]=o*l+r*R+a*w,s[3]=o*B+r*p+a*S,s[6]=o*c+r*d+a*F,s[1]=g*l+I*R+E*w,s[4]=g*B+I*p+E*S,s[7]=g*c+I*d+E*F,s[2]=C*l+Q*R+h*w,s[5]=C*B+Q*p+h*S,s[8]=C*c+Q*d+h*F,this}multiplyScalar(A){const e=this.elements;return e[0]*=A,e[3]*=A,e[6]*=A,e[1]*=A,e[4]*=A,e[7]*=A,e[2]*=A,e[5]*=A,e[8]*=A,this}determinant(){const A=this.elements,e=A[0],t=A[1],n=A[2],s=A[3],o=A[4],r=A[5],a=A[6],g=A[7],I=A[8];return e*o*I-e*r*g-t*s*I+t*r*a+n*s*g-n*o*a}invert(){const A=this.elements,e=A[0],t=A[1],n=A[2],s=A[3],o=A[4],r=A[5],a=A[6],g=A[7],I=A[8],E=I*o-r*g,C=r*a-I*s,Q=g*s-o*a,h=e*E+t*C+n*Q;if(h===0)return this.set(0,0,0,0,0,0,0,0,0);const l=1/h;return A[0]=E*l,A[1]=(n*g-I*t)*l,A[2]=(r*t-n*o)*l,A[3]=C*l,A[4]=(I*e-n*a)*l,A[5]=(n*s-r*e)*l,A[6]=Q*l,A[7]=(t*a-g*e)*l,A[8]=(o*e-t*s)*l,this}transpose(){let A;const e=this.elements;return A=e[1],e[1]=e[3],e[3]=A,A=e[2],e[2]=e[6],e[6]=A,A=e[5],e[5]=e[7],e[7]=A,this}getNormalMatrix(A){return this.setFromMatrix4(A).invert().transpose()}transposeIntoArray(A){const e=this.elements;return A[0]=e[0],A[1]=e[3],A[2]=e[6],A[3]=e[1],A[4]=e[4],A[5]=e[7],A[6]=e[2],A[7]=e[5],A[8]=e[8],this}setUvTransform(A,e,t,n,s,o,r){const a=Math.cos(s),g=Math.sin(s);return this.set(t*a,t*g,-t*(a*o+g*r)+o+A,-n*g,n*a,-n*(-g*o+a*r)+r+e,0,0,1),this}scale(A,e){return this.premultiply(Eo.makeScale(A,e)),this}rotate(A){return this.premultiply(Eo.makeRotation(-A)),this}translate(A,e){return this.premultiply(Eo.makeTranslation(A,e)),this}makeTranslation(A,e){return A.isVector2?this.set(1,0,A.x,0,1,A.y,0,0,1):this.set(1,0,A,0,1,e,0,0,1),this}makeRotation(A){const e=Math.cos(A),t=Math.sin(A);return this.set(e,-t,0,t,e,0,0,0,1),this}makeScale(A,e){return this.set(A,0,0,0,e,0,0,0,1),this}equals(A){const e=this.elements,t=A.elements;for(let n=0;n<9;n++)if(e[n]!==t[n])return!1;return!0}fromArray(A,e=0){for(let t=0;t<9;t++)this.elements[t]=A[t+e];return this}toArray(A=[],e=0){const t=this.elements;return A[e]=t[0],A[e+1]=t[1],A[e+2]=t[2],A[e+3]=t[3],A[e+4]=t[4],A[e+5]=t[5],A[e+6]=t[6],A[e+7]=t[7],A[e+8]=t[8],A}clone(){return new this.constructor().fromArray(this.elements)}}const Eo=new PA;function uE(i){for(let A=i.length-1;A>=0;--A)if(i[A]>=65535)return!0;return!1}function Jn(i){return document.createElementNS("http://www.w3.org/1999/xhtml",i)}function AB(){const i=Jn("canvas");return i.style.display="block",i}const ja={};function Xi(i){i in ja||(ja[i]=!0,console.warn(i))}function eB(i,A,e){return new Promise(function(t,n){function s(){switch(i.clientWaitSync(A,i.SYNC_FLUSH_COMMANDS_BIT,0)){case i.WAIT_FAILED:n();break;case i.TIMEOUT_EXPIRED:setTimeout(s,e);break;default:t()}}setTimeout(s,e)})}function tB(i){const A=i.elements;A[2]=.5*A[2]+.5*A[3],A[6]=.5*A[6]+.5*A[7],A[10]=.5*A[10]+.5*A[11],A[14]=.5*A[14]+.5*A[15]}function iB(i){const A=i.elements;A[11]===-1?(A[10]=-A[10]-1,A[14]=-A[14]):(A[10]=-A[10],A[14]=-A[14]+1)}const $a=new PA().set(.4123908,.3575843,.1804808,.212639,.7151687,.0721923,.0193308,.1191948,.9505322),Ag=new PA().set(3.2409699,-1.5373832,-.4986108,-.9692436,1.8759675,.0415551,.0556301,-.203977,1.0569715);function nB(){const i={enabled:!0,workingColorSpace:be,spaces:{},convert:function(n,s,o){return this.enabled===!1||s===o||!s||!o||(this.spaces[s].transfer===ge&&(n.r=Yt(n.r),n.g=Yt(n.g),n.b=Yt(n.b)),this.spaces[s].primaries!==this.spaces[o].primaries&&(n.applyMatrix3(this.spaces[s].toXYZ),n.applyMatrix3(this.spaces[o].fromXYZ)),this.spaces[o].transfer===ge&&(n.r=An(n.r),n.g=An(n.g),n.b=An(n.b))),n},fromWorkingColorSpace:function(n,s){return this.convert(n,this.workingColorSpace,s)},toWorkingColorSpace:function(n,s){return this.convert(n,s,this.workingColorSpace)},getPrimaries:function(n){return this.spaces[n].primaries},getTransfer:function(n){return n===ii?Ks:this.spaces[n].transfer},getLuminanceCoefficients:function(n,s=this.workingColorSpace){return n.fromArray(this.spaces[s].luminanceCoefficients)},define:function(n){Object.assign(this.spaces,n)},_getMatrix:function(n,s,o){return n.copy(this.spaces[s].toXYZ).multiply(this.spaces[o].fromXYZ)},_getDrawingBufferColorSpace:function(n){return this.spaces[n].outputColorSpaceConfig.drawingBufferColorSpace},_getUnpackColorSpace:function(n=this.workingColorSpace){return this.spaces[n].workingColorSpaceConfig.unpackColorSpace}},A=[.64,.33,.3,.6,.15,.06],e=[.2126,.7152,.0722],t=[.3127,.329];return i.define({[be]:{primaries:A,whitePoint:t,transfer:Ks,toXYZ:$a,fromXYZ:Ag,luminanceCoefficients:e,workingColorSpaceConfig:{unpackColorSpace:De},outputColorSpaceConfig:{drawingBufferColorSpace:De}},[De]:{primaries:A,whitePoint:t,transfer:ge,toXYZ:$a,fromXYZ:Ag,luminanceCoefficients:e,outputColorSpaceConfig:{drawingBufferColorSpace:De}}}),i}const $A=nB();function Yt(i){return i<.04045?i*.0773993808:Math.pow(i*.9478672986+.0521327014,2.4)}function An(i){return i<.0031308?i*12.92:1.055*Math.pow(i,.41666)-.055}let Li;class sB{static getDataURL(A){if(/^data:/i.test(A.src)||typeof HTMLCanvasElement>"u")return A.src;let e;if(A instanceof HTMLCanvasElement)e=A;else{Li===void 0&&(Li=Jn("canvas")),Li.width=A.width,Li.height=A.height;const t=Li.getContext("2d");A instanceof ImageData?t.putImageData(A,0,0):t.drawImage(A,0,0,A.width,A.height),e=Li}return e.width>2048||e.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",A),e.toDataURL("image/jpeg",.6)):e.toDataURL("image/png")}static sRGBToLinear(A){if(typeof HTMLImageElement<"u"&&A instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&A instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&A instanceof ImageBitmap){const e=Jn("canvas");e.width=A.width,e.height=A.height;const t=e.getContext("2d");t.drawImage(A,0,0,A.width,A.height);const n=t.getImageData(0,0,A.width,A.height),s=n.data;for(let o=0;o<s.length;o++)s[o]=Yt(s[o]/255)*255;return t.putImageData(n,0,0),e}else if(A.data){const e=A.data.slice(0);for(let t=0;t<e.length;t++)e instanceof Uint8Array||e instanceof Uint8ClampedArray?e[t]=Math.floor(Yt(e[t]/255)*255):e[t]=Yt(e[t]);return{data:e,width:A.width,height:A.height}}else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),A}}let oB=0;class fE{constructor(A=null){this.isSource=!0,Object.defineProperty(this,"id",{value:oB++}),this.uuid=dt(),this.data=A,this.dataReady=!0,this.version=0}set needsUpdate(A){A===!0&&this.version++}toJSON(A){const e=A===void 0||typeof A=="string";if(!e&&A.images[this.uuid]!==void 0)return A.images[this.uuid];const t={uuid:this.uuid,url:""},n=this.data;if(n!==null){let s;if(Array.isArray(n)){s=[];for(let o=0,r=n.length;o<r;o++)n[o].isDataTexture?s.push(Co(n[o].image)):s.push(Co(n[o]))}else s=Co(n);t.url=s}return e||(A.images[this.uuid]=t),t}}function Co(i){return typeof HTMLImageElement<"u"&&i instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&i instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&i instanceof ImageBitmap?sB.getDataURL(i):i.data?{data:Array.from(i.data),width:i.width,height:i.height,type:i.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}let rB=0;class de extends Si{constructor(A=de.DEFAULT_IMAGE,e=de.DEFAULT_MAPPING,t=ni,n=ni,s=ze,o=Ot,r=et,a=qt,g=de.DEFAULT_ANISOTROPY,I=ii){super(),this.isTexture=!0,Object.defineProperty(this,"id",{value:rB++}),this.uuid=dt(),this.name="",this.source=new fE(A),this.mipmaps=[],this.mapping=e,this.channel=0,this.wrapS=t,this.wrapT=n,this.magFilter=s,this.minFilter=o,this.anisotropy=g,this.format=r,this.internalFormat=null,this.type=a,this.offset=new bA(0,0),this.repeat=new bA(1,1),this.center=new bA(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new PA,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.colorSpace=I,this.userData={},this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1,this.pmremVersion=0}get image(){return this.source.data}set image(A=null){this.source.data=A}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return new this.constructor().copy(this)}copy(A){return this.name=A.name,this.source=A.source,this.mipmaps=A.mipmaps.slice(0),this.mapping=A.mapping,this.channel=A.channel,this.wrapS=A.wrapS,this.wrapT=A.wrapT,this.magFilter=A.magFilter,this.minFilter=A.minFilter,this.anisotropy=A.anisotropy,this.format=A.format,this.internalFormat=A.internalFormat,this.type=A.type,this.offset.copy(A.offset),this.repeat.copy(A.repeat),this.center.copy(A.center),this.rotation=A.rotation,this.matrixAutoUpdate=A.matrixAutoUpdate,this.matrix.copy(A.matrix),this.generateMipmaps=A.generateMipmaps,this.premultiplyAlpha=A.premultiplyAlpha,this.flipY=A.flipY,this.unpackAlignment=A.unpackAlignment,this.colorSpace=A.colorSpace,this.userData=JSON.parse(JSON.stringify(A.userData)),this.needsUpdate=!0,this}toJSON(A){const e=A===void 0||typeof A=="string";if(!e&&A.textures[this.uuid]!==void 0)return A.textures[this.uuid];const t={metadata:{version:4.6,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(A).uuid,mapping:this.mapping,channel:this.channel,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,internalFormat:this.internalFormat,type:this.type,colorSpace:this.colorSpace,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,generateMipmaps:this.generateMipmaps,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return Object.keys(this.userData).length>0&&(t.userData=this.userData),e||(A.textures[this.uuid]=t),t}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(A){if(this.mapping!==oE)return A;if(A.applyMatrix3(this.matrix),A.x<0||A.x>1)switch(this.wrapS){case rn:A.x=A.x-Math.floor(A.x);break;case ni:A.x=A.x<0?0:1;break;case Js:Math.abs(Math.floor(A.x)%2)===1?A.x=Math.ceil(A.x)-A.x:A.x=A.x-Math.floor(A.x);break}if(A.y<0||A.y>1)switch(this.wrapT){case rn:A.y=A.y-Math.floor(A.y);break;case ni:A.y=A.y<0?0:1;break;case Js:Math.abs(Math.floor(A.y)%2)===1?A.y=Math.ceil(A.y)-A.y:A.y=A.y-Math.floor(A.y);break}return this.flipY&&(A.y=1-A.y),A}set needsUpdate(A){A===!0&&(this.version++,this.source.needsUpdate=!0)}set needsPMREMUpdate(A){A===!0&&this.pmremVersion++}}de.DEFAULT_IMAGE=null;de.DEFAULT_MAPPING=oE;de.DEFAULT_ANISOTROPY=1;class YA{constructor(A=0,e=0,t=0,n=1){YA.prototype.isVector4=!0,this.x=A,this.y=e,this.z=t,this.w=n}get width(){return this.z}set width(A){this.z=A}get height(){return this.w}set height(A){this.w=A}set(A,e,t,n){return this.x=A,this.y=e,this.z=t,this.w=n,this}setScalar(A){return this.x=A,this.y=A,this.z=A,this.w=A,this}setX(A){return this.x=A,this}setY(A){return this.y=A,this}setZ(A){return this.z=A,this}setW(A){return this.w=A,this}setComponent(A,e){switch(A){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;case 3:this.w=e;break;default:throw new Error("index is out of range: "+A)}return this}getComponent(A){switch(A){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+A)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(A){return this.x=A.x,this.y=A.y,this.z=A.z,this.w=A.w!==void 0?A.w:1,this}add(A){return this.x+=A.x,this.y+=A.y,this.z+=A.z,this.w+=A.w,this}addScalar(A){return this.x+=A,this.y+=A,this.z+=A,this.w+=A,this}addVectors(A,e){return this.x=A.x+e.x,this.y=A.y+e.y,this.z=A.z+e.z,this.w=A.w+e.w,this}addScaledVector(A,e){return this.x+=A.x*e,this.y+=A.y*e,this.z+=A.z*e,this.w+=A.w*e,this}sub(A){return this.x-=A.x,this.y-=A.y,this.z-=A.z,this.w-=A.w,this}subScalar(A){return this.x-=A,this.y-=A,this.z-=A,this.w-=A,this}subVectors(A,e){return this.x=A.x-e.x,this.y=A.y-e.y,this.z=A.z-e.z,this.w=A.w-e.w,this}multiply(A){return this.x*=A.x,this.y*=A.y,this.z*=A.z,this.w*=A.w,this}multiplyScalar(A){return this.x*=A,this.y*=A,this.z*=A,this.w*=A,this}applyMatrix4(A){const e=this.x,t=this.y,n=this.z,s=this.w,o=A.elements;return this.x=o[0]*e+o[4]*t+o[8]*n+o[12]*s,this.y=o[1]*e+o[5]*t+o[9]*n+o[13]*s,this.z=o[2]*e+o[6]*t+o[10]*n+o[14]*s,this.w=o[3]*e+o[7]*t+o[11]*n+o[15]*s,this}divide(A){return this.x/=A.x,this.y/=A.y,this.z/=A.z,this.w/=A.w,this}divideScalar(A){return this.multiplyScalar(1/A)}setAxisAngleFromQuaternion(A){this.w=2*Math.acos(A.w);const e=Math.sqrt(1-A.w*A.w);return e<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=A.x/e,this.y=A.y/e,this.z=A.z/e),this}setAxisAngleFromRotationMatrix(A){let e,t,n,s;const a=A.elements,g=a[0],I=a[4],E=a[8],C=a[1],Q=a[5],h=a[9],l=a[2],B=a[6],c=a[10];if(Math.abs(I-C)<.01&&Math.abs(E-l)<.01&&Math.abs(h-B)<.01){if(Math.abs(I+C)<.1&&Math.abs(E+l)<.1&&Math.abs(h+B)<.1&&Math.abs(g+Q+c-3)<.1)return this.set(1,0,0,0),this;e=Math.PI;const p=(g+1)/2,d=(Q+1)/2,w=(c+1)/2,S=(I+C)/4,F=(E+l)/4,N=(h+B)/4;return p>d&&p>w?p<.01?(t=0,n=.707106781,s=.707106781):(t=Math.sqrt(p),n=S/t,s=F/t):d>w?d<.01?(t=.707106781,n=0,s=.707106781):(n=Math.sqrt(d),t=S/n,s=N/n):w<.01?(t=.707106781,n=.707106781,s=0):(s=Math.sqrt(w),t=F/s,n=N/s),this.set(t,n,s,e),this}let R=Math.sqrt((B-h)*(B-h)+(E-l)*(E-l)+(C-I)*(C-I));return Math.abs(R)<.001&&(R=1),this.x=(B-h)/R,this.y=(E-l)/R,this.z=(C-I)/R,this.w=Math.acos((g+Q+c-1)/2),this}setFromMatrixPosition(A){const e=A.elements;return this.x=e[12],this.y=e[13],this.z=e[14],this.w=e[15],this}min(A){return this.x=Math.min(this.x,A.x),this.y=Math.min(this.y,A.y),this.z=Math.min(this.z,A.z),this.w=Math.min(this.w,A.w),this}max(A){return this.x=Math.max(this.x,A.x),this.y=Math.max(this.y,A.y),this.z=Math.max(this.z,A.z),this.w=Math.max(this.w,A.w),this}clamp(A,e){return this.x=zA(this.x,A.x,e.x),this.y=zA(this.y,A.y,e.y),this.z=zA(this.z,A.z,e.z),this.w=zA(this.w,A.w,e.w),this}clampScalar(A,e){return this.x=zA(this.x,A,e),this.y=zA(this.y,A,e),this.z=zA(this.z,A,e),this.w=zA(this.w,A,e),this}clampLength(A,e){const t=this.length();return this.divideScalar(t||1).multiplyScalar(zA(t,A,e))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this.w=Math.trunc(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(A){return this.x*A.x+this.y*A.y+this.z*A.z+this.w*A.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(A){return this.normalize().multiplyScalar(A)}lerp(A,e){return this.x+=(A.x-this.x)*e,this.y+=(A.y-this.y)*e,this.z+=(A.z-this.z)*e,this.w+=(A.w-this.w)*e,this}lerpVectors(A,e,t){return this.x=A.x+(e.x-A.x)*t,this.y=A.y+(e.y-A.y)*t,this.z=A.z+(e.z-A.z)*t,this.w=A.w+(e.w-A.w)*t,this}equals(A){return A.x===this.x&&A.y===this.y&&A.z===this.z&&A.w===this.w}fromArray(A,e=0){return this.x=A[e],this.y=A[e+1],this.z=A[e+2],this.w=A[e+3],this}toArray(A=[],e=0){return A[e]=this.x,A[e+1]=this.y,A[e+2]=this.z,A[e+3]=this.w,A}fromBufferAttribute(A,e){return this.x=A.getX(e),this.y=A.getY(e),this.z=A.getZ(e),this.w=A.getW(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}class aB extends Si{constructor(A=1,e=1,t={}){super(),this.isRenderTarget=!0,this.width=A,this.height=e,this.depth=1,this.scissor=new YA(0,0,A,e),this.scissorTest=!1,this.viewport=new YA(0,0,A,e);const n={width:A,height:e,depth:1};t=Object.assign({generateMipmaps:!1,internalFormat:null,minFilter:ze,depthBuffer:!0,stencilBuffer:!1,resolveDepthBuffer:!0,resolveStencilBuffer:!0,depthTexture:null,samples:0,count:1},t);const s=new de(n,t.mapping,t.wrapS,t.wrapT,t.magFilter,t.minFilter,t.format,t.type,t.anisotropy,t.colorSpace);s.flipY=!1,s.generateMipmaps=t.generateMipmaps,s.internalFormat=t.internalFormat,this.textures=[];const o=t.count;for(let r=0;r<o;r++)this.textures[r]=s.clone(),this.textures[r].isRenderTargetTexture=!0;this.depthBuffer=t.depthBuffer,this.stencilBuffer=t.stencilBuffer,this.resolveDepthBuffer=t.resolveDepthBuffer,this.resolveStencilBuffer=t.resolveStencilBuffer,this.depthTexture=t.depthTexture,this.samples=t.samples}get texture(){return this.textures[0]}set texture(A){this.textures[0]=A}setSize(A,e,t=1){if(this.width!==A||this.height!==e||this.depth!==t){this.width=A,this.height=e,this.depth=t;for(let n=0,s=this.textures.length;n<s;n++)this.textures[n].image.width=A,this.textures[n].image.height=e,this.textures[n].image.depth=t;this.dispose()}this.viewport.set(0,0,A,e),this.scissor.set(0,0,A,e)}clone(){return new this.constructor().copy(this)}copy(A){this.width=A.width,this.height=A.height,this.depth=A.depth,this.scissor.copy(A.scissor),this.scissorTest=A.scissorTest,this.viewport.copy(A.viewport),this.textures.length=0;for(let t=0,n=A.textures.length;t<n;t++)this.textures[t]=A.textures[t].clone(),this.textures[t].isRenderTargetTexture=!0;const e=Object.assign({},A.texture.image);return this.texture.source=new fE(e),this.depthBuffer=A.depthBuffer,this.stencilBuffer=A.stencilBuffer,this.resolveDepthBuffer=A.resolveDepthBuffer,this.resolveStencilBuffer=A.resolveStencilBuffer,A.depthTexture!==null&&(this.depthTexture=A.depthTexture.clone()),this.samples=A.samples,this}dispose(){this.dispatchEvent({type:"dispose"})}}class wi extends aB{constructor(A=1,e=1,t={}){super(A,e,t),this.isWebGLRenderTarget=!0}}class pE extends de{constructor(A=null,e=1,t=1,n=1){super(null),this.isDataArrayTexture=!0,this.image={data:A,width:e,height:t,depth:n},this.magFilter=Te,this.minFilter=Te,this.wrapR=ni,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.layerUpdates=new Set}addLayerUpdate(A){this.layerUpdates.add(A)}clearLayerUpdates(){this.layerUpdates.clear()}}class gB extends de{constructor(A=null,e=1,t=1,n=1){super(null),this.isData3DTexture=!0,this.image={data:A,width:e,height:t,depth:n},this.magFilter=Te,this.minFilter=Te,this.wrapR=ni,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class Ii{constructor(A=0,e=0,t=0,n=1){this.isQuaternion=!0,this._x=A,this._y=e,this._z=t,this._w=n}static slerpFlat(A,e,t,n,s,o,r){let a=t[n+0],g=t[n+1],I=t[n+2],E=t[n+3];const C=s[o+0],Q=s[o+1],h=s[o+2],l=s[o+3];if(r===0){A[e+0]=a,A[e+1]=g,A[e+2]=I,A[e+3]=E;return}if(r===1){A[e+0]=C,A[e+1]=Q,A[e+2]=h,A[e+3]=l;return}if(E!==l||a!==C||g!==Q||I!==h){let B=1-r;const c=a*C+g*Q+I*h+E*l,R=c>=0?1:-1,p=1-c*c;if(p>Number.EPSILON){const w=Math.sqrt(p),S=Math.atan2(w,c*R);B=Math.sin(B*S)/w,r=Math.sin(r*S)/w}const d=r*R;if(a=a*B+C*d,g=g*B+Q*d,I=I*B+h*d,E=E*B+l*d,B===1-r){const w=1/Math.sqrt(a*a+g*g+I*I+E*E);a*=w,g*=w,I*=w,E*=w}}A[e]=a,A[e+1]=g,A[e+2]=I,A[e+3]=E}static multiplyQuaternionsFlat(A,e,t,n,s,o){const r=t[n],a=t[n+1],g=t[n+2],I=t[n+3],E=s[o],C=s[o+1],Q=s[o+2],h=s[o+3];return A[e]=r*h+I*E+a*Q-g*C,A[e+1]=a*h+I*C+g*E-r*Q,A[e+2]=g*h+I*Q+r*C-a*E,A[e+3]=I*h-r*E-a*C-g*Q,A}get x(){return this._x}set x(A){this._x=A,this._onChangeCallback()}get y(){return this._y}set y(A){this._y=A,this._onChangeCallback()}get z(){return this._z}set z(A){this._z=A,this._onChangeCallback()}get w(){return this._w}set w(A){this._w=A,this._onChangeCallback()}set(A,e,t,n){return this._x=A,this._y=e,this._z=t,this._w=n,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(A){return this._x=A.x,this._y=A.y,this._z=A.z,this._w=A.w,this._onChangeCallback(),this}setFromEuler(A,e=!0){const t=A._x,n=A._y,s=A._z,o=A._order,r=Math.cos,a=Math.sin,g=r(t/2),I=r(n/2),E=r(s/2),C=a(t/2),Q=a(n/2),h=a(s/2);switch(o){case"XYZ":this._x=C*I*E+g*Q*h,this._y=g*Q*E-C*I*h,this._z=g*I*h+C*Q*E,this._w=g*I*E-C*Q*h;break;case"YXZ":this._x=C*I*E+g*Q*h,this._y=g*Q*E-C*I*h,this._z=g*I*h-C*Q*E,this._w=g*I*E+C*Q*h;break;case"ZXY":this._x=C*I*E-g*Q*h,this._y=g*Q*E+C*I*h,this._z=g*I*h+C*Q*E,this._w=g*I*E-C*Q*h;break;case"ZYX":this._x=C*I*E-g*Q*h,this._y=g*Q*E+C*I*h,this._z=g*I*h-C*Q*E,this._w=g*I*E+C*Q*h;break;case"YZX":this._x=C*I*E+g*Q*h,this._y=g*Q*E+C*I*h,this._z=g*I*h-C*Q*E,this._w=g*I*E-C*Q*h;break;case"XZY":this._x=C*I*E-g*Q*h,this._y=g*Q*E-C*I*h,this._z=g*I*h+C*Q*E,this._w=g*I*E+C*Q*h;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+o)}return e===!0&&this._onChangeCallback(),this}setFromAxisAngle(A,e){const t=e/2,n=Math.sin(t);return this._x=A.x*n,this._y=A.y*n,this._z=A.z*n,this._w=Math.cos(t),this._onChangeCallback(),this}setFromRotationMatrix(A){const e=A.elements,t=e[0],n=e[4],s=e[8],o=e[1],r=e[5],a=e[9],g=e[2],I=e[6],E=e[10],C=t+r+E;if(C>0){const Q=.5/Math.sqrt(C+1);this._w=.25/Q,this._x=(I-a)*Q,this._y=(s-g)*Q,this._z=(o-n)*Q}else if(t>r&&t>E){const Q=2*Math.sqrt(1+t-r-E);this._w=(I-a)/Q,this._x=.25*Q,this._y=(n+o)/Q,this._z=(s+g)/Q}else if(r>E){const Q=2*Math.sqrt(1+r-t-E);this._w=(s-g)/Q,this._x=(n+o)/Q,this._y=.25*Q,this._z=(a+I)/Q}else{const Q=2*Math.sqrt(1+E-t-r);this._w=(o-n)/Q,this._x=(s+g)/Q,this._y=(a+I)/Q,this._z=.25*Q}return this._onChangeCallback(),this}setFromUnitVectors(A,e){let t=A.dot(e)+1;return t<Number.EPSILON?(t=0,Math.abs(A.x)>Math.abs(A.z)?(this._x=-A.y,this._y=A.x,this._z=0,this._w=t):(this._x=0,this._y=-A.z,this._z=A.y,this._w=t)):(this._x=A.y*e.z-A.z*e.y,this._y=A.z*e.x-A.x*e.z,this._z=A.x*e.y-A.y*e.x,this._w=t),this.normalize()}angleTo(A){return 2*Math.acos(Math.abs(zA(this.dot(A),-1,1)))}rotateTowards(A,e){const t=this.angleTo(A);if(t===0)return this;const n=Math.min(1,e/t);return this.slerp(A,n),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(A){return this._x*A._x+this._y*A._y+this._z*A._z+this._w*A._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let A=this.length();return A===0?(this._x=0,this._y=0,this._z=0,this._w=1):(A=1/A,this._x=this._x*A,this._y=this._y*A,this._z=this._z*A,this._w=this._w*A),this._onChangeCallback(),this}multiply(A){return this.multiplyQuaternions(this,A)}premultiply(A){return this.multiplyQuaternions(A,this)}multiplyQuaternions(A,e){const t=A._x,n=A._y,s=A._z,o=A._w,r=e._x,a=e._y,g=e._z,I=e._w;return this._x=t*I+o*r+n*g-s*a,this._y=n*I+o*a+s*r-t*g,this._z=s*I+o*g+t*a-n*r,this._w=o*I-t*r-n*a-s*g,this._onChangeCallback(),this}slerp(A,e){if(e===0)return this;if(e===1)return this.copy(A);const t=this._x,n=this._y,s=this._z,o=this._w;let r=o*A._w+t*A._x+n*A._y+s*A._z;if(r<0?(this._w=-A._w,this._x=-A._x,this._y=-A._y,this._z=-A._z,r=-r):this.copy(A),r>=1)return this._w=o,this._x=t,this._y=n,this._z=s,this;const a=1-r*r;if(a<=Number.EPSILON){const Q=1-e;return this._w=Q*o+e*this._w,this._x=Q*t+e*this._x,this._y=Q*n+e*this._y,this._z=Q*s+e*this._z,this.normalize(),this}const g=Math.sqrt(a),I=Math.atan2(g,r),E=Math.sin((1-e)*I)/g,C=Math.sin(e*I)/g;return this._w=o*E+this._w*C,this._x=t*E+this._x*C,this._y=n*E+this._y*C,this._z=s*E+this._z*C,this._onChangeCallback(),this}slerpQuaternions(A,e,t){return this.copy(A).slerp(e,t)}random(){const A=2*Math.PI*Math.random(),e=2*Math.PI*Math.random(),t=Math.random(),n=Math.sqrt(1-t),s=Math.sqrt(t);return this.set(n*Math.sin(A),n*Math.cos(A),s*Math.sin(e),s*Math.cos(e))}equals(A){return A._x===this._x&&A._y===this._y&&A._z===this._z&&A._w===this._w}fromArray(A,e=0){return this._x=A[e],this._y=A[e+1],this._z=A[e+2],this._w=A[e+3],this._onChangeCallback(),this}toArray(A=[],e=0){return A[e]=this._x,A[e+1]=this._y,A[e+2]=this._z,A[e+3]=this._w,A}fromBufferAttribute(A,e){return this._x=A.getX(e),this._y=A.getY(e),this._z=A.getZ(e),this._w=A.getW(e),this._onChangeCallback(),this}toJSON(){return this.toArray()}_onChange(A){return this._onChangeCallback=A,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class L{constructor(A=0,e=0,t=0){L.prototype.isVector3=!0,this.x=A,this.y=e,this.z=t}set(A,e,t){return t===void 0&&(t=this.z),this.x=A,this.y=e,this.z=t,this}setScalar(A){return this.x=A,this.y=A,this.z=A,this}setX(A){return this.x=A,this}setY(A){return this.y=A,this}setZ(A){return this.z=A,this}setComponent(A,e){switch(A){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;default:throw new Error("index is out of range: "+A)}return this}getComponent(A){switch(A){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+A)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(A){return this.x=A.x,this.y=A.y,this.z=A.z,this}add(A){return this.x+=A.x,this.y+=A.y,this.z+=A.z,this}addScalar(A){return this.x+=A,this.y+=A,this.z+=A,this}addVectors(A,e){return this.x=A.x+e.x,this.y=A.y+e.y,this.z=A.z+e.z,this}addScaledVector(A,e){return this.x+=A.x*e,this.y+=A.y*e,this.z+=A.z*e,this}sub(A){return this.x-=A.x,this.y-=A.y,this.z-=A.z,this}subScalar(A){return this.x-=A,this.y-=A,this.z-=A,this}subVectors(A,e){return this.x=A.x-e.x,this.y=A.y-e.y,this.z=A.z-e.z,this}multiply(A){return this.x*=A.x,this.y*=A.y,this.z*=A.z,this}multiplyScalar(A){return this.x*=A,this.y*=A,this.z*=A,this}multiplyVectors(A,e){return this.x=A.x*e.x,this.y=A.y*e.y,this.z=A.z*e.z,this}applyEuler(A){return this.applyQuaternion(eg.setFromEuler(A))}applyAxisAngle(A,e){return this.applyQuaternion(eg.setFromAxisAngle(A,e))}applyMatrix3(A){const e=this.x,t=this.y,n=this.z,s=A.elements;return this.x=s[0]*e+s[3]*t+s[6]*n,this.y=s[1]*e+s[4]*t+s[7]*n,this.z=s[2]*e+s[5]*t+s[8]*n,this}applyNormalMatrix(A){return this.applyMatrix3(A).normalize()}applyMatrix4(A){const e=this.x,t=this.y,n=this.z,s=A.elements,o=1/(s[3]*e+s[7]*t+s[11]*n+s[15]);return this.x=(s[0]*e+s[4]*t+s[8]*n+s[12])*o,this.y=(s[1]*e+s[5]*t+s[9]*n+s[13])*o,this.z=(s[2]*e+s[6]*t+s[10]*n+s[14])*o,this}applyQuaternion(A){const e=this.x,t=this.y,n=this.z,s=A.x,o=A.y,r=A.z,a=A.w,g=2*(o*n-r*t),I=2*(r*e-s*n),E=2*(s*t-o*e);return this.x=e+a*g+o*E-r*I,this.y=t+a*I+r*g-s*E,this.z=n+a*E+s*I-o*g,this}project(A){return this.applyMatrix4(A.matrixWorldInverse).applyMatrix4(A.projectionMatrix)}unproject(A){return this.applyMatrix4(A.projectionMatrixInverse).applyMatrix4(A.matrixWorld)}transformDirection(A){const e=this.x,t=this.y,n=this.z,s=A.elements;return this.x=s[0]*e+s[4]*t+s[8]*n,this.y=s[1]*e+s[5]*t+s[9]*n,this.z=s[2]*e+s[6]*t+s[10]*n,this.normalize()}divide(A){return this.x/=A.x,this.y/=A.y,this.z/=A.z,this}divideScalar(A){return this.multiplyScalar(1/A)}min(A){return this.x=Math.min(this.x,A.x),this.y=Math.min(this.y,A.y),this.z=Math.min(this.z,A.z),this}max(A){return this.x=Math.max(this.x,A.x),this.y=Math.max(this.y,A.y),this.z=Math.max(this.z,A.z),this}clamp(A,e){return this.x=zA(this.x,A.x,e.x),this.y=zA(this.y,A.y,e.y),this.z=zA(this.z,A.z,e.z),this}clampScalar(A,e){return this.x=zA(this.x,A,e),this.y=zA(this.y,A,e),this.z=zA(this.z,A,e),this}clampLength(A,e){const t=this.length();return this.divideScalar(t||1).multiplyScalar(zA(t,A,e))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(A){return this.x*A.x+this.y*A.y+this.z*A.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(A){return this.normalize().multiplyScalar(A)}lerp(A,e){return this.x+=(A.x-this.x)*e,this.y+=(A.y-this.y)*e,this.z+=(A.z-this.z)*e,this}lerpVectors(A,e,t){return this.x=A.x+(e.x-A.x)*t,this.y=A.y+(e.y-A.y)*t,this.z=A.z+(e.z-A.z)*t,this}cross(A){return this.crossVectors(this,A)}crossVectors(A,e){const t=A.x,n=A.y,s=A.z,o=e.x,r=e.y,a=e.z;return this.x=n*a-s*r,this.y=s*o-t*a,this.z=t*r-n*o,this}projectOnVector(A){const e=A.lengthSq();if(e===0)return this.set(0,0,0);const t=A.dot(this)/e;return this.copy(A).multiplyScalar(t)}projectOnPlane(A){return Qo.copy(this).projectOnVector(A),this.sub(Qo)}reflect(A){return this.sub(Qo.copy(A).multiplyScalar(2*this.dot(A)))}angleTo(A){const e=Math.sqrt(this.lengthSq()*A.lengthSq());if(e===0)return Math.PI/2;const t=this.dot(A)/e;return Math.acos(zA(t,-1,1))}distanceTo(A){return Math.sqrt(this.distanceToSquared(A))}distanceToSquared(A){const e=this.x-A.x,t=this.y-A.y,n=this.z-A.z;return e*e+t*t+n*n}manhattanDistanceTo(A){return Math.abs(this.x-A.x)+Math.abs(this.y-A.y)+Math.abs(this.z-A.z)}setFromSpherical(A){return this.setFromSphericalCoords(A.radius,A.phi,A.theta)}setFromSphericalCoords(A,e,t){const n=Math.sin(e)*A;return this.x=n*Math.sin(t),this.y=Math.cos(e)*A,this.z=n*Math.cos(t),this}setFromCylindrical(A){return this.setFromCylindricalCoords(A.radius,A.theta,A.y)}setFromCylindricalCoords(A,e,t){return this.x=A*Math.sin(e),this.y=t,this.z=A*Math.cos(e),this}setFromMatrixPosition(A){const e=A.elements;return this.x=e[12],this.y=e[13],this.z=e[14],this}setFromMatrixScale(A){const e=this.setFromMatrixColumn(A,0).length(),t=this.setFromMatrixColumn(A,1).length(),n=this.setFromMatrixColumn(A,2).length();return this.x=e,this.y=t,this.z=n,this}setFromMatrixColumn(A,e){return this.fromArray(A.elements,e*4)}setFromMatrix3Column(A,e){return this.fromArray(A.elements,e*3)}setFromEuler(A){return this.x=A._x,this.y=A._y,this.z=A._z,this}setFromColor(A){return this.x=A.r,this.y=A.g,this.z=A.b,this}equals(A){return A.x===this.x&&A.y===this.y&&A.z===this.z}fromArray(A,e=0){return this.x=A[e],this.y=A[e+1],this.z=A[e+2],this}toArray(A=[],e=0){return A[e]=this.x,A[e+1]=this.y,A[e+2]=this.z,A}fromBufferAttribute(A,e){return this.x=A.getX(e),this.y=A.getY(e),this.z=A.getZ(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const A=Math.random()*Math.PI*2,e=Math.random()*2-1,t=Math.sqrt(1-e*e);return this.x=t*Math.cos(A),this.y=e,this.z=t*Math.sin(A),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const Qo=new L,eg=new Ii;class rt{constructor(A=new L(1/0,1/0,1/0),e=new L(-1/0,-1/0,-1/0)){this.isBox3=!0,this.min=A,this.max=e}set(A,e){return this.min.copy(A),this.max.copy(e),this}setFromArray(A){this.makeEmpty();for(let e=0,t=A.length;e<t;e+=3)this.expandByPoint(It.fromArray(A,e));return this}setFromBufferAttribute(A){this.makeEmpty();for(let e=0,t=A.count;e<t;e++)this.expandByPoint(It.fromBufferAttribute(A,e));return this}setFromPoints(A){this.makeEmpty();for(let e=0,t=A.length;e<t;e++)this.expandByPoint(A[e]);return this}setFromCenterAndSize(A,e){const t=It.copy(e).multiplyScalar(.5);return this.min.copy(A).sub(t),this.max.copy(A).add(t),this}setFromObject(A,e=!1){return this.makeEmpty(),this.expandByObject(A,e)}clone(){return new this.constructor().copy(this)}copy(A){return this.min.copy(A.min),this.max.copy(A.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(A){return this.isEmpty()?A.set(0,0,0):A.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(A){return this.isEmpty()?A.set(0,0,0):A.subVectors(this.max,this.min)}expandByPoint(A){return this.min.min(A),this.max.max(A),this}expandByVector(A){return this.min.sub(A),this.max.add(A),this}expandByScalar(A){return this.min.addScalar(-A),this.max.addScalar(A),this}expandByObject(A,e=!1){A.updateWorldMatrix(!1,!1);const t=A.geometry;if(t!==void 0){const s=t.getAttribute("position");if(e===!0&&s!==void 0&&A.isInstancedMesh!==!0)for(let o=0,r=s.count;o<r;o++)A.isMesh===!0?A.getVertexPosition(o,It):It.fromBufferAttribute(s,o),It.applyMatrix4(A.matrixWorld),this.expandByPoint(It);else A.boundingBox!==void 0?(A.boundingBox===null&&A.computeBoundingBox(),jn.copy(A.boundingBox)):(t.boundingBox===null&&t.computeBoundingBox(),jn.copy(t.boundingBox)),jn.applyMatrix4(A.matrixWorld),this.union(jn)}const n=A.children;for(let s=0,o=n.length;s<o;s++)this.expandByObject(n[s],e);return this}containsPoint(A){return A.x>=this.min.x&&A.x<=this.max.x&&A.y>=this.min.y&&A.y<=this.max.y&&A.z>=this.min.z&&A.z<=this.max.z}containsBox(A){return this.min.x<=A.min.x&&A.max.x<=this.max.x&&this.min.y<=A.min.y&&A.max.y<=this.max.y&&this.min.z<=A.min.z&&A.max.z<=this.max.z}getParameter(A,e){return e.set((A.x-this.min.x)/(this.max.x-this.min.x),(A.y-this.min.y)/(this.max.y-this.min.y),(A.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(A){return A.max.x>=this.min.x&&A.min.x<=this.max.x&&A.max.y>=this.min.y&&A.min.y<=this.max.y&&A.max.z>=this.min.z&&A.min.z<=this.max.z}intersectsSphere(A){return this.clampPoint(A.center,It),It.distanceToSquared(A.center)<=A.radius*A.radius}intersectsPlane(A){let e,t;return A.normal.x>0?(e=A.normal.x*this.min.x,t=A.normal.x*this.max.x):(e=A.normal.x*this.max.x,t=A.normal.x*this.min.x),A.normal.y>0?(e+=A.normal.y*this.min.y,t+=A.normal.y*this.max.y):(e+=A.normal.y*this.max.y,t+=A.normal.y*this.min.y),A.normal.z>0?(e+=A.normal.z*this.min.z,t+=A.normal.z*this.max.z):(e+=A.normal.z*this.max.z,t+=A.normal.z*this.min.z),e<=-A.constant&&t>=-A.constant}intersectsTriangle(A){if(this.isEmpty())return!1;this.getCenter(fn),$n.subVectors(this.max,fn),_i.subVectors(A.a,fn),Ui.subVectors(A.b,fn),Gi.subVectors(A.c,fn),Vt.subVectors(Ui,_i),zt.subVectors(Gi,Ui),Bi.subVectors(_i,Gi);let e=[0,-Vt.z,Vt.y,0,-zt.z,zt.y,0,-Bi.z,Bi.y,Vt.z,0,-Vt.x,zt.z,0,-zt.x,Bi.z,0,-Bi.x,-Vt.y,Vt.x,0,-zt.y,zt.x,0,-Bi.y,Bi.x,0];return!Bo(e,_i,Ui,Gi,$n)||(e=[1,0,0,0,1,0,0,0,1],!Bo(e,_i,Ui,Gi,$n))?!1:(As.crossVectors(Vt,zt),e=[As.x,As.y,As.z],Bo(e,_i,Ui,Gi,$n))}clampPoint(A,e){return e.copy(A).clamp(this.min,this.max)}distanceToPoint(A){return this.clampPoint(A,It).distanceTo(A)}getBoundingSphere(A){return this.isEmpty()?A.makeEmpty():(this.getCenter(A.center),A.radius=this.getSize(It).length()*.5),A}intersect(A){return this.min.max(A.min),this.max.min(A.max),this.isEmpty()&&this.makeEmpty(),this}union(A){return this.min.min(A.min),this.max.max(A.max),this}applyMatrix4(A){return this.isEmpty()?this:(Ft[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(A),Ft[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(A),Ft[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(A),Ft[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(A),Ft[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(A),Ft[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(A),Ft[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(A),Ft[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(A),this.setFromPoints(Ft),this)}translate(A){return this.min.add(A),this.max.add(A),this}equals(A){return A.min.equals(this.min)&&A.max.equals(this.max)}}const Ft=[new L,new L,new L,new L,new L,new L,new L,new L],It=new L,jn=new rt,_i=new L,Ui=new L,Gi=new L,Vt=new L,zt=new L,Bi=new L,fn=new L,$n=new L,As=new L,ci=new L;function Bo(i,A,e,t,n){for(let s=0,o=i.length-3;s<=o;s+=3){ci.fromArray(i,s);const r=n.x*Math.abs(ci.x)+n.y*Math.abs(ci.y)+n.z*Math.abs(ci.z),a=A.dot(ci),g=e.dot(ci),I=t.dot(ci);if(Math.max(-Math.max(a,g,I),Math.min(a,g,I))>r)return!1}return!0}const IB=new rt,pn=new L,co=new L;class Dt{constructor(A=new L,e=-1){this.isSphere=!0,this.center=A,this.radius=e}set(A,e){return this.center.copy(A),this.radius=e,this}setFromPoints(A,e){const t=this.center;e!==void 0?t.copy(e):IB.setFromPoints(A).getCenter(t);let n=0;for(let s=0,o=A.length;s<o;s++)n=Math.max(n,t.distanceToSquared(A[s]));return this.radius=Math.sqrt(n),this}copy(A){return this.center.copy(A.center),this.radius=A.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(A){return A.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(A){return A.distanceTo(this.center)-this.radius}intersectsSphere(A){const e=this.radius+A.radius;return A.center.distanceToSquared(this.center)<=e*e}intersectsBox(A){return A.intersectsSphere(this)}intersectsPlane(A){return Math.abs(A.distanceToPoint(this.center))<=this.radius}clampPoint(A,e){const t=this.center.distanceToSquared(A);return e.copy(A),t>this.radius*this.radius&&(e.sub(this.center).normalize(),e.multiplyScalar(this.radius).add(this.center)),e}getBoundingBox(A){return this.isEmpty()?(A.makeEmpty(),A):(A.set(this.center,this.center),A.expandByScalar(this.radius),A)}applyMatrix4(A){return this.center.applyMatrix4(A),this.radius=this.radius*A.getMaxScaleOnAxis(),this}translate(A){return this.center.add(A),this}expandByPoint(A){if(this.isEmpty())return this.center.copy(A),this.radius=0,this;pn.subVectors(A,this.center);const e=pn.lengthSq();if(e>this.radius*this.radius){const t=Math.sqrt(e),n=(t-this.radius)*.5;this.center.addScaledVector(pn,n/t),this.radius+=n}return this}union(A){return A.isEmpty()?this:this.isEmpty()?(this.copy(A),this):(this.center.equals(A.center)===!0?this.radius=Math.max(this.radius,A.radius):(co.subVectors(A.center,this.center).setLength(A.radius),this.expandByPoint(pn.copy(A.center).add(co)),this.expandByPoint(pn.copy(A.center).sub(co))),this)}equals(A){return A.center.equals(this.center)&&A.radius===this.radius}clone(){return new this.constructor().copy(this)}}const Lt=new L,ho=new L,es=new L,Xt=new L,lo=new L,ts=new L,uo=new L;class Mi{constructor(A=new L,e=new L(0,0,-1)){this.origin=A,this.direction=e}set(A,e){return this.origin.copy(A),this.direction.copy(e),this}copy(A){return this.origin.copy(A.origin),this.direction.copy(A.direction),this}at(A,e){return e.copy(this.origin).addScaledVector(this.direction,A)}lookAt(A){return this.direction.copy(A).sub(this.origin).normalize(),this}recast(A){return this.origin.copy(this.at(A,Lt)),this}closestPointToPoint(A,e){e.subVectors(A,this.origin);const t=e.dot(this.direction);return t<0?e.copy(this.origin):e.copy(this.origin).addScaledVector(this.direction,t)}distanceToPoint(A){return Math.sqrt(this.distanceSqToPoint(A))}distanceSqToPoint(A){const e=Lt.subVectors(A,this.origin).dot(this.direction);return e<0?this.origin.distanceToSquared(A):(Lt.copy(this.origin).addScaledVector(this.direction,e),Lt.distanceToSquared(A))}distanceSqToSegment(A,e,t,n){ho.copy(A).add(e).multiplyScalar(.5),es.copy(e).sub(A).normalize(),Xt.copy(this.origin).sub(ho);const s=A.distanceTo(e)*.5,o=-this.direction.dot(es),r=Xt.dot(this.direction),a=-Xt.dot(es),g=Xt.lengthSq(),I=Math.abs(1-o*o);let E,C,Q,h;if(I>0)if(E=o*a-r,C=o*r-a,h=s*I,E>=0)if(C>=-h)if(C<=h){const l=1/I;E*=l,C*=l,Q=E*(E+o*C+2*r)+C*(o*E+C+2*a)+g}else C=s,E=Math.max(0,-(o*C+r)),Q=-E*E+C*(C+2*a)+g;else C=-s,E=Math.max(0,-(o*C+r)),Q=-E*E+C*(C+2*a)+g;else C<=-h?(E=Math.max(0,-(-o*s+r)),C=E>0?-s:Math.min(Math.max(-s,-a),s),Q=-E*E+C*(C+2*a)+g):C<=h?(E=0,C=Math.min(Math.max(-s,-a),s),Q=C*(C+2*a)+g):(E=Math.max(0,-(o*s+r)),C=E>0?s:Math.min(Math.max(-s,-a),s),Q=-E*E+C*(C+2*a)+g);else C=o>0?-s:s,E=Math.max(0,-(o*C+r)),Q=-E*E+C*(C+2*a)+g;return t&&t.copy(this.origin).addScaledVector(this.direction,E),n&&n.copy(ho).addScaledVector(es,C),Q}intersectSphere(A,e){Lt.subVectors(A.center,this.origin);const t=Lt.dot(this.direction),n=Lt.dot(Lt)-t*t,s=A.radius*A.radius;if(n>s)return null;const o=Math.sqrt(s-n),r=t-o,a=t+o;return a<0?null:r<0?this.at(a,e):this.at(r,e)}intersectsSphere(A){return this.distanceSqToPoint(A.center)<=A.radius*A.radius}distanceToPlane(A){const e=A.normal.dot(this.direction);if(e===0)return A.distanceToPoint(this.origin)===0?0:null;const t=-(this.origin.dot(A.normal)+A.constant)/e;return t>=0?t:null}intersectPlane(A,e){const t=this.distanceToPlane(A);return t===null?null:this.at(t,e)}intersectsPlane(A){const e=A.distanceToPoint(this.origin);return e===0||A.normal.dot(this.direction)*e<0}intersectBox(A,e){let t,n,s,o,r,a;const g=1/this.direction.x,I=1/this.direction.y,E=1/this.direction.z,C=this.origin;return g>=0?(t=(A.min.x-C.x)*g,n=(A.max.x-C.x)*g):(t=(A.max.x-C.x)*g,n=(A.min.x-C.x)*g),I>=0?(s=(A.min.y-C.y)*I,o=(A.max.y-C.y)*I):(s=(A.max.y-C.y)*I,o=(A.min.y-C.y)*I),t>o||s>n||((s>t||isNaN(t))&&(t=s),(o<n||isNaN(n))&&(n=o),E>=0?(r=(A.min.z-C.z)*E,a=(A.max.z-C.z)*E):(r=(A.max.z-C.z)*E,a=(A.min.z-C.z)*E),t>a||r>n)||((r>t||t!==t)&&(t=r),(a<n||n!==n)&&(n=a),n<0)?null:this.at(t>=0?t:n,e)}intersectsBox(A){return this.intersectBox(A,Lt)!==null}intersectTriangle(A,e,t,n,s){lo.subVectors(e,A),ts.subVectors(t,A),uo.crossVectors(lo,ts);let o=this.direction.dot(uo),r;if(o>0){if(n)return null;r=1}else if(o<0)r=-1,o=-o;else return null;Xt.subVectors(this.origin,A);const a=r*this.direction.dot(ts.crossVectors(Xt,ts));if(a<0)return null;const g=r*this.direction.dot(lo.cross(Xt));if(g<0||a+g>o)return null;const I=-r*Xt.dot(uo);return I<0?null:this.at(I/o,s)}applyMatrix4(A){return this.origin.applyMatrix4(A),this.direction.transformDirection(A),this}equals(A){return A.origin.equals(this.origin)&&A.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}class UA{constructor(A,e,t,n,s,o,r,a,g,I,E,C,Q,h,l,B){UA.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],A!==void 0&&this.set(A,e,t,n,s,o,r,a,g,I,E,C,Q,h,l,B)}set(A,e,t,n,s,o,r,a,g,I,E,C,Q,h,l,B){const c=this.elements;return c[0]=A,c[4]=e,c[8]=t,c[12]=n,c[1]=s,c[5]=o,c[9]=r,c[13]=a,c[2]=g,c[6]=I,c[10]=E,c[14]=C,c[3]=Q,c[7]=h,c[11]=l,c[15]=B,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new UA().fromArray(this.elements)}copy(A){const e=this.elements,t=A.elements;return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],this}copyPosition(A){const e=this.elements,t=A.elements;return e[12]=t[12],e[13]=t[13],e[14]=t[14],this}setFromMatrix3(A){const e=A.elements;return this.set(e[0],e[3],e[6],0,e[1],e[4],e[7],0,e[2],e[5],e[8],0,0,0,0,1),this}extractBasis(A,e,t){return A.setFromMatrixColumn(this,0),e.setFromMatrixColumn(this,1),t.setFromMatrixColumn(this,2),this}makeBasis(A,e,t){return this.set(A.x,e.x,t.x,0,A.y,e.y,t.y,0,A.z,e.z,t.z,0,0,0,0,1),this}extractRotation(A){const e=this.elements,t=A.elements,n=1/vi.setFromMatrixColumn(A,0).length(),s=1/vi.setFromMatrixColumn(A,1).length(),o=1/vi.setFromMatrixColumn(A,2).length();return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e[3]=0,e[4]=t[4]*s,e[5]=t[5]*s,e[6]=t[6]*s,e[7]=0,e[8]=t[8]*o,e[9]=t[9]*o,e[10]=t[10]*o,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromEuler(A){const e=this.elements,t=A.x,n=A.y,s=A.z,o=Math.cos(t),r=Math.sin(t),a=Math.cos(n),g=Math.sin(n),I=Math.cos(s),E=Math.sin(s);if(A.order==="XYZ"){const C=o*I,Q=o*E,h=r*I,l=r*E;e[0]=a*I,e[4]=-a*E,e[8]=g,e[1]=Q+h*g,e[5]=C-l*g,e[9]=-r*a,e[2]=l-C*g,e[6]=h+Q*g,e[10]=o*a}else if(A.order==="YXZ"){const C=a*I,Q=a*E,h=g*I,l=g*E;e[0]=C+l*r,e[4]=h*r-Q,e[8]=o*g,e[1]=o*E,e[5]=o*I,e[9]=-r,e[2]=Q*r-h,e[6]=l+C*r,e[10]=o*a}else if(A.order==="ZXY"){const C=a*I,Q=a*E,h=g*I,l=g*E;e[0]=C-l*r,e[4]=-o*E,e[8]=h+Q*r,e[1]=Q+h*r,e[5]=o*I,e[9]=l-C*r,e[2]=-o*g,e[6]=r,e[10]=o*a}else if(A.order==="ZYX"){const C=o*I,Q=o*E,h=r*I,l=r*E;e[0]=a*I,e[4]=h*g-Q,e[8]=C*g+l,e[1]=a*E,e[5]=l*g+C,e[9]=Q*g-h,e[2]=-g,e[6]=r*a,e[10]=o*a}else if(A.order==="YZX"){const C=o*a,Q=o*g,h=r*a,l=r*g;e[0]=a*I,e[4]=l-C*E,e[8]=h*E+Q,e[1]=E,e[5]=o*I,e[9]=-r*I,e[2]=-g*I,e[6]=Q*E+h,e[10]=C-l*E}else if(A.order==="XZY"){const C=o*a,Q=o*g,h=r*a,l=r*g;e[0]=a*I,e[4]=-E,e[8]=g*I,e[1]=C*E+l,e[5]=o*I,e[9]=Q*E-h,e[2]=h*E-Q,e[6]=r*I,e[10]=l*E+C}return e[3]=0,e[7]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromQuaternion(A){return this.compose(EB,A,CB)}lookAt(A,e,t){const n=this.elements;return Ye.subVectors(A,e),Ye.lengthSq()===0&&(Ye.z=1),Ye.normalize(),Zt.crossVectors(t,Ye),Zt.lengthSq()===0&&(Math.abs(t.z)===1?Ye.x+=1e-4:Ye.z+=1e-4,Ye.normalize(),Zt.crossVectors(t,Ye)),Zt.normalize(),is.crossVectors(Ye,Zt),n[0]=Zt.x,n[4]=is.x,n[8]=Ye.x,n[1]=Zt.y,n[5]=is.y,n[9]=Ye.y,n[2]=Zt.z,n[6]=is.z,n[10]=Ye.z,this}multiply(A){return this.multiplyMatrices(this,A)}premultiply(A){return this.multiplyMatrices(A,this)}multiplyMatrices(A,e){const t=A.elements,n=e.elements,s=this.elements,o=t[0],r=t[4],a=t[8],g=t[12],I=t[1],E=t[5],C=t[9],Q=t[13],h=t[2],l=t[6],B=t[10],c=t[14],R=t[3],p=t[7],d=t[11],w=t[15],S=n[0],F=n[4],N=n[8],u=n[12],f=n[1],m=n[5],T=n[9],M=n[13],_=n[2],P=n[6],b=n[10],z=n[14],O=n[3],eA=n[7],oA=n[11],gA=n[15];return s[0]=o*S+r*f+a*_+g*O,s[4]=o*F+r*m+a*P+g*eA,s[8]=o*N+r*T+a*b+g*oA,s[12]=o*u+r*M+a*z+g*gA,s[1]=I*S+E*f+C*_+Q*O,s[5]=I*F+E*m+C*P+Q*eA,s[9]=I*N+E*T+C*b+Q*oA,s[13]=I*u+E*M+C*z+Q*gA,s[2]=h*S+l*f+B*_+c*O,s[6]=h*F+l*m+B*P+c*eA,s[10]=h*N+l*T+B*b+c*oA,s[14]=h*u+l*M+B*z+c*gA,s[3]=R*S+p*f+d*_+w*O,s[7]=R*F+p*m+d*P+w*eA,s[11]=R*N+p*T+d*b+w*oA,s[15]=R*u+p*M+d*z+w*gA,this}multiplyScalar(A){const e=this.elements;return e[0]*=A,e[4]*=A,e[8]*=A,e[12]*=A,e[1]*=A,e[5]*=A,e[9]*=A,e[13]*=A,e[2]*=A,e[6]*=A,e[10]*=A,e[14]*=A,e[3]*=A,e[7]*=A,e[11]*=A,e[15]*=A,this}determinant(){const A=this.elements,e=A[0],t=A[4],n=A[8],s=A[12],o=A[1],r=A[5],a=A[9],g=A[13],I=A[2],E=A[6],C=A[10],Q=A[14],h=A[3],l=A[7],B=A[11],c=A[15];return h*(+s*a*E-n*g*E-s*r*C+t*g*C+n*r*Q-t*a*Q)+l*(+e*a*Q-e*g*C+s*o*C-n*o*Q+n*g*I-s*a*I)+B*(+e*g*E-e*r*Q-s*o*E+t*o*Q+s*r*I-t*g*I)+c*(-n*r*I-e*a*E+e*r*C+n*o*E-t*o*C+t*a*I)}transpose(){const A=this.elements;let e;return e=A[1],A[1]=A[4],A[4]=e,e=A[2],A[2]=A[8],A[8]=e,e=A[6],A[6]=A[9],A[9]=e,e=A[3],A[3]=A[12],A[12]=e,e=A[7],A[7]=A[13],A[13]=e,e=A[11],A[11]=A[14],A[14]=e,this}setPosition(A,e,t){const n=this.elements;return A.isVector3?(n[12]=A.x,n[13]=A.y,n[14]=A.z):(n[12]=A,n[13]=e,n[14]=t),this}invert(){const A=this.elements,e=A[0],t=A[1],n=A[2],s=A[3],o=A[4],r=A[5],a=A[6],g=A[7],I=A[8],E=A[9],C=A[10],Q=A[11],h=A[12],l=A[13],B=A[14],c=A[15],R=E*B*g-l*C*g+l*a*Q-r*B*Q-E*a*c+r*C*c,p=h*C*g-I*B*g-h*a*Q+o*B*Q+I*a*c-o*C*c,d=I*l*g-h*E*g+h*r*Q-o*l*Q-I*r*c+o*E*c,w=h*E*a-I*l*a-h*r*C+o*l*C+I*r*B-o*E*B,S=e*R+t*p+n*d+s*w;if(S===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const F=1/S;return A[0]=R*F,A[1]=(l*C*s-E*B*s-l*n*Q+t*B*Q+E*n*c-t*C*c)*F,A[2]=(r*B*s-l*a*s+l*n*g-t*B*g-r*n*c+t*a*c)*F,A[3]=(E*a*s-r*C*s-E*n*g+t*C*g+r*n*Q-t*a*Q)*F,A[4]=p*F,A[5]=(I*B*s-h*C*s+h*n*Q-e*B*Q-I*n*c+e*C*c)*F,A[6]=(h*a*s-o*B*s-h*n*g+e*B*g+o*n*c-e*a*c)*F,A[7]=(o*C*s-I*a*s+I*n*g-e*C*g-o*n*Q+e*a*Q)*F,A[8]=d*F,A[9]=(h*E*s-I*l*s-h*t*Q+e*l*Q+I*t*c-e*E*c)*F,A[10]=(o*l*s-h*r*s+h*t*g-e*l*g-o*t*c+e*r*c)*F,A[11]=(I*r*s-o*E*s-I*t*g+e*E*g+o*t*Q-e*r*Q)*F,A[12]=w*F,A[13]=(I*l*n-h*E*n+h*t*C-e*l*C-I*t*B+e*E*B)*F,A[14]=(h*r*n-o*l*n-h*t*a+e*l*a+o*t*B-e*r*B)*F,A[15]=(o*E*n-I*r*n+I*t*a-e*E*a-o*t*C+e*r*C)*F,this}scale(A){const e=this.elements,t=A.x,n=A.y,s=A.z;return e[0]*=t,e[4]*=n,e[8]*=s,e[1]*=t,e[5]*=n,e[9]*=s,e[2]*=t,e[6]*=n,e[10]*=s,e[3]*=t,e[7]*=n,e[11]*=s,this}getMaxScaleOnAxis(){const A=this.elements,e=A[0]*A[0]+A[1]*A[1]+A[2]*A[2],t=A[4]*A[4]+A[5]*A[5]+A[6]*A[6],n=A[8]*A[8]+A[9]*A[9]+A[10]*A[10];return Math.sqrt(Math.max(e,t,n))}makeTranslation(A,e,t){return A.isVector3?this.set(1,0,0,A.x,0,1,0,A.y,0,0,1,A.z,0,0,0,1):this.set(1,0,0,A,0,1,0,e,0,0,1,t,0,0,0,1),this}makeRotationX(A){const e=Math.cos(A),t=Math.sin(A);return this.set(1,0,0,0,0,e,-t,0,0,t,e,0,0,0,0,1),this}makeRotationY(A){const e=Math.cos(A),t=Math.sin(A);return this.set(e,0,t,0,0,1,0,0,-t,0,e,0,0,0,0,1),this}makeRotationZ(A){const e=Math.cos(A),t=Math.sin(A);return this.set(e,-t,0,0,t,e,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(A,e){const t=Math.cos(e),n=Math.sin(e),s=1-t,o=A.x,r=A.y,a=A.z,g=s*o,I=s*r;return this.set(g*o+t,g*r-n*a,g*a+n*r,0,g*r+n*a,I*r+t,I*a-n*o,0,g*a-n*r,I*a+n*o,s*a*a+t,0,0,0,0,1),this}makeScale(A,e,t){return this.set(A,0,0,0,0,e,0,0,0,0,t,0,0,0,0,1),this}makeShear(A,e,t,n,s,o){return this.set(1,t,s,0,A,1,o,0,e,n,1,0,0,0,0,1),this}compose(A,e,t){const n=this.elements,s=e._x,o=e._y,r=e._z,a=e._w,g=s+s,I=o+o,E=r+r,C=s*g,Q=s*I,h=s*E,l=o*I,B=o*E,c=r*E,R=a*g,p=a*I,d=a*E,w=t.x,S=t.y,F=t.z;return n[0]=(1-(l+c))*w,n[1]=(Q+d)*w,n[2]=(h-p)*w,n[3]=0,n[4]=(Q-d)*S,n[5]=(1-(C+c))*S,n[6]=(B+R)*S,n[7]=0,n[8]=(h+p)*F,n[9]=(B-R)*F,n[10]=(1-(C+l))*F,n[11]=0,n[12]=A.x,n[13]=A.y,n[14]=A.z,n[15]=1,this}decompose(A,e,t){const n=this.elements;let s=vi.set(n[0],n[1],n[2]).length();const o=vi.set(n[4],n[5],n[6]).length(),r=vi.set(n[8],n[9],n[10]).length();this.determinant()<0&&(s=-s),A.x=n[12],A.y=n[13],A.z=n[14],Et.copy(this);const g=1/s,I=1/o,E=1/r;return Et.elements[0]*=g,Et.elements[1]*=g,Et.elements[2]*=g,Et.elements[4]*=I,Et.elements[5]*=I,Et.elements[6]*=I,Et.elements[8]*=E,Et.elements[9]*=E,Et.elements[10]*=E,e.setFromRotationMatrix(Et),t.x=s,t.y=o,t.z=r,this}makePerspective(A,e,t,n,s,o,r=Jt){const a=this.elements,g=2*s/(e-A),I=2*s/(t-n),E=(e+A)/(e-A),C=(t+n)/(t-n);let Q,h;if(r===Jt)Q=-(o+s)/(o-s),h=-2*o*s/(o-s);else if(r===Ys)Q=-o/(o-s),h=-o*s/(o-s);else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: "+r);return a[0]=g,a[4]=0,a[8]=E,a[12]=0,a[1]=0,a[5]=I,a[9]=C,a[13]=0,a[2]=0,a[6]=0,a[10]=Q,a[14]=h,a[3]=0,a[7]=0,a[11]=-1,a[15]=0,this}makeOrthographic(A,e,t,n,s,o,r=Jt){const a=this.elements,g=1/(e-A),I=1/(t-n),E=1/(o-s),C=(e+A)*g,Q=(t+n)*I;let h,l;if(r===Jt)h=(o+s)*E,l=-2*E;else if(r===Ys)h=s*E,l=-1*E;else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: "+r);return a[0]=2*g,a[4]=0,a[8]=0,a[12]=-C,a[1]=0,a[5]=2*I,a[9]=0,a[13]=-Q,a[2]=0,a[6]=0,a[10]=l,a[14]=-h,a[3]=0,a[7]=0,a[11]=0,a[15]=1,this}equals(A){const e=this.elements,t=A.elements;for(let n=0;n<16;n++)if(e[n]!==t[n])return!1;return!0}fromArray(A,e=0){for(let t=0;t<16;t++)this.elements[t]=A[t+e];return this}toArray(A=[],e=0){const t=this.elements;return A[e]=t[0],A[e+1]=t[1],A[e+2]=t[2],A[e+3]=t[3],A[e+4]=t[4],A[e+5]=t[5],A[e+6]=t[6],A[e+7]=t[7],A[e+8]=t[8],A[e+9]=t[9],A[e+10]=t[10],A[e+11]=t[11],A[e+12]=t[12],A[e+13]=t[13],A[e+14]=t[14],A[e+15]=t[15],A}}const vi=new L,Et=new UA,EB=new L(0,0,0),CB=new L(1,1,1),Zt=new L,is=new L,Ye=new L,tg=new UA,ig=new Ii;class pt{constructor(A=0,e=0,t=0,n=pt.DEFAULT_ORDER){this.isEuler=!0,this._x=A,this._y=e,this._z=t,this._order=n}get x(){return this._x}set x(A){this._x=A,this._onChangeCallback()}get y(){return this._y}set y(A){this._y=A,this._onChangeCallback()}get z(){return this._z}set z(A){this._z=A,this._onChangeCallback()}get order(){return this._order}set order(A){this._order=A,this._onChangeCallback()}set(A,e,t,n=this._order){return this._x=A,this._y=e,this._z=t,this._order=n,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(A){return this._x=A._x,this._y=A._y,this._z=A._z,this._order=A._order,this._onChangeCallback(),this}setFromRotationMatrix(A,e=this._order,t=!0){const n=A.elements,s=n[0],o=n[4],r=n[8],a=n[1],g=n[5],I=n[9],E=n[2],C=n[6],Q=n[10];switch(e){case"XYZ":this._y=Math.asin(zA(r,-1,1)),Math.abs(r)<.9999999?(this._x=Math.atan2(-I,Q),this._z=Math.atan2(-o,s)):(this._x=Math.atan2(C,g),this._z=0);break;case"YXZ":this._x=Math.asin(-zA(I,-1,1)),Math.abs(I)<.9999999?(this._y=Math.atan2(r,Q),this._z=Math.atan2(a,g)):(this._y=Math.atan2(-E,s),this._z=0);break;case"ZXY":this._x=Math.asin(zA(C,-1,1)),Math.abs(C)<.9999999?(this._y=Math.atan2(-E,Q),this._z=Math.atan2(-o,g)):(this._y=0,this._z=Math.atan2(a,s));break;case"ZYX":this._y=Math.asin(-zA(E,-1,1)),Math.abs(E)<.9999999?(this._x=Math.atan2(C,Q),this._z=Math.atan2(a,s)):(this._x=0,this._z=Math.atan2(-o,g));break;case"YZX":this._z=Math.asin(zA(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(-I,g),this._y=Math.atan2(-E,s)):(this._x=0,this._y=Math.atan2(r,Q));break;case"XZY":this._z=Math.asin(-zA(o,-1,1)),Math.abs(o)<.9999999?(this._x=Math.atan2(C,g),this._y=Math.atan2(r,s)):(this._x=Math.atan2(-I,Q),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+e)}return this._order=e,t===!0&&this._onChangeCallback(),this}setFromQuaternion(A,e,t){return tg.makeRotationFromQuaternion(A),this.setFromRotationMatrix(tg,e,t)}setFromVector3(A,e=this._order){return this.set(A.x,A.y,A.z,e)}reorder(A){return ig.setFromEuler(this),this.setFromQuaternion(ig,A)}equals(A){return A._x===this._x&&A._y===this._y&&A._z===this._z&&A._order===this._order}fromArray(A){return this._x=A[0],this._y=A[1],this._z=A[2],A[3]!==void 0&&(this._order=A[3]),this._onChangeCallback(),this}toArray(A=[],e=0){return A[e]=this._x,A[e+1]=this._y,A[e+2]=this._z,A[e+3]=this._order,A}_onChange(A){return this._onChangeCallback=A,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}}pt.DEFAULT_ORDER="XYZ";class Ba{constructor(){this.mask=1}set(A){this.mask=(1<<A|0)>>>0}enable(A){this.mask|=1<<A|0}enableAll(){this.mask=-1}toggle(A){this.mask^=1<<A|0}disable(A){this.mask&=~(1<<A|0)}disableAll(){this.mask=0}test(A){return(this.mask&A.mask)!==0}isEnabled(A){return(this.mask&(1<<A|0))!==0}}let QB=0;const ng=new L,Ti=new Ii,_t=new UA,ns=new L,Dn=new L,BB=new L,cB=new Ii,sg=new L(1,0,0),og=new L(0,1,0),rg=new L(0,0,1),ag={type:"added"},hB={type:"removed"},bi={type:"childadded",child:null},fo={type:"childremoved",child:null};class Be extends Si{constructor(){super(),this.isObject3D=!0,Object.defineProperty(this,"id",{value:QB++}),this.uuid=dt(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=Be.DEFAULT_UP.clone();const A=new L,e=new pt,t=new Ii,n=new L(1,1,1);function s(){t.setFromEuler(e,!1)}function o(){e.setFromQuaternion(t,void 0,!1)}e._onChange(s),t._onChange(o),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:A},rotation:{configurable:!0,enumerable:!0,value:e},quaternion:{configurable:!0,enumerable:!0,value:t},scale:{configurable:!0,enumerable:!0,value:n},modelViewMatrix:{value:new UA},normalMatrix:{value:new PA}}),this.matrix=new UA,this.matrixWorld=new UA,this.matrixAutoUpdate=Be.DEFAULT_MATRIX_AUTO_UPDATE,this.matrixWorldAutoUpdate=Be.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,this.matrixWorldNeedsUpdate=!1,this.layers=new Ba,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeShadow(){}onAfterShadow(){}onBeforeRender(){}onAfterRender(){}applyMatrix4(A){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(A),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(A){return this.quaternion.premultiply(A),this}setRotationFromAxisAngle(A,e){this.quaternion.setFromAxisAngle(A,e)}setRotationFromEuler(A){this.quaternion.setFromEuler(A,!0)}setRotationFromMatrix(A){this.quaternion.setFromRotationMatrix(A)}setRotationFromQuaternion(A){this.quaternion.copy(A)}rotateOnAxis(A,e){return Ti.setFromAxisAngle(A,e),this.quaternion.multiply(Ti),this}rotateOnWorldAxis(A,e){return Ti.setFromAxisAngle(A,e),this.quaternion.premultiply(Ti),this}rotateX(A){return this.rotateOnAxis(sg,A)}rotateY(A){return this.rotateOnAxis(og,A)}rotateZ(A){return this.rotateOnAxis(rg,A)}translateOnAxis(A,e){return ng.copy(A).applyQuaternion(this.quaternion),this.position.add(ng.multiplyScalar(e)),this}translateX(A){return this.translateOnAxis(sg,A)}translateY(A){return this.translateOnAxis(og,A)}translateZ(A){return this.translateOnAxis(rg,A)}localToWorld(A){return this.updateWorldMatrix(!0,!1),A.applyMatrix4(this.matrixWorld)}worldToLocal(A){return this.updateWorldMatrix(!0,!1),A.applyMatrix4(_t.copy(this.matrixWorld).invert())}lookAt(A,e,t){A.isVector3?ns.copy(A):ns.set(A,e,t);const n=this.parent;this.updateWorldMatrix(!0,!1),Dn.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?_t.lookAt(Dn,ns,this.up):_t.lookAt(ns,Dn,this.up),this.quaternion.setFromRotationMatrix(_t),n&&(_t.extractRotation(n.matrixWorld),Ti.setFromRotationMatrix(_t),this.quaternion.premultiply(Ti.invert()))}add(A){if(arguments.length>1){for(let e=0;e<arguments.length;e++)this.add(arguments[e]);return this}return A===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",A),this):(A&&A.isObject3D?(A.removeFromParent(),A.parent=this,this.children.push(A),A.dispatchEvent(ag),bi.child=A,this.dispatchEvent(bi),bi.child=null):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",A),this)}remove(A){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.remove(arguments[t]);return this}const e=this.children.indexOf(A);return e!==-1&&(A.parent=null,this.children.splice(e,1),A.dispatchEvent(hB),fo.child=A,this.dispatchEvent(fo),fo.child=null),this}removeFromParent(){const A=this.parent;return A!==null&&A.remove(this),this}clear(){return this.remove(...this.children)}attach(A){return this.updateWorldMatrix(!0,!1),_t.copy(this.matrixWorld).invert(),A.parent!==null&&(A.parent.updateWorldMatrix(!0,!1),_t.multiply(A.parent.matrixWorld)),A.applyMatrix4(_t),A.removeFromParent(),A.parent=this,this.children.push(A),A.updateWorldMatrix(!1,!0),A.dispatchEvent(ag),bi.child=A,this.dispatchEvent(bi),bi.child=null,this}getObjectById(A){return this.getObjectByProperty("id",A)}getObjectByName(A){return this.getObjectByProperty("name",A)}getObjectByProperty(A,e){if(this[A]===e)return this;for(let t=0,n=this.children.length;t<n;t++){const o=this.children[t].getObjectByProperty(A,e);if(o!==void 0)return o}}getObjectsByProperty(A,e,t=[]){this[A]===e&&t.push(this);const n=this.children;for(let s=0,o=n.length;s<o;s++)n[s].getObjectsByProperty(A,e,t);return t}getWorldPosition(A){return this.updateWorldMatrix(!0,!1),A.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(A){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Dn,A,BB),A}getWorldScale(A){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Dn,cB,A),A}getWorldDirection(A){this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return A.set(e[8],e[9],e[10]).normalize()}raycast(){}traverse(A){A(this);const e=this.children;for(let t=0,n=e.length;t<n;t++)e[t].traverse(A)}traverseVisible(A){if(this.visible===!1)return;A(this);const e=this.children;for(let t=0,n=e.length;t<n;t++)e[t].traverseVisible(A)}traverseAncestors(A){const e=this.parent;e!==null&&(A(e),e.traverseAncestors(A))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(A){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||A)&&(this.matrixWorldAutoUpdate===!0&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix)),this.matrixWorldNeedsUpdate=!1,A=!0);const e=this.children;for(let t=0,n=e.length;t<n;t++)e[t].updateMatrixWorld(A)}updateWorldMatrix(A,e){const t=this.parent;if(A===!0&&t!==null&&t.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.matrixWorldAutoUpdate===!0&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix)),e===!0){const n=this.children;for(let s=0,o=n.length;s<o;s++)n[s].updateWorldMatrix(!1,!0)}}toJSON(A){const e=A===void 0||typeof A=="string",t={};e&&(A={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},t.metadata={version:4.6,type:"Object",generator:"Object3D.toJSON"});const n={};n.uuid=this.uuid,n.type=this.type,this.name!==""&&(n.name=this.name),this.castShadow===!0&&(n.castShadow=!0),this.receiveShadow===!0&&(n.receiveShadow=!0),this.visible===!1&&(n.visible=!1),this.frustumCulled===!1&&(n.frustumCulled=!1),this.renderOrder!==0&&(n.renderOrder=this.renderOrder),Object.keys(this.userData).length>0&&(n.userData=this.userData),n.layers=this.layers.mask,n.matrix=this.matrix.toArray(),n.up=this.up.toArray(),this.matrixAutoUpdate===!1&&(n.matrixAutoUpdate=!1),this.isInstancedMesh&&(n.type="InstancedMesh",n.count=this.count,n.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(n.instanceColor=this.instanceColor.toJSON())),this.isBatchedMesh&&(n.type="BatchedMesh",n.perObjectFrustumCulled=this.perObjectFrustumCulled,n.sortObjects=this.sortObjects,n.drawRanges=this._drawRanges,n.reservedRanges=this._reservedRanges,n.visibility=this._visibility,n.active=this._active,n.bounds=this._bounds.map(r=>({boxInitialized:r.boxInitialized,boxMin:r.box.min.toArray(),boxMax:r.box.max.toArray(),sphereInitialized:r.sphereInitialized,sphereRadius:r.sphere.radius,sphereCenter:r.sphere.center.toArray()})),n.maxInstanceCount=this._maxInstanceCount,n.maxVertexCount=this._maxVertexCount,n.maxIndexCount=this._maxIndexCount,n.geometryInitialized=this._geometryInitialized,n.geometryCount=this._geometryCount,n.matricesTexture=this._matricesTexture.toJSON(A),this._colorsTexture!==null&&(n.colorsTexture=this._colorsTexture.toJSON(A)),this.boundingSphere!==null&&(n.boundingSphere={center:n.boundingSphere.center.toArray(),radius:n.boundingSphere.radius}),this.boundingBox!==null&&(n.boundingBox={min:n.boundingBox.min.toArray(),max:n.boundingBox.max.toArray()}));function s(r,a){return r[a.uuid]===void 0&&(r[a.uuid]=a.toJSON(A)),a.uuid}if(this.isScene)this.background&&(this.background.isColor?n.background=this.background.toJSON():this.background.isTexture&&(n.background=this.background.toJSON(A).uuid)),this.environment&&this.environment.isTexture&&this.environment.isRenderTargetTexture!==!0&&(n.environment=this.environment.toJSON(A).uuid);else if(this.isMesh||this.isLine||this.isPoints){n.geometry=s(A.geometries,this.geometry);const r=this.geometry.parameters;if(r!==void 0&&r.shapes!==void 0){const a=r.shapes;if(Array.isArray(a))for(let g=0,I=a.length;g<I;g++){const E=a[g];s(A.shapes,E)}else s(A.shapes,a)}}if(this.isSkinnedMesh&&(n.bindMode=this.bindMode,n.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(s(A.skeletons,this.skeleton),n.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const r=[];for(let a=0,g=this.material.length;a<g;a++)r.push(s(A.materials,this.material[a]));n.material=r}else n.material=s(A.materials,this.material);if(this.children.length>0){n.children=[];for(let r=0;r<this.children.length;r++)n.children.push(this.children[r].toJSON(A).object)}if(this.animations.length>0){n.animations=[];for(let r=0;r<this.animations.length;r++){const a=this.animations[r];n.animations.push(s(A.animations,a))}}if(e){const r=o(A.geometries),a=o(A.materials),g=o(A.textures),I=o(A.images),E=o(A.shapes),C=o(A.skeletons),Q=o(A.animations),h=o(A.nodes);r.length>0&&(t.geometries=r),a.length>0&&(t.materials=a),g.length>0&&(t.textures=g),I.length>0&&(t.images=I),E.length>0&&(t.shapes=E),C.length>0&&(t.skeletons=C),Q.length>0&&(t.animations=Q),h.length>0&&(t.nodes=h)}return t.object=n,t;function o(r){const a=[];for(const g in r){const I=r[g];delete I.metadata,a.push(I)}return a}}clone(A){return new this.constructor().copy(this,A)}copy(A,e=!0){if(this.name=A.name,this.up.copy(A.up),this.position.copy(A.position),this.rotation.order=A.rotation.order,this.quaternion.copy(A.quaternion),this.scale.copy(A.scale),this.matrix.copy(A.matrix),this.matrixWorld.copy(A.matrixWorld),this.matrixAutoUpdate=A.matrixAutoUpdate,this.matrixWorldAutoUpdate=A.matrixWorldAutoUpdate,this.matrixWorldNeedsUpdate=A.matrixWorldNeedsUpdate,this.layers.mask=A.layers.mask,this.visible=A.visible,this.castShadow=A.castShadow,this.receiveShadow=A.receiveShadow,this.frustumCulled=A.frustumCulled,this.renderOrder=A.renderOrder,this.animations=A.animations.slice(),this.userData=JSON.parse(JSON.stringify(A.userData)),e===!0)for(let t=0;t<A.children.length;t++){const n=A.children[t];this.add(n.clone())}return this}}Be.DEFAULT_UP=new L(0,1,0);Be.DEFAULT_MATRIX_AUTO_UPDATE=!0;Be.DEFAULT_MATRIX_WORLD_AUTO_UPDATE=!0;const Ct=new L,Ut=new L,po=new L,Gt=new L,ki=new L,Hi=new L,gg=new L,Do=new L,mo=new L,yo=new L,Ro=new YA,wo=new YA,So=new YA;class ht{constructor(A=new L,e=new L,t=new L){this.a=A,this.b=e,this.c=t}static getNormal(A,e,t,n){n.subVectors(t,e),Ct.subVectors(A,e),n.cross(Ct);const s=n.lengthSq();return s>0?n.multiplyScalar(1/Math.sqrt(s)):n.set(0,0,0)}static getBarycoord(A,e,t,n,s){Ct.subVectors(n,e),Ut.subVectors(t,e),po.subVectors(A,e);const o=Ct.dot(Ct),r=Ct.dot(Ut),a=Ct.dot(po),g=Ut.dot(Ut),I=Ut.dot(po),E=o*g-r*r;if(E===0)return s.set(0,0,0),null;const C=1/E,Q=(g*a-r*I)*C,h=(o*I-r*a)*C;return s.set(1-Q-h,h,Q)}static containsPoint(A,e,t,n){return this.getBarycoord(A,e,t,n,Gt)===null?!1:Gt.x>=0&&Gt.y>=0&&Gt.x+Gt.y<=1}static getInterpolation(A,e,t,n,s,o,r,a){return this.getBarycoord(A,e,t,n,Gt)===null?(a.x=0,a.y=0,"z"in a&&(a.z=0),"w"in a&&(a.w=0),null):(a.setScalar(0),a.addScaledVector(s,Gt.x),a.addScaledVector(o,Gt.y),a.addScaledVector(r,Gt.z),a)}static getInterpolatedAttribute(A,e,t,n,s,o){return Ro.setScalar(0),wo.setScalar(0),So.setScalar(0),Ro.fromBufferAttribute(A,e),wo.fromBufferAttribute(A,t),So.fromBufferAttribute(A,n),o.setScalar(0),o.addScaledVector(Ro,s.x),o.addScaledVector(wo,s.y),o.addScaledVector(So,s.z),o}static isFrontFacing(A,e,t,n){return Ct.subVectors(t,e),Ut.subVectors(A,e),Ct.cross(Ut).dot(n)<0}set(A,e,t){return this.a.copy(A),this.b.copy(e),this.c.copy(t),this}setFromPointsAndIndices(A,e,t,n){return this.a.copy(A[e]),this.b.copy(A[t]),this.c.copy(A[n]),this}setFromAttributeAndIndices(A,e,t,n){return this.a.fromBufferAttribute(A,e),this.b.fromBufferAttribute(A,t),this.c.fromBufferAttribute(A,n),this}clone(){return new this.constructor().copy(this)}copy(A){return this.a.copy(A.a),this.b.copy(A.b),this.c.copy(A.c),this}getArea(){return Ct.subVectors(this.c,this.b),Ut.subVectors(this.a,this.b),Ct.cross(Ut).length()*.5}getMidpoint(A){return A.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(A){return ht.getNormal(this.a,this.b,this.c,A)}getPlane(A){return A.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(A,e){return ht.getBarycoord(A,this.a,this.b,this.c,e)}getInterpolation(A,e,t,n,s){return ht.getInterpolation(A,this.a,this.b,this.c,e,t,n,s)}containsPoint(A){return ht.containsPoint(A,this.a,this.b,this.c)}isFrontFacing(A){return ht.isFrontFacing(this.a,this.b,this.c,A)}intersectsBox(A){return A.intersectsTriangle(this)}closestPointToPoint(A,e){const t=this.a,n=this.b,s=this.c;let o,r;ki.subVectors(n,t),Hi.subVectors(s,t),Do.subVectors(A,t);const a=ki.dot(Do),g=Hi.dot(Do);if(a<=0&&g<=0)return e.copy(t);mo.subVectors(A,n);const I=ki.dot(mo),E=Hi.dot(mo);if(I>=0&&E<=I)return e.copy(n);const C=a*E-I*g;if(C<=0&&a>=0&&I<=0)return o=a/(a-I),e.copy(t).addScaledVector(ki,o);yo.subVectors(A,s);const Q=ki.dot(yo),h=Hi.dot(yo);if(h>=0&&Q<=h)return e.copy(s);const l=Q*g-a*h;if(l<=0&&g>=0&&h<=0)return r=g/(g-h),e.copy(t).addScaledVector(Hi,r);const B=I*h-Q*E;if(B<=0&&E-I>=0&&Q-h>=0)return gg.subVectors(s,n),r=(E-I)/(E-I+(Q-h)),e.copy(n).addScaledVector(gg,r);const c=1/(B+l+C);return o=l*c,r=C*c,e.copy(t).addScaledVector(ki,o).addScaledVector(Hi,r)}equals(A){return A.a.equals(this.a)&&A.b.equals(this.b)&&A.c.equals(this.c)}}const DE={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},jt={h:0,s:0,l:0},ss={h:0,s:0,l:0};function Mo(i,A,e){return e<0&&(e+=1),e>1&&(e-=1),e<1/6?i+(A-i)*6*e:e<1/2?A:e<2/3?i+(A-i)*6*(2/3-e):i}class GA{constructor(A,e,t){return this.isColor=!0,this.r=1,this.g=1,this.b=1,this.set(A,e,t)}set(A,e,t){if(e===void 0&&t===void 0){const n=A;n&&n.isColor?this.copy(n):typeof n=="number"?this.setHex(n):typeof n=="string"&&this.setStyle(n)}else this.setRGB(A,e,t);return this}setScalar(A){return this.r=A,this.g=A,this.b=A,this}setHex(A,e=De){return A=Math.floor(A),this.r=(A>>16&255)/255,this.g=(A>>8&255)/255,this.b=(A&255)/255,$A.toWorkingColorSpace(this,e),this}setRGB(A,e,t,n=$A.workingColorSpace){return this.r=A,this.g=e,this.b=t,$A.toWorkingColorSpace(this,n),this}setHSL(A,e,t,n=$A.workingColorSpace){if(A=Ca(A,1),e=zA(e,0,1),t=zA(t,0,1),e===0)this.r=this.g=this.b=t;else{const s=t<=.5?t*(1+e):t+e-t*e,o=2*t-s;this.r=Mo(o,s,A+1/3),this.g=Mo(o,s,A),this.b=Mo(o,s,A-1/3)}return $A.toWorkingColorSpace(this,n),this}setStyle(A,e=De){function t(s){s!==void 0&&parseFloat(s)<1&&console.warn("THREE.Color: Alpha component of "+A+" will be ignored.")}let n;if(n=/^(\w+)\(([^\)]*)\)/.exec(A)){let s;const o=n[1],r=n[2];switch(o){case"rgb":case"rgba":if(s=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r))return t(s[4]),this.setRGB(Math.min(255,parseInt(s[1],10))/255,Math.min(255,parseInt(s[2],10))/255,Math.min(255,parseInt(s[3],10))/255,e);if(s=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r))return t(s[4]),this.setRGB(Math.min(100,parseInt(s[1],10))/100,Math.min(100,parseInt(s[2],10))/100,Math.min(100,parseInt(s[3],10))/100,e);break;case"hsl":case"hsla":if(s=/^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r))return t(s[4]),this.setHSL(parseFloat(s[1])/360,parseFloat(s[2])/100,parseFloat(s[3])/100,e);break;default:console.warn("THREE.Color: Unknown color model "+A)}}else if(n=/^\#([A-Fa-f\d]+)$/.exec(A)){const s=n[1],o=s.length;if(o===3)return this.setRGB(parseInt(s.charAt(0),16)/15,parseInt(s.charAt(1),16)/15,parseInt(s.charAt(2),16)/15,e);if(o===6)return this.setHex(parseInt(s,16),e);console.warn("THREE.Color: Invalid hex color "+A)}else if(A&&A.length>0)return this.setColorName(A,e);return this}setColorName(A,e=De){const t=DE[A.toLowerCase()];return t!==void 0?this.setHex(t,e):console.warn("THREE.Color: Unknown color "+A),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(A){return this.r=A.r,this.g=A.g,this.b=A.b,this}copySRGBToLinear(A){return this.r=Yt(A.r),this.g=Yt(A.g),this.b=Yt(A.b),this}copyLinearToSRGB(A){return this.r=An(A.r),this.g=An(A.g),this.b=An(A.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(A=De){return $A.fromWorkingColorSpace(xe.copy(this),A),Math.round(zA(xe.r*255,0,255))*65536+Math.round(zA(xe.g*255,0,255))*256+Math.round(zA(xe.b*255,0,255))}getHexString(A=De){return("000000"+this.getHex(A).toString(16)).slice(-6)}getHSL(A,e=$A.workingColorSpace){$A.fromWorkingColorSpace(xe.copy(this),e);const t=xe.r,n=xe.g,s=xe.b,o=Math.max(t,n,s),r=Math.min(t,n,s);let a,g;const I=(r+o)/2;if(r===o)a=0,g=0;else{const E=o-r;switch(g=I<=.5?E/(o+r):E/(2-o-r),o){case t:a=(n-s)/E+(n<s?6:0);break;case n:a=(s-t)/E+2;break;case s:a=(t-n)/E+4;break}a/=6}return A.h=a,A.s=g,A.l=I,A}getRGB(A,e=$A.workingColorSpace){return $A.fromWorkingColorSpace(xe.copy(this),e),A.r=xe.r,A.g=xe.g,A.b=xe.b,A}getStyle(A=De){$A.fromWorkingColorSpace(xe.copy(this),A);const e=xe.r,t=xe.g,n=xe.b;return A!==De?`color(${A} ${e.toFixed(3)} ${t.toFixed(3)} ${n.toFixed(3)})`:`rgb(${Math.round(e*255)},${Math.round(t*255)},${Math.round(n*255)})`}offsetHSL(A,e,t){return this.getHSL(jt),this.setHSL(jt.h+A,jt.s+e,jt.l+t)}add(A){return this.r+=A.r,this.g+=A.g,this.b+=A.b,this}addColors(A,e){return this.r=A.r+e.r,this.g=A.g+e.g,this.b=A.b+e.b,this}addScalar(A){return this.r+=A,this.g+=A,this.b+=A,this}sub(A){return this.r=Math.max(0,this.r-A.r),this.g=Math.max(0,this.g-A.g),this.b=Math.max(0,this.b-A.b),this}multiply(A){return this.r*=A.r,this.g*=A.g,this.b*=A.b,this}multiplyScalar(A){return this.r*=A,this.g*=A,this.b*=A,this}lerp(A,e){return this.r+=(A.r-this.r)*e,this.g+=(A.g-this.g)*e,this.b+=(A.b-this.b)*e,this}lerpColors(A,e,t){return this.r=A.r+(e.r-A.r)*t,this.g=A.g+(e.g-A.g)*t,this.b=A.b+(e.b-A.b)*t,this}lerpHSL(A,e){this.getHSL(jt),A.getHSL(ss);const t=vn(jt.h,ss.h,e),n=vn(jt.s,ss.s,e),s=vn(jt.l,ss.l,e);return this.setHSL(t,n,s),this}setFromVector3(A){return this.r=A.x,this.g=A.y,this.b=A.z,this}applyMatrix3(A){const e=this.r,t=this.g,n=this.b,s=A.elements;return this.r=s[0]*e+s[3]*t+s[6]*n,this.g=s[1]*e+s[4]*t+s[7]*n,this.b=s[2]*e+s[5]*t+s[8]*n,this}equals(A){return A.r===this.r&&A.g===this.g&&A.b===this.b}fromArray(A,e=0){return this.r=A[e],this.g=A[e+1],this.b=A[e+2],this}toArray(A=[],e=0){return A[e]=this.r,A[e+1]=this.g,A[e+2]=this.b,A}fromBufferAttribute(A,e){return this.r=A.getX(e),this.g=A.getY(e),this.b=A.getZ(e),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}}const xe=new GA;GA.NAMES=DE;let lB=0;class ut extends Si{constructor(){super(),this.isMaterial=!0,Object.defineProperty(this,"id",{value:lB++}),this.uuid=dt(),this.name="",this.type="Material",this.blending=Ri,this.side=ft,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.alphaHash=!1,this.blendSrc=sr,this.blendDst=or,this.blendEquation=Di,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.blendColor=new GA(0,0,0),this.blendAlpha=0,this.depthFunc=nn,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=za,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=Fi,this.stencilZFail=Fi,this.stencilZPass=Fi,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.forceSinglePass=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(A){this._alphaTest>0!=A>0&&this.version++,this._alphaTest=A}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(A){if(A!==void 0)for(const e in A){const t=A[e];if(t===void 0){console.warn(`THREE.Material: parameter '${e}' has value of undefined.`);continue}const n=this[e];if(n===void 0){console.warn(`THREE.Material: '${e}' is not a property of THREE.${this.type}.`);continue}n&&n.isColor?n.set(t):n&&n.isVector3&&t&&t.isVector3?n.copy(t):this[e]=t}}toJSON(A){const e=A===void 0||typeof A=="string";e&&(A={textures:{},images:{}});const t={metadata:{version:4.6,type:"Material",generator:"Material.toJSON"}};t.uuid=this.uuid,t.type=this.type,this.name!==""&&(t.name=this.name),this.color&&this.color.isColor&&(t.color=this.color.getHex()),this.roughness!==void 0&&(t.roughness=this.roughness),this.metalness!==void 0&&(t.metalness=this.metalness),this.sheen!==void 0&&(t.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(t.sheenColor=this.sheenColor.getHex()),this.sheenRoughness!==void 0&&(t.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(t.emissive=this.emissive.getHex()),this.emissiveIntensity!==void 0&&this.emissiveIntensity!==1&&(t.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(t.specular=this.specular.getHex()),this.specularIntensity!==void 0&&(t.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(t.specularColor=this.specularColor.getHex()),this.shininess!==void 0&&(t.shininess=this.shininess),this.clearcoat!==void 0&&(t.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(t.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(t.clearcoatMap=this.clearcoatMap.toJSON(A).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(t.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(A).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(t.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(A).uuid,t.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.dispersion!==void 0&&(t.dispersion=this.dispersion),this.iridescence!==void 0&&(t.iridescence=this.iridescence),this.iridescenceIOR!==void 0&&(t.iridescenceIOR=this.iridescenceIOR),this.iridescenceThicknessRange!==void 0&&(t.iridescenceThicknessRange=this.iridescenceThicknessRange),this.iridescenceMap&&this.iridescenceMap.isTexture&&(t.iridescenceMap=this.iridescenceMap.toJSON(A).uuid),this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture&&(t.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(A).uuid),this.anisotropy!==void 0&&(t.anisotropy=this.anisotropy),this.anisotropyRotation!==void 0&&(t.anisotropyRotation=this.anisotropyRotation),this.anisotropyMap&&this.anisotropyMap.isTexture&&(t.anisotropyMap=this.anisotropyMap.toJSON(A).uuid),this.map&&this.map.isTexture&&(t.map=this.map.toJSON(A).uuid),this.matcap&&this.matcap.isTexture&&(t.matcap=this.matcap.toJSON(A).uuid),this.alphaMap&&this.alphaMap.isTexture&&(t.alphaMap=this.alphaMap.toJSON(A).uuid),this.lightMap&&this.lightMap.isTexture&&(t.lightMap=this.lightMap.toJSON(A).uuid,t.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(t.aoMap=this.aoMap.toJSON(A).uuid,t.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(t.bumpMap=this.bumpMap.toJSON(A).uuid,t.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(t.normalMap=this.normalMap.toJSON(A).uuid,t.normalMapType=this.normalMapType,t.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(t.displacementMap=this.displacementMap.toJSON(A).uuid,t.displacementScale=this.displacementScale,t.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(t.roughnessMap=this.roughnessMap.toJSON(A).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(t.metalnessMap=this.metalnessMap.toJSON(A).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(t.emissiveMap=this.emissiveMap.toJSON(A).uuid),this.specularMap&&this.specularMap.isTexture&&(t.specularMap=this.specularMap.toJSON(A).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(t.specularIntensityMap=this.specularIntensityMap.toJSON(A).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(t.specularColorMap=this.specularColorMap.toJSON(A).uuid),this.envMap&&this.envMap.isTexture&&(t.envMap=this.envMap.toJSON(A).uuid,this.combine!==void 0&&(t.combine=this.combine)),this.envMapRotation!==void 0&&(t.envMapRotation=this.envMapRotation.toArray()),this.envMapIntensity!==void 0&&(t.envMapIntensity=this.envMapIntensity),this.reflectivity!==void 0&&(t.reflectivity=this.reflectivity),this.refractionRatio!==void 0&&(t.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(t.gradientMap=this.gradientMap.toJSON(A).uuid),this.transmission!==void 0&&(t.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(t.transmissionMap=this.transmissionMap.toJSON(A).uuid),this.thickness!==void 0&&(t.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(t.thicknessMap=this.thicknessMap.toJSON(A).uuid),this.attenuationDistance!==void 0&&this.attenuationDistance!==1/0&&(t.attenuationDistance=this.attenuationDistance),this.attenuationColor!==void 0&&(t.attenuationColor=this.attenuationColor.getHex()),this.size!==void 0&&(t.size=this.size),this.shadowSide!==null&&(t.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(t.sizeAttenuation=this.sizeAttenuation),this.blending!==Ri&&(t.blending=this.blending),this.side!==ft&&(t.side=this.side),this.vertexColors===!0&&(t.vertexColors=!0),this.opacity<1&&(t.opacity=this.opacity),this.transparent===!0&&(t.transparent=!0),this.blendSrc!==sr&&(t.blendSrc=this.blendSrc),this.blendDst!==or&&(t.blendDst=this.blendDst),this.blendEquation!==Di&&(t.blendEquation=this.blendEquation),this.blendSrcAlpha!==null&&(t.blendSrcAlpha=this.blendSrcAlpha),this.blendDstAlpha!==null&&(t.blendDstAlpha=this.blendDstAlpha),this.blendEquationAlpha!==null&&(t.blendEquationAlpha=this.blendEquationAlpha),this.blendColor&&this.blendColor.isColor&&(t.blendColor=this.blendColor.getHex()),this.blendAlpha!==0&&(t.blendAlpha=this.blendAlpha),this.depthFunc!==nn&&(t.depthFunc=this.depthFunc),this.depthTest===!1&&(t.depthTest=this.depthTest),this.depthWrite===!1&&(t.depthWrite=this.depthWrite),this.colorWrite===!1&&(t.colorWrite=this.colorWrite),this.stencilWriteMask!==255&&(t.stencilWriteMask=this.stencilWriteMask),this.stencilFunc!==za&&(t.stencilFunc=this.stencilFunc),this.stencilRef!==0&&(t.stencilRef=this.stencilRef),this.stencilFuncMask!==255&&(t.stencilFuncMask=this.stencilFuncMask),this.stencilFail!==Fi&&(t.stencilFail=this.stencilFail),this.stencilZFail!==Fi&&(t.stencilZFail=this.stencilZFail),this.stencilZPass!==Fi&&(t.stencilZPass=this.stencilZPass),this.stencilWrite===!0&&(t.stencilWrite=this.stencilWrite),this.rotation!==void 0&&this.rotation!==0&&(t.rotation=this.rotation),this.polygonOffset===!0&&(t.polygonOffset=!0),this.polygonOffsetFactor!==0&&(t.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(t.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth!==void 0&&this.linewidth!==1&&(t.linewidth=this.linewidth),this.dashSize!==void 0&&(t.dashSize=this.dashSize),this.gapSize!==void 0&&(t.gapSize=this.gapSize),this.scale!==void 0&&(t.scale=this.scale),this.dithering===!0&&(t.dithering=!0),this.alphaTest>0&&(t.alphaTest=this.alphaTest),this.alphaHash===!0&&(t.alphaHash=!0),this.alphaToCoverage===!0&&(t.alphaToCoverage=!0),this.premultipliedAlpha===!0&&(t.premultipliedAlpha=!0),this.forceSinglePass===!0&&(t.forceSinglePass=!0),this.wireframe===!0&&(t.wireframe=!0),this.wireframeLinewidth>1&&(t.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(t.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(t.wireframeLinejoin=this.wireframeLinejoin),this.flatShading===!0&&(t.flatShading=!0),this.visible===!1&&(t.visible=!1),this.toneMapped===!1&&(t.toneMapped=!1),this.fog===!1&&(t.fog=!1),Object.keys(this.userData).length>0&&(t.userData=this.userData);function n(s){const o=[];for(const r in s){const a=s[r];delete a.metadata,o.push(a)}return o}if(e){const s=n(A.textures),o=n(A.images);s.length>0&&(t.textures=s),o.length>0&&(t.images=o)}return t}clone(){return new this.constructor().copy(this)}copy(A){this.name=A.name,this.blending=A.blending,this.side=A.side,this.vertexColors=A.vertexColors,this.opacity=A.opacity,this.transparent=A.transparent,this.blendSrc=A.blendSrc,this.blendDst=A.blendDst,this.blendEquation=A.blendEquation,this.blendSrcAlpha=A.blendSrcAlpha,this.blendDstAlpha=A.blendDstAlpha,this.blendEquationAlpha=A.blendEquationAlpha,this.blendColor.copy(A.blendColor),this.blendAlpha=A.blendAlpha,this.depthFunc=A.depthFunc,this.depthTest=A.depthTest,this.depthWrite=A.depthWrite,this.stencilWriteMask=A.stencilWriteMask,this.stencilFunc=A.stencilFunc,this.stencilRef=A.stencilRef,this.stencilFuncMask=A.stencilFuncMask,this.stencilFail=A.stencilFail,this.stencilZFail=A.stencilZFail,this.stencilZPass=A.stencilZPass,this.stencilWrite=A.stencilWrite;const e=A.clippingPlanes;let t=null;if(e!==null){const n=e.length;t=new Array(n);for(let s=0;s!==n;++s)t[s]=e[s].clone()}return this.clippingPlanes=t,this.clipIntersection=A.clipIntersection,this.clipShadows=A.clipShadows,this.shadowSide=A.shadowSide,this.colorWrite=A.colorWrite,this.precision=A.precision,this.polygonOffset=A.polygonOffset,this.polygonOffsetFactor=A.polygonOffsetFactor,this.polygonOffsetUnits=A.polygonOffsetUnits,this.dithering=A.dithering,this.alphaTest=A.alphaTest,this.alphaHash=A.alphaHash,this.alphaToCoverage=A.alphaToCoverage,this.premultipliedAlpha=A.premultipliedAlpha,this.forceSinglePass=A.forceSinglePass,this.visible=A.visible,this.toneMapped=A.toneMapped,this.userData=JSON.parse(JSON.stringify(A.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(A){A===!0&&this.version++}onBuild(){console.warn("Material: onBuild() has been removed.")}}class tt extends ut{constructor(A){super(),this.isMeshBasicMaterial=!0,this.type="MeshBasicMaterial",this.color=new GA(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new pt,this.combine=sE,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(A)}copy(A){return super.copy(A),this.color.copy(A.color),this.map=A.map,this.lightMap=A.lightMap,this.lightMapIntensity=A.lightMapIntensity,this.aoMap=A.aoMap,this.aoMapIntensity=A.aoMapIntensity,this.specularMap=A.specularMap,this.alphaMap=A.alphaMap,this.envMap=A.envMap,this.envMapRotation.copy(A.envMapRotation),this.combine=A.combine,this.reflectivity=A.reflectivity,this.refractionRatio=A.refractionRatio,this.wireframe=A.wireframe,this.wireframeLinewidth=A.wireframeLinewidth,this.wireframeLinecap=A.wireframeLinecap,this.wireframeLinejoin=A.wireframeLinejoin,this.fog=A.fog,this}}const fe=new L,os=new bA;class Qe{constructor(A,e,t=!1){if(Array.isArray(A))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,this.name="",this.array=A,this.itemSize=e,this.count=A!==void 0?A.length/e:0,this.normalized=t,this.usage=Jr,this.updateRanges=[],this.gpuType=lt,this.version=0}onUploadCallback(){}set needsUpdate(A){A===!0&&this.version++}setUsage(A){return this.usage=A,this}addUpdateRange(A,e){this.updateRanges.push({start:A,count:e})}clearUpdateRanges(){this.updateRanges.length=0}copy(A){return this.name=A.name,this.array=new A.array.constructor(A.array),this.itemSize=A.itemSize,this.count=A.count,this.normalized=A.normalized,this.usage=A.usage,this.gpuType=A.gpuType,this}copyAt(A,e,t){A*=this.itemSize,t*=e.itemSize;for(let n=0,s=this.itemSize;n<s;n++)this.array[A+n]=e.array[t+n];return this}copyArray(A){return this.array.set(A),this}applyMatrix3(A){if(this.itemSize===2)for(let e=0,t=this.count;e<t;e++)os.fromBufferAttribute(this,e),os.applyMatrix3(A),this.setXY(e,os.x,os.y);else if(this.itemSize===3)for(let e=0,t=this.count;e<t;e++)fe.fromBufferAttribute(this,e),fe.applyMatrix3(A),this.setXYZ(e,fe.x,fe.y,fe.z);return this}applyMatrix4(A){for(let e=0,t=this.count;e<t;e++)fe.fromBufferAttribute(this,e),fe.applyMatrix4(A),this.setXYZ(e,fe.x,fe.y,fe.z);return this}applyNormalMatrix(A){for(let e=0,t=this.count;e<t;e++)fe.fromBufferAttribute(this,e),fe.applyNormalMatrix(A),this.setXYZ(e,fe.x,fe.y,fe.z);return this}transformDirection(A){for(let e=0,t=this.count;e<t;e++)fe.fromBufferAttribute(this,e),fe.transformDirection(A),this.setXYZ(e,fe.x,fe.y,fe.z);return this}set(A,e=0){return this.array.set(A,e),this}getComponent(A,e){let t=this.array[A*this.itemSize+e];return this.normalized&&(t=ct(t,this.array)),t}setComponent(A,e,t){return this.normalized&&(t=re(t,this.array)),this.array[A*this.itemSize+e]=t,this}getX(A){let e=this.array[A*this.itemSize];return this.normalized&&(e=ct(e,this.array)),e}setX(A,e){return this.normalized&&(e=re(e,this.array)),this.array[A*this.itemSize]=e,this}getY(A){let e=this.array[A*this.itemSize+1];return this.normalized&&(e=ct(e,this.array)),e}setY(A,e){return this.normalized&&(e=re(e,this.array)),this.array[A*this.itemSize+1]=e,this}getZ(A){let e=this.array[A*this.itemSize+2];return this.normalized&&(e=ct(e,this.array)),e}setZ(A,e){return this.normalized&&(e=re(e,this.array)),this.array[A*this.itemSize+2]=e,this}getW(A){let e=this.array[A*this.itemSize+3];return this.normalized&&(e=ct(e,this.array)),e}setW(A,e){return this.normalized&&(e=re(e,this.array)),this.array[A*this.itemSize+3]=e,this}setXY(A,e,t){return A*=this.itemSize,this.normalized&&(e=re(e,this.array),t=re(t,this.array)),this.array[A+0]=e,this.array[A+1]=t,this}setXYZ(A,e,t,n){return A*=this.itemSize,this.normalized&&(e=re(e,this.array),t=re(t,this.array),n=re(n,this.array)),this.array[A+0]=e,this.array[A+1]=t,this.array[A+2]=n,this}setXYZW(A,e,t,n,s){return A*=this.itemSize,this.normalized&&(e=re(e,this.array),t=re(t,this.array),n=re(n,this.array),s=re(s,this.array)),this.array[A+0]=e,this.array[A+1]=t,this.array[A+2]=n,this.array[A+3]=s,this}onUpload(A){return this.onUploadCallback=A,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const A={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.from(this.array),normalized:this.normalized};return this.name!==""&&(A.name=this.name),this.usage!==Jr&&(A.usage=this.usage),A}}class mE extends Qe{constructor(A,e,t){super(new Uint16Array(A),e,t)}}class yE extends Qe{constructor(A,e,t){super(new Uint32Array(A),e,t)}}class Rt extends Qe{constructor(A,e,t){super(new Float32Array(A),e,t)}}let dB=0;const $e=new UA,No=new Be,Pi=new L,qe=new rt,mn=new rt,Re=new L;class Xe extends Si{constructor(){super(),this.isBufferGeometry=!0,Object.defineProperty(this,"id",{value:dB++}),this.uuid=dt(),this.name="",this.type="BufferGeometry",this.index=null,this.indirect=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(A){return Array.isArray(A)?this.index=new(uE(A)?yE:mE)(A,1):this.index=A,this}setIndirect(A){return this.indirect=A,this}getIndirect(){return this.indirect}getAttribute(A){return this.attributes[A]}setAttribute(A,e){return this.attributes[A]=e,this}deleteAttribute(A){return delete this.attributes[A],this}hasAttribute(A){return this.attributes[A]!==void 0}addGroup(A,e,t=0){this.groups.push({start:A,count:e,materialIndex:t})}clearGroups(){this.groups=[]}setDrawRange(A,e){this.drawRange.start=A,this.drawRange.count=e}applyMatrix4(A){const e=this.attributes.position;e!==void 0&&(e.applyMatrix4(A),e.needsUpdate=!0);const t=this.attributes.normal;if(t!==void 0){const s=new PA().getNormalMatrix(A);t.applyNormalMatrix(s),t.needsUpdate=!0}const n=this.attributes.tangent;return n!==void 0&&(n.transformDirection(A),n.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}applyQuaternion(A){return $e.makeRotationFromQuaternion(A),this.applyMatrix4($e),this}rotateX(A){return $e.makeRotationX(A),this.applyMatrix4($e),this}rotateY(A){return $e.makeRotationY(A),this.applyMatrix4($e),this}rotateZ(A){return $e.makeRotationZ(A),this.applyMatrix4($e),this}translate(A,e,t){return $e.makeTranslation(A,e,t),this.applyMatrix4($e),this}scale(A,e,t){return $e.makeScale(A,e,t),this.applyMatrix4($e),this}lookAt(A){return No.lookAt(A),No.updateMatrix(),this.applyMatrix4(No.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(Pi).negate(),this.translate(Pi.x,Pi.y,Pi.z),this}setFromPoints(A){const e=this.getAttribute("position");if(e===void 0){const t=[];for(let n=0,s=A.length;n<s;n++){const o=A[n];t.push(o.x,o.y,o.z||0)}this.setAttribute("position",new Rt(t,3))}else{const t=Math.min(A.length,e.count);for(let n=0;n<t;n++){const s=A[n];e.setXYZ(n,s.x,s.y,s.z||0)}A.length>e.count&&console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."),e.needsUpdate=!0}return this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new rt);const A=this.attributes.position,e=this.morphAttributes.position;if(A&&A.isGLBufferAttribute){console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.",this),this.boundingBox.set(new L(-1/0,-1/0,-1/0),new L(1/0,1/0,1/0));return}if(A!==void 0){if(this.boundingBox.setFromBufferAttribute(A),e)for(let t=0,n=e.length;t<n;t++){const s=e[t];qe.setFromBufferAttribute(s),this.morphTargetsRelative?(Re.addVectors(this.boundingBox.min,qe.min),this.boundingBox.expandByPoint(Re),Re.addVectors(this.boundingBox.max,qe.max),this.boundingBox.expandByPoint(Re)):(this.boundingBox.expandByPoint(qe.min),this.boundingBox.expandByPoint(qe.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new Dt);const A=this.attributes.position,e=this.morphAttributes.position;if(A&&A.isGLBufferAttribute){console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.",this),this.boundingSphere.set(new L,1/0);return}if(A){const t=this.boundingSphere.center;if(qe.setFromBufferAttribute(A),e)for(let s=0,o=e.length;s<o;s++){const r=e[s];mn.setFromBufferAttribute(r),this.morphTargetsRelative?(Re.addVectors(qe.min,mn.min),qe.expandByPoint(Re),Re.addVectors(qe.max,mn.max),qe.expandByPoint(Re)):(qe.expandByPoint(mn.min),qe.expandByPoint(mn.max))}qe.getCenter(t);let n=0;for(let s=0,o=A.count;s<o;s++)Re.fromBufferAttribute(A,s),n=Math.max(n,t.distanceToSquared(Re));if(e)for(let s=0,o=e.length;s<o;s++){const r=e[s],a=this.morphTargetsRelative;for(let g=0,I=r.count;g<I;g++)Re.fromBufferAttribute(r,g),a&&(Pi.fromBufferAttribute(A,g),Re.add(Pi)),n=Math.max(n,t.distanceToSquared(Re))}this.boundingSphere.radius=Math.sqrt(n),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const A=this.index,e=this.attributes;if(A===null||e.position===void 0||e.normal===void 0||e.uv===void 0){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const t=e.position,n=e.normal,s=e.uv;this.hasAttribute("tangent")===!1&&this.setAttribute("tangent",new Qe(new Float32Array(4*t.count),4));const o=this.getAttribute("tangent"),r=[],a=[];for(let N=0;N<t.count;N++)r[N]=new L,a[N]=new L;const g=new L,I=new L,E=new L,C=new bA,Q=new bA,h=new bA,l=new L,B=new L;function c(N,u,f){g.fromBufferAttribute(t,N),I.fromBufferAttribute(t,u),E.fromBufferAttribute(t,f),C.fromBufferAttribute(s,N),Q.fromBufferAttribute(s,u),h.fromBufferAttribute(s,f),I.sub(g),E.sub(g),Q.sub(C),h.sub(C);const m=1/(Q.x*h.y-h.x*Q.y);isFinite(m)&&(l.copy(I).multiplyScalar(h.y).addScaledVector(E,-Q.y).multiplyScalar(m),B.copy(E).multiplyScalar(Q.x).addScaledVector(I,-h.x).multiplyScalar(m),r[N].add(l),r[u].add(l),r[f].add(l),a[N].add(B),a[u].add(B),a[f].add(B))}let R=this.groups;R.length===0&&(R=[{start:0,count:A.count}]);for(let N=0,u=R.length;N<u;++N){const f=R[N],m=f.start,T=f.count;for(let M=m,_=m+T;M<_;M+=3)c(A.getX(M+0),A.getX(M+1),A.getX(M+2))}const p=new L,d=new L,w=new L,S=new L;function F(N){w.fromBufferAttribute(n,N),S.copy(w);const u=r[N];p.copy(u),p.sub(w.multiplyScalar(w.dot(u))).normalize(),d.crossVectors(S,u);const m=d.dot(a[N])<0?-1:1;o.setXYZW(N,p.x,p.y,p.z,m)}for(let N=0,u=R.length;N<u;++N){const f=R[N],m=f.start,T=f.count;for(let M=m,_=m+T;M<_;M+=3)F(A.getX(M+0)),F(A.getX(M+1)),F(A.getX(M+2))}}computeVertexNormals(){const A=this.index,e=this.getAttribute("position");if(e!==void 0){let t=this.getAttribute("normal");if(t===void 0)t=new Qe(new Float32Array(e.count*3),3),this.setAttribute("normal",t);else for(let C=0,Q=t.count;C<Q;C++)t.setXYZ(C,0,0,0);const n=new L,s=new L,o=new L,r=new L,a=new L,g=new L,I=new L,E=new L;if(A)for(let C=0,Q=A.count;C<Q;C+=3){const h=A.getX(C+0),l=A.getX(C+1),B=A.getX(C+2);n.fromBufferAttribute(e,h),s.fromBufferAttribute(e,l),o.fromBufferAttribute(e,B),I.subVectors(o,s),E.subVectors(n,s),I.cross(E),r.fromBufferAttribute(t,h),a.fromBufferAttribute(t,l),g.fromBufferAttribute(t,B),r.add(I),a.add(I),g.add(I),t.setXYZ(h,r.x,r.y,r.z),t.setXYZ(l,a.x,a.y,a.z),t.setXYZ(B,g.x,g.y,g.z)}else for(let C=0,Q=e.count;C<Q;C+=3)n.fromBufferAttribute(e,C+0),s.fromBufferAttribute(e,C+1),o.fromBufferAttribute(e,C+2),I.subVectors(o,s),E.subVectors(n,s),I.cross(E),t.setXYZ(C+0,I.x,I.y,I.z),t.setXYZ(C+1,I.x,I.y,I.z),t.setXYZ(C+2,I.x,I.y,I.z);this.normalizeNormals(),t.needsUpdate=!0}}normalizeNormals(){const A=this.attributes.normal;for(let e=0,t=A.count;e<t;e++)Re.fromBufferAttribute(A,e),Re.normalize(),A.setXYZ(e,Re.x,Re.y,Re.z)}toNonIndexed(){function A(r,a){const g=r.array,I=r.itemSize,E=r.normalized,C=new g.constructor(a.length*I);let Q=0,h=0;for(let l=0,B=a.length;l<B;l++){r.isInterleavedBufferAttribute?Q=a[l]*r.data.stride+r.offset:Q=a[l]*I;for(let c=0;c<I;c++)C[h++]=g[Q++]}return new Qe(C,I,E)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const e=new Xe,t=this.index.array,n=this.attributes;for(const r in n){const a=n[r],g=A(a,t);e.setAttribute(r,g)}const s=this.morphAttributes;for(const r in s){const a=[],g=s[r];for(let I=0,E=g.length;I<E;I++){const C=g[I],Q=A(C,t);a.push(Q)}e.morphAttributes[r]=a}e.morphTargetsRelative=this.morphTargetsRelative;const o=this.groups;for(let r=0,a=o.length;r<a;r++){const g=o[r];e.addGroup(g.start,g.count,g.materialIndex)}return e}toJSON(){const A={metadata:{version:4.6,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(A.uuid=this.uuid,A.type=this.type,this.name!==""&&(A.name=this.name),Object.keys(this.userData).length>0&&(A.userData=this.userData),this.parameters!==void 0){const a=this.parameters;for(const g in a)a[g]!==void 0&&(A[g]=a[g]);return A}A.data={attributes:{}};const e=this.index;e!==null&&(A.data.index={type:e.array.constructor.name,array:Array.prototype.slice.call(e.array)});const t=this.attributes;for(const a in t){const g=t[a];A.data.attributes[a]=g.toJSON(A.data)}const n={};let s=!1;for(const a in this.morphAttributes){const g=this.morphAttributes[a],I=[];for(let E=0,C=g.length;E<C;E++){const Q=g[E];I.push(Q.toJSON(A.data))}I.length>0&&(n[a]=I,s=!0)}s&&(A.data.morphAttributes=n,A.data.morphTargetsRelative=this.morphTargetsRelative);const o=this.groups;o.length>0&&(A.data.groups=JSON.parse(JSON.stringify(o)));const r=this.boundingSphere;return r!==null&&(A.data.boundingSphere={center:r.center.toArray(),radius:r.radius}),A}clone(){return new this.constructor().copy(this)}copy(A){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const e={};this.name=A.name;const t=A.index;t!==null&&this.setIndex(t.clone(e));const n=A.attributes;for(const g in n){const I=n[g];this.setAttribute(g,I.clone(e))}const s=A.morphAttributes;for(const g in s){const I=[],E=s[g];for(let C=0,Q=E.length;C<Q;C++)I.push(E[C].clone(e));this.morphAttributes[g]=I}this.morphTargetsRelative=A.morphTargetsRelative;const o=A.groups;for(let g=0,I=o.length;g<I;g++){const E=o[g];this.addGroup(E.start,E.count,E.materialIndex)}const r=A.boundingBox;r!==null&&(this.boundingBox=r.clone());const a=A.boundingSphere;return a!==null&&(this.boundingSphere=a.clone()),this.drawRange.start=A.drawRange.start,this.drawRange.count=A.drawRange.count,this.userData=A.userData,this}dispose(){this.dispatchEvent({type:"dispose"})}}const Ig=new UA,hi=new Mi,rs=new Dt,Eg=new L,as=new L,gs=new L,Is=new L,xo=new L,Es=new L,Cg=new L,Cs=new L;class ve extends Be{constructor(A=new Xe,e=new tt){super(),this.isMesh=!0,this.type="Mesh",this.geometry=A,this.material=e,this.updateMorphTargets()}copy(A,e){return super.copy(A,e),A.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=A.morphTargetInfluences.slice()),A.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},A.morphTargetDictionary)),this.material=Array.isArray(A.material)?A.material.slice():A.material,this.geometry=A.geometry,this}updateMorphTargets(){const e=this.geometry.morphAttributes,t=Object.keys(e);if(t.length>0){const n=e[t[0]];if(n!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let s=0,o=n.length;s<o;s++){const r=n[s].name||String(s);this.morphTargetInfluences.push(0),this.morphTargetDictionary[r]=s}}}}getVertexPosition(A,e){const t=this.geometry,n=t.attributes.position,s=t.morphAttributes.position,o=t.morphTargetsRelative;e.fromBufferAttribute(n,A);const r=this.morphTargetInfluences;if(s&&r){Es.set(0,0,0);for(let a=0,g=s.length;a<g;a++){const I=r[a],E=s[a];I!==0&&(xo.fromBufferAttribute(E,A),o?Es.addScaledVector(xo,I):Es.addScaledVector(xo.sub(e),I))}e.add(Es)}return e}raycast(A,e){const t=this.geometry,n=this.material,s=this.matrixWorld;n!==void 0&&(t.boundingSphere===null&&t.computeBoundingSphere(),rs.copy(t.boundingSphere),rs.applyMatrix4(s),hi.copy(A.ray).recast(A.near),!(rs.containsPoint(hi.origin)===!1&&(hi.intersectSphere(rs,Eg)===null||hi.origin.distanceToSquared(Eg)>(A.far-A.near)**2))&&(Ig.copy(s).invert(),hi.copy(A.ray).applyMatrix4(Ig),!(t.boundingBox!==null&&hi.intersectsBox(t.boundingBox)===!1)&&this._computeIntersections(A,e,hi)))}_computeIntersections(A,e,t){let n;const s=this.geometry,o=this.material,r=s.index,a=s.attributes.position,g=s.attributes.uv,I=s.attributes.uv1,E=s.attributes.normal,C=s.groups,Q=s.drawRange;if(r!==null)if(Array.isArray(o))for(let h=0,l=C.length;h<l;h++){const B=C[h],c=o[B.materialIndex],R=Math.max(B.start,Q.start),p=Math.min(r.count,Math.min(B.start+B.count,Q.start+Q.count));for(let d=R,w=p;d<w;d+=3){const S=r.getX(d),F=r.getX(d+1),N=r.getX(d+2);n=Qs(this,c,A,t,g,I,E,S,F,N),n&&(n.faceIndex=Math.floor(d/3),n.face.materialIndex=B.materialIndex,e.push(n))}}else{const h=Math.max(0,Q.start),l=Math.min(r.count,Q.start+Q.count);for(let B=h,c=l;B<c;B+=3){const R=r.getX(B),p=r.getX(B+1),d=r.getX(B+2);n=Qs(this,o,A,t,g,I,E,R,p,d),n&&(n.faceIndex=Math.floor(B/3),e.push(n))}}else if(a!==void 0)if(Array.isArray(o))for(let h=0,l=C.length;h<l;h++){const B=C[h],c=o[B.materialIndex],R=Math.max(B.start,Q.start),p=Math.min(a.count,Math.min(B.start+B.count,Q.start+Q.count));for(let d=R,w=p;d<w;d+=3){const S=d,F=d+1,N=d+2;n=Qs(this,c,A,t,g,I,E,S,F,N),n&&(n.faceIndex=Math.floor(d/3),n.face.materialIndex=B.materialIndex,e.push(n))}}else{const h=Math.max(0,Q.start),l=Math.min(a.count,Q.start+Q.count);for(let B=h,c=l;B<c;B+=3){const R=B,p=B+1,d=B+2;n=Qs(this,o,A,t,g,I,E,R,p,d),n&&(n.faceIndex=Math.floor(B/3),e.push(n))}}}}function uB(i,A,e,t,n,s,o,r){let a;if(A.side===Je?a=t.intersectTriangle(o,s,n,!0,r):a=t.intersectTriangle(n,s,o,A.side===ft,r),a===null)return null;Cs.copy(r),Cs.applyMatrix4(i.matrixWorld);const g=e.ray.origin.distanceTo(Cs);return g<e.near||g>e.far?null:{distance:g,point:Cs.clone(),object:i}}function Qs(i,A,e,t,n,s,o,r,a,g){i.getVertexPosition(r,as),i.getVertexPosition(a,gs),i.getVertexPosition(g,Is);const I=uB(i,A,e,t,as,gs,Is,Cg);if(I){const E=new L;ht.getBarycoord(Cg,as,gs,Is,E),n&&(I.uv=ht.getInterpolatedAttribute(n,r,a,g,E,new bA)),s&&(I.uv1=ht.getInterpolatedAttribute(s,r,a,g,E,new bA)),o&&(I.normal=ht.getInterpolatedAttribute(o,r,a,g,E,new L),I.normal.dot(t.direction)>0&&I.normal.multiplyScalar(-1));const C={a:r,b:a,c:g,normal:new L,materialIndex:0};ht.getNormal(as,gs,Is,C.normal),I.face=C,I.barycoord=E}return I}class Wn extends Xe{constructor(A=1,e=1,t=1,n=1,s=1,o=1){super(),this.type="BoxGeometry",this.parameters={width:A,height:e,depth:t,widthSegments:n,heightSegments:s,depthSegments:o};const r=this;n=Math.floor(n),s=Math.floor(s),o=Math.floor(o);const a=[],g=[],I=[],E=[];let C=0,Q=0;h("z","y","x",-1,-1,t,e,A,o,s,0),h("z","y","x",1,-1,t,e,-A,o,s,1),h("x","z","y",1,1,A,t,e,n,o,2),h("x","z","y",1,-1,A,t,-e,n,o,3),h("x","y","z",1,-1,A,e,t,n,s,4),h("x","y","z",-1,-1,A,e,-t,n,s,5),this.setIndex(a),this.setAttribute("position",new Rt(g,3)),this.setAttribute("normal",new Rt(I,3)),this.setAttribute("uv",new Rt(E,2));function h(l,B,c,R,p,d,w,S,F,N,u){const f=d/F,m=w/N,T=d/2,M=w/2,_=S/2,P=F+1,b=N+1;let z=0,O=0;const eA=new L;for(let oA=0;oA<b;oA++){const gA=oA*m-M;for(let pA=0;pA<P;pA++){const qA=pA*f-T;eA[l]=qA*R,eA[B]=gA*p,eA[c]=_,g.push(eA.x,eA.y,eA.z),eA[l]=0,eA[B]=0,eA[c]=S>0?1:-1,I.push(eA.x,eA.y,eA.z),E.push(pA/F),E.push(1-oA/N),z+=1}}for(let oA=0;oA<N;oA++)for(let gA=0;gA<F;gA++){const pA=C+gA+P*oA,qA=C+gA+P*(oA+1),X=C+(gA+1)+P*(oA+1),AA=C+(gA+1)+P*oA;a.push(pA,qA,AA),a.push(qA,X,AA),O+=6}r.addGroup(Q,O,u),Q+=O,C+=z}}copy(A){return super.copy(A),this.parameters=Object.assign({},A.parameters),this}static fromJSON(A){return new Wn(A.width,A.height,A.depth,A.widthSegments,A.heightSegments,A.depthSegments)}}function En(i){const A={};for(const e in i){A[e]={};for(const t in i[e]){const n=i[e][t];n&&(n.isColor||n.isMatrix3||n.isMatrix4||n.isVector2||n.isVector3||n.isVector4||n.isTexture||n.isQuaternion)?n.isRenderTargetTexture?(console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),A[e][t]=null):A[e][t]=n.clone():Array.isArray(n)?A[e][t]=n.slice():A[e][t]=n}}return A}function Ge(i){const A={};for(let e=0;e<i.length;e++){const t=En(i[e]);for(const n in t)A[n]=t[n]}return A}function fB(i){const A=[];for(let e=0;e<i.length;e++)A.push(i[e].clone());return A}function RE(i){const A=i.getRenderTarget();return A===null?i.outputColorSpace:A.isXRRenderTarget===!0?A.texture.colorSpace:$A.workingColorSpace}const wE={clone:En,merge:Ge};var pB=`void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,DB=`void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;class Wt extends ut{constructor(A){super(),this.isShaderMaterial=!0,this.type="ShaderMaterial",this.defines={},this.uniforms={},this.uniformsGroups=[],this.vertexShader=pB,this.fragmentShader=DB,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.forceSinglePass=!0,this.extensions={clipCullDistance:!1,multiDraw:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv1:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,A!==void 0&&this.setValues(A)}copy(A){return super.copy(A),this.fragmentShader=A.fragmentShader,this.vertexShader=A.vertexShader,this.uniforms=En(A.uniforms),this.uniformsGroups=fB(A.uniformsGroups),this.defines=Object.assign({},A.defines),this.wireframe=A.wireframe,this.wireframeLinewidth=A.wireframeLinewidth,this.fog=A.fog,this.lights=A.lights,this.clipping=A.clipping,this.extensions=Object.assign({},A.extensions),this.glslVersion=A.glslVersion,this}toJSON(A){const e=super.toJSON(A);e.glslVersion=this.glslVersion,e.uniforms={};for(const n in this.uniforms){const o=this.uniforms[n].value;o&&o.isTexture?e.uniforms[n]={type:"t",value:o.toJSON(A).uuid}:o&&o.isColor?e.uniforms[n]={type:"c",value:o.getHex()}:o&&o.isVector2?e.uniforms[n]={type:"v2",value:o.toArray()}:o&&o.isVector3?e.uniforms[n]={type:"v3",value:o.toArray()}:o&&o.isVector4?e.uniforms[n]={type:"v4",value:o.toArray()}:o&&o.isMatrix3?e.uniforms[n]={type:"m3",value:o.toArray()}:o&&o.isMatrix4?e.uniforms[n]={type:"m4",value:o.toArray()}:e.uniforms[n]={value:o}}Object.keys(this.defines).length>0&&(e.defines=this.defines),e.vertexShader=this.vertexShader,e.fragmentShader=this.fragmentShader,e.lights=this.lights,e.clipping=this.clipping;const t={};for(const n in this.extensions)this.extensions[n]===!0&&(t[n]=!0);return Object.keys(t).length>0&&(e.extensions=t),e}}class SE extends Be{constructor(){super(),this.isCamera=!0,this.type="Camera",this.matrixWorldInverse=new UA,this.projectionMatrix=new UA,this.projectionMatrixInverse=new UA,this.coordinateSystem=Jt}copy(A,e){return super.copy(A,e),this.matrixWorldInverse.copy(A.matrixWorldInverse),this.projectionMatrix.copy(A.projectionMatrix),this.projectionMatrixInverse.copy(A.projectionMatrixInverse),this.coordinateSystem=A.coordinateSystem,this}getWorldDirection(A){return super.getWorldDirection(A).negate()}updateMatrixWorld(A){super.updateMatrixWorld(A),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(A,e){super.updateWorldMatrix(A,e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}}const $t=new L,Qg=new bA,Bg=new bA;class Le extends SE{constructor(A=50,e=1,t=.1,n=2e3){super(),this.isPerspectiveCamera=!0,this.type="PerspectiveCamera",this.fov=A,this.zoom=1,this.near=t,this.far=n,this.focus=10,this.aspect=e,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(A,e){return super.copy(A,e),this.fov=A.fov,this.zoom=A.zoom,this.near=A.near,this.far=A.far,this.focus=A.focus,this.aspect=A.aspect,this.view=A.view===null?null:Object.assign({},A.view),this.filmGauge=A.filmGauge,this.filmOffset=A.filmOffset,this}setFocalLength(A){const e=.5*this.getFilmHeight()/A;this.fov=In*2*Math.atan(e),this.updateProjectionMatrix()}getFocalLength(){const A=Math.tan(Gn*.5*this.fov);return .5*this.getFilmHeight()/A}getEffectiveFOV(){return In*2*Math.atan(Math.tan(Gn*.5*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}getViewBounds(A,e,t){$t.set(-1,-1,.5).applyMatrix4(this.projectionMatrixInverse),e.set($t.x,$t.y).multiplyScalar(-A/$t.z),$t.set(1,1,.5).applyMatrix4(this.projectionMatrixInverse),t.set($t.x,$t.y).multiplyScalar(-A/$t.z)}getViewSize(A,e){return this.getViewBounds(A,Qg,Bg),e.subVectors(Bg,Qg)}setViewOffset(A,e,t,n,s,o){this.aspect=A/e,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=A,this.view.fullHeight=e,this.view.offsetX=t,this.view.offsetY=n,this.view.width=s,this.view.height=o,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const A=this.near;let e=A*Math.tan(Gn*.5*this.fov)/this.zoom,t=2*e,n=this.aspect*t,s=-.5*n;const o=this.view;if(this.view!==null&&this.view.enabled){const a=o.fullWidth,g=o.fullHeight;s+=o.offsetX*n/a,e-=o.offsetY*t/g,n*=o.width/a,t*=o.height/g}const r=this.filmOffset;r!==0&&(s+=A*r/this.getFilmWidth()),this.projectionMatrix.makePerspective(s,s+n,e,e-t,A,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(A){const e=super.toJSON(A);return e.object.fov=this.fov,e.object.zoom=this.zoom,e.object.near=this.near,e.object.far=this.far,e.object.focus=this.focus,e.object.aspect=this.aspect,this.view!==null&&(e.object.view=Object.assign({},this.view)),e.object.filmGauge=this.filmGauge,e.object.filmOffset=this.filmOffset,e}}const Oi=-90,Ji=1;class mB extends Be{constructor(A,e,t){super(),this.type="CubeCamera",this.renderTarget=t,this.coordinateSystem=null,this.activeMipmapLevel=0;const n=new Le(Oi,Ji,A,e);n.layers=this.layers,this.add(n);const s=new Le(Oi,Ji,A,e);s.layers=this.layers,this.add(s);const o=new Le(Oi,Ji,A,e);o.layers=this.layers,this.add(o);const r=new Le(Oi,Ji,A,e);r.layers=this.layers,this.add(r);const a=new Le(Oi,Ji,A,e);a.layers=this.layers,this.add(a);const g=new Le(Oi,Ji,A,e);g.layers=this.layers,this.add(g)}updateCoordinateSystem(){const A=this.coordinateSystem,e=this.children.concat(),[t,n,s,o,r,a]=e;for(const g of e)this.remove(g);if(A===Jt)t.up.set(0,1,0),t.lookAt(1,0,0),n.up.set(0,1,0),n.lookAt(-1,0,0),s.up.set(0,0,-1),s.lookAt(0,1,0),o.up.set(0,0,1),o.lookAt(0,-1,0),r.up.set(0,1,0),r.lookAt(0,0,1),a.up.set(0,1,0),a.lookAt(0,0,-1);else if(A===Ys)t.up.set(0,-1,0),t.lookAt(-1,0,0),n.up.set(0,-1,0),n.lookAt(1,0,0),s.up.set(0,0,1),s.lookAt(0,1,0),o.up.set(0,0,-1),o.lookAt(0,-1,0),r.up.set(0,-1,0),r.lookAt(0,0,1),a.up.set(0,-1,0),a.lookAt(0,0,-1);else throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: "+A);for(const g of e)this.add(g),g.updateMatrixWorld()}update(A,e){this.parent===null&&this.updateMatrixWorld();const{renderTarget:t,activeMipmapLevel:n}=this;this.coordinateSystem!==A.coordinateSystem&&(this.coordinateSystem=A.coordinateSystem,this.updateCoordinateSystem());const[s,o,r,a,g,I]=this.children,E=A.getRenderTarget(),C=A.getActiveCubeFace(),Q=A.getActiveMipmapLevel(),h=A.xr.enabled;A.xr.enabled=!1;const l=t.texture.generateMipmaps;t.texture.generateMipmaps=!1,A.setRenderTarget(t,0,n),A.render(e,s),A.setRenderTarget(t,1,n),A.render(e,o),A.setRenderTarget(t,2,n),A.render(e,r),A.setRenderTarget(t,3,n),A.render(e,a),A.setRenderTarget(t,4,n),A.render(e,g),t.texture.generateMipmaps=l,A.setRenderTarget(t,5,n),A.render(e,I),A.setRenderTarget(E,C,Q),A.xr.enabled=h,t.texture.needsPMREMUpdate=!0}}class ME extends de{constructor(A,e,t,n,s,o,r,a,g,I){A=A!==void 0?A:[],e=e!==void 0?e:sn,super(A,e,t,n,s,o,r,a,g,I),this.isCubeTexture=!0,this.flipY=!1}get images(){return this.image}set images(A){this.image=A}}class yB extends wi{constructor(A=1,e={}){super(A,A,e),this.isWebGLCubeRenderTarget=!0;const t={width:A,height:A,depth:1},n=[t,t,t,t,t,t];this.texture=new ME(n,e.mapping,e.wrapS,e.wrapT,e.magFilter,e.minFilter,e.format,e.type,e.anisotropy,e.colorSpace),this.texture.isRenderTargetTexture=!0,this.texture.generateMipmaps=e.generateMipmaps!==void 0?e.generateMipmaps:!1,this.texture.minFilter=e.minFilter!==void 0?e.minFilter:ze}fromEquirectangularTexture(A,e){this.texture.type=e.type,this.texture.colorSpace=e.colorSpace,this.texture.generateMipmaps=e.generateMipmaps,this.texture.minFilter=e.minFilter,this.texture.magFilter=e.magFilter;const t={uniforms:{tEquirect:{value:null}},vertexShader:`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,fragmentShader:`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`},n=new Wn(5,5,5),s=new Wt({name:"CubemapFromEquirect",uniforms:En(t.uniforms),vertexShader:t.vertexShader,fragmentShader:t.fragmentShader,side:Je,blending:ri});s.uniforms.tEquirect.value=e;const o=new ve(n,s),r=e.minFilter;return e.minFilter===Ot&&(e.minFilter=ze),new mB(1,10,this).update(A,o),e.minFilter=r,o.geometry.dispose(),o.material.dispose(),this}clear(A,e,t,n){const s=A.getRenderTarget();for(let o=0;o<6;o++)A.setRenderTarget(this,o),A.clear(e,t,n);A.setRenderTarget(s)}}class RB extends Be{constructor(){super(),this.isScene=!0,this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.backgroundBlurriness=0,this.backgroundIntensity=1,this.backgroundRotation=new pt,this.environmentIntensity=1,this.environmentRotation=new pt,this.overrideMaterial=null,typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(A,e){return super.copy(A,e),A.background!==null&&(this.background=A.background.clone()),A.environment!==null&&(this.environment=A.environment.clone()),A.fog!==null&&(this.fog=A.fog.clone()),this.backgroundBlurriness=A.backgroundBlurriness,this.backgroundIntensity=A.backgroundIntensity,this.backgroundRotation.copy(A.backgroundRotation),this.environmentIntensity=A.environmentIntensity,this.environmentRotation.copy(A.environmentRotation),A.overrideMaterial!==null&&(this.overrideMaterial=A.overrideMaterial.clone()),this.matrixAutoUpdate=A.matrixAutoUpdate,this}toJSON(A){const e=super.toJSON(A);return this.fog!==null&&(e.object.fog=this.fog.toJSON()),this.backgroundBlurriness>0&&(e.object.backgroundBlurriness=this.backgroundBlurriness),this.backgroundIntensity!==1&&(e.object.backgroundIntensity=this.backgroundIntensity),e.object.backgroundRotation=this.backgroundRotation.toArray(),this.environmentIntensity!==1&&(e.object.environmentIntensity=this.environmentIntensity),e.object.environmentRotation=this.environmentRotation.toArray(),e}}class wB{constructor(A,e){this.isInterleavedBuffer=!0,this.array=A,this.stride=e,this.count=A!==void 0?A.length/e:0,this.usage=Jr,this.updateRanges=[],this.version=0,this.uuid=dt()}onUploadCallback(){}set needsUpdate(A){A===!0&&this.version++}setUsage(A){return this.usage=A,this}addUpdateRange(A,e){this.updateRanges.push({start:A,count:e})}clearUpdateRanges(){this.updateRanges.length=0}copy(A){return this.array=new A.array.constructor(A.array),this.count=A.count,this.stride=A.stride,this.usage=A.usage,this}copyAt(A,e,t){A*=this.stride,t*=e.stride;for(let n=0,s=this.stride;n<s;n++)this.array[A+n]=e.array[t+n];return this}set(A,e=0){return this.array.set(A,e),this}clone(A){A.arrayBuffers===void 0&&(A.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=dt()),A.arrayBuffers[this.array.buffer._uuid]===void 0&&(A.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const e=new this.array.constructor(A.arrayBuffers[this.array.buffer._uuid]),t=new this.constructor(e,this.stride);return t.setUsage(this.usage),t}onUpload(A){return this.onUploadCallback=A,this}toJSON(A){return A.arrayBuffers===void 0&&(A.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=dt()),A.arrayBuffers[this.array.buffer._uuid]===void 0&&(A.arrayBuffers[this.array.buffer._uuid]=Array.from(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}const Ue=new L;class ca{constructor(A,e,t,n=!1){this.isInterleavedBufferAttribute=!0,this.name="",this.data=A,this.itemSize=e,this.offset=t,this.normalized=n}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(A){this.data.needsUpdate=A}applyMatrix4(A){for(let e=0,t=this.data.count;e<t;e++)Ue.fromBufferAttribute(this,e),Ue.applyMatrix4(A),this.setXYZ(e,Ue.x,Ue.y,Ue.z);return this}applyNormalMatrix(A){for(let e=0,t=this.count;e<t;e++)Ue.fromBufferAttribute(this,e),Ue.applyNormalMatrix(A),this.setXYZ(e,Ue.x,Ue.y,Ue.z);return this}transformDirection(A){for(let e=0,t=this.count;e<t;e++)Ue.fromBufferAttribute(this,e),Ue.transformDirection(A),this.setXYZ(e,Ue.x,Ue.y,Ue.z);return this}getComponent(A,e){let t=this.array[A*this.data.stride+this.offset+e];return this.normalized&&(t=ct(t,this.array)),t}setComponent(A,e,t){return this.normalized&&(t=re(t,this.array)),this.data.array[A*this.data.stride+this.offset+e]=t,this}setX(A,e){return this.normalized&&(e=re(e,this.array)),this.data.array[A*this.data.stride+this.offset]=e,this}setY(A,e){return this.normalized&&(e=re(e,this.array)),this.data.array[A*this.data.stride+this.offset+1]=e,this}setZ(A,e){return this.normalized&&(e=re(e,this.array)),this.data.array[A*this.data.stride+this.offset+2]=e,this}setW(A,e){return this.normalized&&(e=re(e,this.array)),this.data.array[A*this.data.stride+this.offset+3]=e,this}getX(A){let e=this.data.array[A*this.data.stride+this.offset];return this.normalized&&(e=ct(e,this.array)),e}getY(A){let e=this.data.array[A*this.data.stride+this.offset+1];return this.normalized&&(e=ct(e,this.array)),e}getZ(A){let e=this.data.array[A*this.data.stride+this.offset+2];return this.normalized&&(e=ct(e,this.array)),e}getW(A){let e=this.data.array[A*this.data.stride+this.offset+3];return this.normalized&&(e=ct(e,this.array)),e}setXY(A,e,t){return A=A*this.data.stride+this.offset,this.normalized&&(e=re(e,this.array),t=re(t,this.array)),this.data.array[A+0]=e,this.data.array[A+1]=t,this}setXYZ(A,e,t,n){return A=A*this.data.stride+this.offset,this.normalized&&(e=re(e,this.array),t=re(t,this.array),n=re(n,this.array)),this.data.array[A+0]=e,this.data.array[A+1]=t,this.data.array[A+2]=n,this}setXYZW(A,e,t,n,s){return A=A*this.data.stride+this.offset,this.normalized&&(e=re(e,this.array),t=re(t,this.array),n=re(n,this.array),s=re(s,this.array)),this.data.array[A+0]=e,this.data.array[A+1]=t,this.data.array[A+2]=n,this.data.array[A+3]=s,this}clone(A){if(A===void 0){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");const e=[];for(let t=0;t<this.count;t++){const n=t*this.data.stride+this.offset;for(let s=0;s<this.itemSize;s++)e.push(this.data.array[n+s])}return new Qe(new this.array.constructor(e),this.itemSize,this.normalized)}else return A.interleavedBuffers===void 0&&(A.interleavedBuffers={}),A.interleavedBuffers[this.data.uuid]===void 0&&(A.interleavedBuffers[this.data.uuid]=this.data.clone(A)),new ca(A.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(A){if(A===void 0){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");const e=[];for(let t=0;t<this.count;t++){const n=t*this.data.stride+this.offset;for(let s=0;s<this.itemSize;s++)e.push(this.data.array[n+s])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:e,normalized:this.normalized}}else return A.interleavedBuffers===void 0&&(A.interleavedBuffers={}),A.interleavedBuffers[this.data.uuid]===void 0&&(A.interleavedBuffers[this.data.uuid]=this.data.toJSON(A)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}const cg=new L,hg=new YA,lg=new YA,SB=new L,dg=new UA,Bs=new L,Fo=new Dt,ug=new UA,Lo=new Mi;class MB extends ve{constructor(A,e){super(A,e),this.isSkinnedMesh=!0,this.type="SkinnedMesh",this.bindMode=Ya,this.bindMatrix=new UA,this.bindMatrixInverse=new UA,this.boundingBox=null,this.boundingSphere=null}computeBoundingBox(){const A=this.geometry;this.boundingBox===null&&(this.boundingBox=new rt),this.boundingBox.makeEmpty();const e=A.getAttribute("position");for(let t=0;t<e.count;t++)this.getVertexPosition(t,Bs),this.boundingBox.expandByPoint(Bs)}computeBoundingSphere(){const A=this.geometry;this.boundingSphere===null&&(this.boundingSphere=new Dt),this.boundingSphere.makeEmpty();const e=A.getAttribute("position");for(let t=0;t<e.count;t++)this.getVertexPosition(t,Bs),this.boundingSphere.expandByPoint(Bs)}copy(A,e){return super.copy(A,e),this.bindMode=A.bindMode,this.bindMatrix.copy(A.bindMatrix),this.bindMatrixInverse.copy(A.bindMatrixInverse),this.skeleton=A.skeleton,A.boundingBox!==null&&(this.boundingBox=A.boundingBox.clone()),A.boundingSphere!==null&&(this.boundingSphere=A.boundingSphere.clone()),this}raycast(A,e){const t=this.material,n=this.matrixWorld;t!==void 0&&(this.boundingSphere===null&&this.computeBoundingSphere(),Fo.copy(this.boundingSphere),Fo.applyMatrix4(n),A.ray.intersectsSphere(Fo)!==!1&&(ug.copy(n).invert(),Lo.copy(A.ray).applyMatrix4(ug),!(this.boundingBox!==null&&Lo.intersectsBox(this.boundingBox)===!1)&&this._computeIntersections(A,e,Lo)))}getVertexPosition(A,e){return super.getVertexPosition(A,e),this.applyBoneTransform(A,e),e}bind(A,e){this.skeleton=A,e===void 0&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),e=this.matrixWorld),this.bindMatrix.copy(e),this.bindMatrixInverse.copy(e).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){const A=new YA,e=this.geometry.attributes.skinWeight;for(let t=0,n=e.count;t<n;t++){A.fromBufferAttribute(e,t);const s=1/A.manhattanLength();s!==1/0?A.multiplyScalar(s):A.set(1,0,0,0),e.setXYZW(t,A.x,A.y,A.z,A.w)}}updateMatrixWorld(A){super.updateMatrixWorld(A),this.bindMode===Ya?this.bindMatrixInverse.copy(this.matrixWorld).invert():this.bindMode===yQ?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}applyBoneTransform(A,e){const t=this.skeleton,n=this.geometry;hg.fromBufferAttribute(n.attributes.skinIndex,A),lg.fromBufferAttribute(n.attributes.skinWeight,A),cg.copy(e).applyMatrix4(this.bindMatrix),e.set(0,0,0);for(let s=0;s<4;s++){const o=lg.getComponent(s);if(o!==0){const r=hg.getComponent(s);dg.multiplyMatrices(t.bones[r].matrixWorld,t.boneInverses[r]),e.addScaledVector(SB.copy(cg).applyMatrix4(dg),o)}}return e.applyMatrix4(this.bindMatrixInverse)}}class NE extends Be{constructor(){super(),this.isBone=!0,this.type="Bone"}}class bt extends de{constructor(A=null,e=1,t=1,n,s,o,r,a,g=Te,I=Te,E,C){super(null,o,r,a,g,I,n,s,E,C),this.isDataTexture=!0,this.image={data:A,width:e,height:t},this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}const fg=new UA,NB=new UA;class ha{constructor(A=[],e=[]){this.uuid=dt(),this.bones=A.slice(0),this.boneInverses=e,this.boneMatrices=null,this.boneTexture=null,this.init()}init(){const A=this.bones,e=this.boneInverses;if(this.boneMatrices=new Float32Array(A.length*16),e.length===0)this.calculateInverses();else if(A.length!==e.length){console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(let t=0,n=this.bones.length;t<n;t++)this.boneInverses.push(new UA)}}calculateInverses(){this.boneInverses.length=0;for(let A=0,e=this.bones.length;A<e;A++){const t=new UA;this.bones[A]&&t.copy(this.bones[A].matrixWorld).invert(),this.boneInverses.push(t)}}pose(){for(let A=0,e=this.bones.length;A<e;A++){const t=this.bones[A];t&&t.matrixWorld.copy(this.boneInverses[A]).invert()}for(let A=0,e=this.bones.length;A<e;A++){const t=this.bones[A];t&&(t.parent&&t.parent.isBone?(t.matrix.copy(t.parent.matrixWorld).invert(),t.matrix.multiply(t.matrixWorld)):t.matrix.copy(t.matrixWorld),t.matrix.decompose(t.position,t.quaternion,t.scale))}}update(){const A=this.bones,e=this.boneInverses,t=this.boneMatrices,n=this.boneTexture;for(let s=0,o=A.length;s<o;s++){const r=A[s]?A[s].matrixWorld:NB;fg.multiplyMatrices(r,e[s]),fg.toArray(t,s*16)}n!==null&&(n.needsUpdate=!0)}clone(){return new ha(this.bones,this.boneInverses)}computeBoneTexture(){let A=Math.sqrt(this.bones.length*4);A=Math.ceil(A/4)*4,A=Math.max(A,4);const e=new Float32Array(A*A*4);e.set(this.boneMatrices);const t=new bt(e,A,A,et,lt);return t.needsUpdate=!0,this.boneMatrices=e,this.boneTexture=t,this}getBoneByName(A){for(let e=0,t=this.bones.length;e<t;e++){const n=this.bones[e];if(n.name===A)return n}}dispose(){this.boneTexture!==null&&(this.boneTexture.dispose(),this.boneTexture=null)}fromJSON(A,e){this.uuid=A.uuid;for(let t=0,n=A.bones.length;t<n;t++){const s=A.bones[t];let o=e[s];o===void 0&&(console.warn("THREE.Skeleton: No bone found with UUID:",s),o=new NE),this.bones.push(o),this.boneInverses.push(new UA().fromArray(A.boneInverses[t]))}return this.init(),this}toJSON(){const A={metadata:{version:4.6,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};A.uuid=this.uuid;const e=this.bones,t=this.boneInverses;for(let n=0,s=e.length;n<s;n++){const o=e[n];A.bones.push(o.uuid);const r=t[n];A.boneInverses.push(r.toArray())}return A}}class qs extends Qe{constructor(A,e,t,n=1){super(A,e,t),this.isInstancedBufferAttribute=!0,this.meshPerAttribute=n}copy(A){return super.copy(A),this.meshPerAttribute=A.meshPerAttribute,this}toJSON(){const A=super.toJSON();return A.meshPerAttribute=this.meshPerAttribute,A.isInstancedBufferAttribute=!0,A}}const Ki=new UA,pg=new UA,cs=[],Dg=new rt,xB=new UA,yn=new ve,Rn=new Dt;class FB extends ve{constructor(A,e,t){super(A,e),this.isInstancedMesh=!0,this.instanceMatrix=new qs(new Float32Array(t*16),16),this.instanceColor=null,this.morphTexture=null,this.count=t,this.boundingBox=null,this.boundingSphere=null;for(let n=0;n<t;n++)this.setMatrixAt(n,xB)}computeBoundingBox(){const A=this.geometry,e=this.count;this.boundingBox===null&&(this.boundingBox=new rt),A.boundingBox===null&&A.computeBoundingBox(),this.boundingBox.makeEmpty();for(let t=0;t<e;t++)this.getMatrixAt(t,Ki),Dg.copy(A.boundingBox).applyMatrix4(Ki),this.boundingBox.union(Dg)}computeBoundingSphere(){const A=this.geometry,e=this.count;this.boundingSphere===null&&(this.boundingSphere=new Dt),A.boundingSphere===null&&A.computeBoundingSphere(),this.boundingSphere.makeEmpty();for(let t=0;t<e;t++)this.getMatrixAt(t,Ki),Rn.copy(A.boundingSphere).applyMatrix4(Ki),this.boundingSphere.union(Rn)}copy(A,e){return super.copy(A,e),this.instanceMatrix.copy(A.instanceMatrix),A.morphTexture!==null&&(this.morphTexture=A.morphTexture.clone()),A.instanceColor!==null&&(this.instanceColor=A.instanceColor.clone()),this.count=A.count,A.boundingBox!==null&&(this.boundingBox=A.boundingBox.clone()),A.boundingSphere!==null&&(this.boundingSphere=A.boundingSphere.clone()),this}getColorAt(A,e){e.fromArray(this.instanceColor.array,A*3)}getMatrixAt(A,e){e.fromArray(this.instanceMatrix.array,A*16)}getMorphAt(A,e){const t=e.morphTargetInfluences,n=this.morphTexture.source.data.data,s=t.length+1,o=A*s+1;for(let r=0;r<t.length;r++)t[r]=n[o+r]}raycast(A,e){const t=this.matrixWorld,n=this.count;if(yn.geometry=this.geometry,yn.material=this.material,yn.material!==void 0&&(this.boundingSphere===null&&this.computeBoundingSphere(),Rn.copy(this.boundingSphere),Rn.applyMatrix4(t),A.ray.intersectsSphere(Rn)!==!1))for(let s=0;s<n;s++){this.getMatrixAt(s,Ki),pg.multiplyMatrices(t,Ki),yn.matrixWorld=pg,yn.raycast(A,cs);for(let o=0,r=cs.length;o<r;o++){const a=cs[o];a.instanceId=s,a.object=this,e.push(a)}cs.length=0}}setColorAt(A,e){this.instanceColor===null&&(this.instanceColor=new qs(new Float32Array(this.instanceMatrix.count*3).fill(1),3)),e.toArray(this.instanceColor.array,A*3)}setMatrixAt(A,e){e.toArray(this.instanceMatrix.array,A*16)}setMorphAt(A,e){const t=e.morphTargetInfluences,n=t.length+1;this.morphTexture===null&&(this.morphTexture=new bt(new Float32Array(n*this.count),n,this.count,aa,lt));const s=this.morphTexture.source.data.data;let o=0;for(let g=0;g<t.length;g++)o+=t[g];const r=this.geometry.morphTargetsRelative?1:1-o,a=n*A;s[a]=r,s.set(t,a+1)}updateMorphTargets(){}dispose(){return this.dispatchEvent({type:"dispose"}),this.morphTexture!==null&&(this.morphTexture.dispose(),this.morphTexture=null),this}}const _o=new L,LB=new L,_B=new PA;class Ht{constructor(A=new L(1,0,0),e=0){this.isPlane=!0,this.normal=A,this.constant=e}set(A,e){return this.normal.copy(A),this.constant=e,this}setComponents(A,e,t,n){return this.normal.set(A,e,t),this.constant=n,this}setFromNormalAndCoplanarPoint(A,e){return this.normal.copy(A),this.constant=-e.dot(this.normal),this}setFromCoplanarPoints(A,e,t){const n=_o.subVectors(t,e).cross(LB.subVectors(A,e)).normalize();return this.setFromNormalAndCoplanarPoint(n,A),this}copy(A){return this.normal.copy(A.normal),this.constant=A.constant,this}normalize(){const A=1/this.normal.length();return this.normal.multiplyScalar(A),this.constant*=A,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(A){return this.normal.dot(A)+this.constant}distanceToSphere(A){return this.distanceToPoint(A.center)-A.radius}projectPoint(A,e){return e.copy(A).addScaledVector(this.normal,-this.distanceToPoint(A))}intersectLine(A,e){const t=A.delta(_o),n=this.normal.dot(t);if(n===0)return this.distanceToPoint(A.start)===0?e.copy(A.start):null;const s=-(A.start.dot(this.normal)+this.constant)/n;return s<0||s>1?null:e.copy(A.start).addScaledVector(t,s)}intersectsLine(A){const e=this.distanceToPoint(A.start),t=this.distanceToPoint(A.end);return e<0&&t>0||t<0&&e>0}intersectsBox(A){return A.intersectsPlane(this)}intersectsSphere(A){return A.intersectsPlane(this)}coplanarPoint(A){return A.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(A,e){const t=e||_B.getNormalMatrix(A),n=this.coplanarPoint(_o).applyMatrix4(A),s=this.normal.applyMatrix3(t).normalize();return this.constant=-n.dot(s),this}translate(A){return this.constant-=A.dot(this.normal),this}equals(A){return A.normal.equals(this.normal)&&A.constant===this.constant}clone(){return new this.constructor().copy(this)}}const li=new Dt,hs=new L;class to{constructor(A=new Ht,e=new Ht,t=new Ht,n=new Ht,s=new Ht,o=new Ht){this.planes=[A,e,t,n,s,o]}set(A,e,t,n,s,o){const r=this.planes;return r[0].copy(A),r[1].copy(e),r[2].copy(t),r[3].copy(n),r[4].copy(s),r[5].copy(o),this}copy(A){const e=this.planes;for(let t=0;t<6;t++)e[t].copy(A.planes[t]);return this}setFromProjectionMatrix(A,e=Jt){const t=this.planes,n=A.elements,s=n[0],o=n[1],r=n[2],a=n[3],g=n[4],I=n[5],E=n[6],C=n[7],Q=n[8],h=n[9],l=n[10],B=n[11],c=n[12],R=n[13],p=n[14],d=n[15];if(t[0].setComponents(a-s,C-g,B-Q,d-c).normalize(),t[1].setComponents(a+s,C+g,B+Q,d+c).normalize(),t[2].setComponents(a+o,C+I,B+h,d+R).normalize(),t[3].setComponents(a-o,C-I,B-h,d-R).normalize(),t[4].setComponents(a-r,C-E,B-l,d-p).normalize(),e===Jt)t[5].setComponents(a+r,C+E,B+l,d+p).normalize();else if(e===Ys)t[5].setComponents(r,E,l,p).normalize();else throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: "+e);return this}intersectsObject(A){if(A.boundingSphere!==void 0)A.boundingSphere===null&&A.computeBoundingSphere(),li.copy(A.boundingSphere).applyMatrix4(A.matrixWorld);else{const e=A.geometry;e.boundingSphere===null&&e.computeBoundingSphere(),li.copy(e.boundingSphere).applyMatrix4(A.matrixWorld)}return this.intersectsSphere(li)}intersectsSprite(A){return li.center.set(0,0,0),li.radius=.7071067811865476,li.applyMatrix4(A.matrixWorld),this.intersectsSphere(li)}intersectsSphere(A){const e=this.planes,t=A.center,n=-A.radius;for(let s=0;s<6;s++)if(e[s].distanceToPoint(t)<n)return!1;return!0}intersectsBox(A){const e=this.planes;for(let t=0;t<6;t++){const n=e[t];if(hs.x=n.normal.x>0?A.max.x:A.min.x,hs.y=n.normal.y>0?A.max.y:A.min.y,hs.z=n.normal.z>0?A.max.z:A.min.z,n.distanceToPoint(hs)<0)return!1}return!0}containsPoint(A){const e=this.planes;for(let t=0;t<6;t++)if(e[t].distanceToPoint(A)<0)return!1;return!0}clone(){return new this.constructor().copy(this)}}class la extends ut{constructor(A){super(),this.isLineBasicMaterial=!0,this.type="LineBasicMaterial",this.color=new GA(16777215),this.map=null,this.linewidth=1,this.linecap="round",this.linejoin="round",this.fog=!0,this.setValues(A)}copy(A){return super.copy(A),this.color.copy(A.color),this.map=A.map,this.linewidth=A.linewidth,this.linecap=A.linecap,this.linejoin=A.linejoin,this.fog=A.fog,this}}const Ws=new L,Vs=new L,mg=new UA,wn=new Mi,ls=new Dt,Uo=new L,yg=new L;class da extends Be{constructor(A=new Xe,e=new la){super(),this.isLine=!0,this.type="Line",this.geometry=A,this.material=e,this.updateMorphTargets()}copy(A,e){return super.copy(A,e),this.material=Array.isArray(A.material)?A.material.slice():A.material,this.geometry=A.geometry,this}computeLineDistances(){const A=this.geometry;if(A.index===null){const e=A.attributes.position,t=[0];for(let n=1,s=e.count;n<s;n++)Ws.fromBufferAttribute(e,n-1),Vs.fromBufferAttribute(e,n),t[n]=t[n-1],t[n]+=Ws.distanceTo(Vs);A.setAttribute("lineDistance",new Rt(t,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}raycast(A,e){const t=this.geometry,n=this.matrixWorld,s=A.params.Line.threshold,o=t.drawRange;if(t.boundingSphere===null&&t.computeBoundingSphere(),ls.copy(t.boundingSphere),ls.applyMatrix4(n),ls.radius+=s,A.ray.intersectsSphere(ls)===!1)return;mg.copy(n).invert(),wn.copy(A.ray).applyMatrix4(mg);const r=s/((this.scale.x+this.scale.y+this.scale.z)/3),a=r*r,g=this.isLineSegments?2:1,I=t.index,C=t.attributes.position;if(I!==null){const Q=Math.max(0,o.start),h=Math.min(I.count,o.start+o.count);for(let l=Q,B=h-1;l<B;l+=g){const c=I.getX(l),R=I.getX(l+1),p=ds(this,A,wn,a,c,R);p&&e.push(p)}if(this.isLineLoop){const l=I.getX(h-1),B=I.getX(Q),c=ds(this,A,wn,a,l,B);c&&e.push(c)}}else{const Q=Math.max(0,o.start),h=Math.min(C.count,o.start+o.count);for(let l=Q,B=h-1;l<B;l+=g){const c=ds(this,A,wn,a,l,l+1);c&&e.push(c)}if(this.isLineLoop){const l=ds(this,A,wn,a,h-1,Q);l&&e.push(l)}}}updateMorphTargets(){const e=this.geometry.morphAttributes,t=Object.keys(e);if(t.length>0){const n=e[t[0]];if(n!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let s=0,o=n.length;s<o;s++){const r=n[s].name||String(s);this.morphTargetInfluences.push(0),this.morphTargetDictionary[r]=s}}}}}function ds(i,A,e,t,n,s){const o=i.geometry.attributes.position;if(Ws.fromBufferAttribute(o,n),Vs.fromBufferAttribute(o,s),e.distanceSqToSegment(Ws,Vs,Uo,yg)>t)return;Uo.applyMatrix4(i.matrixWorld);const a=A.ray.origin.distanceTo(Uo);if(!(a<A.near||a>A.far))return{distance:a,point:yg.clone().applyMatrix4(i.matrixWorld),index:n,face:null,faceIndex:null,barycoord:null,object:i}}const Rg=new L,wg=new L;class xE extends da{constructor(A,e){super(A,e),this.isLineSegments=!0,this.type="LineSegments"}computeLineDistances(){const A=this.geometry;if(A.index===null){const e=A.attributes.position,t=[];for(let n=0,s=e.count;n<s;n+=2)Rg.fromBufferAttribute(e,n),wg.fromBufferAttribute(e,n+1),t[n]=n===0?0:t[n-1],t[n+1]=t[n]+Rg.distanceTo(wg);A.setAttribute("lineDistance",new Rt(t,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}}class UB extends da{constructor(A,e){super(A,e),this.isLineLoop=!0,this.type="LineLoop"}}class FE extends ut{constructor(A){super(),this.isPointsMaterial=!0,this.type="PointsMaterial",this.color=new GA(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.fog=!0,this.setValues(A)}copy(A){return super.copy(A),this.color.copy(A.color),this.map=A.map,this.alphaMap=A.alphaMap,this.size=A.size,this.sizeAttenuation=A.sizeAttenuation,this.fog=A.fog,this}}const Sg=new UA,Kr=new Mi,us=new Dt,fs=new L;class GB extends Be{constructor(A=new Xe,e=new FE){super(),this.isPoints=!0,this.type="Points",this.geometry=A,this.material=e,this.updateMorphTargets()}copy(A,e){return super.copy(A,e),this.material=Array.isArray(A.material)?A.material.slice():A.material,this.geometry=A.geometry,this}raycast(A,e){const t=this.geometry,n=this.matrixWorld,s=A.params.Points.threshold,o=t.drawRange;if(t.boundingSphere===null&&t.computeBoundingSphere(),us.copy(t.boundingSphere),us.applyMatrix4(n),us.radius+=s,A.ray.intersectsSphere(us)===!1)return;Sg.copy(n).invert(),Kr.copy(A.ray).applyMatrix4(Sg);const r=s/((this.scale.x+this.scale.y+this.scale.z)/3),a=r*r,g=t.index,E=t.attributes.position;if(g!==null){const C=Math.max(0,o.start),Q=Math.min(g.count,o.start+o.count);for(let h=C,l=Q;h<l;h++){const B=g.getX(h);fs.fromBufferAttribute(E,B),Mg(fs,B,a,n,A,e,this)}}else{const C=Math.max(0,o.start),Q=Math.min(E.count,o.start+o.count);for(let h=C,l=Q;h<l;h++)fs.fromBufferAttribute(E,h),Mg(fs,h,a,n,A,e,this)}}updateMorphTargets(){const e=this.geometry.morphAttributes,t=Object.keys(e);if(t.length>0){const n=e[t[0]];if(n!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let s=0,o=n.length;s<o;s++){const r=n[s].name||String(s);this.morphTargetInfluences.push(0),this.morphTargetDictionary[r]=s}}}}}function Mg(i,A,e,t,n,s,o){const r=Kr.distanceSqToPoint(i);if(r<e){const a=new L;Kr.closestPointToPoint(i,a),a.applyMatrix4(t);const g=n.ray.origin.distanceTo(a);if(g<n.near||g>n.far)return;s.push({distance:g,distanceToRay:Math.sqrt(r),point:a,index:A,face:null,faceIndex:null,barycoord:null,object:o})}}class yi extends Be{constructor(){super(),this.isGroup=!0,this.type="Group"}}class LE extends de{constructor(A,e,t,n,s,o,r,a,g){super(A,e,t,n,s,o,r,a,g),this.isCanvasTexture=!0,this.needsUpdate=!0}}class _E extends de{constructor(A,e,t,n,s,o,r,a,g,I=$i){if(I!==$i&&I!==gn)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");t===void 0&&I===$i&&(t=Oe),t===void 0&&I===gn&&(t=an),super(null,n,s,o,r,a,I,t,g),this.isDepthTexture=!0,this.image={width:A,height:e},this.magFilter=r!==void 0?r:Te,this.minFilter=a!==void 0?a:Te,this.flipY=!1,this.generateMipmaps=!1,this.compareFunction=null}copy(A){return super.copy(A),this.compareFunction=A.compareFunction,this}toJSON(A){const e=super.toJSON(A);return this.compareFunction!==null&&(e.compareFunction=this.compareFunction),e}}class Vn extends Xe{constructor(A=1,e=1,t=1,n=1){super(),this.type="PlaneGeometry",this.parameters={width:A,height:e,widthSegments:t,heightSegments:n};const s=A/2,o=e/2,r=Math.floor(t),a=Math.floor(n),g=r+1,I=a+1,E=A/r,C=e/a,Q=[],h=[],l=[],B=[];for(let c=0;c<I;c++){const R=c*C-o;for(let p=0;p<g;p++){const d=p*E-s;h.push(d,-R,0),l.push(0,0,1),B.push(p/r),B.push(1-c/a)}}for(let c=0;c<a;c++)for(let R=0;R<r;R++){const p=R+g*c,d=R+g*(c+1),w=R+1+g*(c+1),S=R+1+g*c;Q.push(p,d,S),Q.push(d,w,S)}this.setIndex(Q),this.setAttribute("position",new Rt(h,3)),this.setAttribute("normal",new Rt(l,3)),this.setAttribute("uv",new Rt(B,2))}copy(A){return super.copy(A),this.parameters=Object.assign({},A.parameters),this}static fromJSON(A){return new Vn(A.width,A.height,A.widthSegments,A.heightSegments)}}class io extends ut{constructor(A){super(),this.isMeshStandardMaterial=!0,this.type="MeshStandardMaterial",this.defines={STANDARD:""},this.color=new GA(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new GA(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Ea,this.normalScale=new bA(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new pt,this.envMapIntensity=1,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(A)}copy(A){return super.copy(A),this.defines={STANDARD:""},this.color.copy(A.color),this.roughness=A.roughness,this.metalness=A.metalness,this.map=A.map,this.lightMap=A.lightMap,this.lightMapIntensity=A.lightMapIntensity,this.aoMap=A.aoMap,this.aoMapIntensity=A.aoMapIntensity,this.emissive.copy(A.emissive),this.emissiveMap=A.emissiveMap,this.emissiveIntensity=A.emissiveIntensity,this.bumpMap=A.bumpMap,this.bumpScale=A.bumpScale,this.normalMap=A.normalMap,this.normalMapType=A.normalMapType,this.normalScale.copy(A.normalScale),this.displacementMap=A.displacementMap,this.displacementScale=A.displacementScale,this.displacementBias=A.displacementBias,this.roughnessMap=A.roughnessMap,this.metalnessMap=A.metalnessMap,this.alphaMap=A.alphaMap,this.envMap=A.envMap,this.envMapRotation.copy(A.envMapRotation),this.envMapIntensity=A.envMapIntensity,this.wireframe=A.wireframe,this.wireframeLinewidth=A.wireframeLinewidth,this.wireframeLinecap=A.wireframeLinecap,this.wireframeLinejoin=A.wireframeLinejoin,this.flatShading=A.flatShading,this.fog=A.fog,this}}class Mt extends io{constructor(A){super(),this.isMeshPhysicalMaterial=!0,this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.anisotropyRotation=0,this.anisotropyMap=null,this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new bA(1,1),this.clearcoatNormalMap=null,this.ior=1.5,Object.defineProperty(this,"reflectivity",{get:function(){return zA(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(e){this.ior=(1+.4*e)/(1-.4*e)}}),this.iridescenceMap=null,this.iridescenceIOR=1.3,this.iridescenceThicknessRange=[100,400],this.iridescenceThicknessMap=null,this.sheenColor=new GA(0),this.sheenColorMap=null,this.sheenRoughness=1,this.sheenRoughnessMap=null,this.transmissionMap=null,this.thickness=0,this.thicknessMap=null,this.attenuationDistance=1/0,this.attenuationColor=new GA(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularColor=new GA(1,1,1),this.specularColorMap=null,this._anisotropy=0,this._clearcoat=0,this._dispersion=0,this._iridescence=0,this._sheen=0,this._transmission=0,this.setValues(A)}get anisotropy(){return this._anisotropy}set anisotropy(A){this._anisotropy>0!=A>0&&this.version++,this._anisotropy=A}get clearcoat(){return this._clearcoat}set clearcoat(A){this._clearcoat>0!=A>0&&this.version++,this._clearcoat=A}get iridescence(){return this._iridescence}set iridescence(A){this._iridescence>0!=A>0&&this.version++,this._iridescence=A}get dispersion(){return this._dispersion}set dispersion(A){this._dispersion>0!=A>0&&this.version++,this._dispersion=A}get sheen(){return this._sheen}set sheen(A){this._sheen>0!=A>0&&this.version++,this._sheen=A}get transmission(){return this._transmission}set transmission(A){this._transmission>0!=A>0&&this.version++,this._transmission=A}copy(A){return super.copy(A),this.defines={STANDARD:"",PHYSICAL:""},this.anisotropy=A.anisotropy,this.anisotropyRotation=A.anisotropyRotation,this.anisotropyMap=A.anisotropyMap,this.clearcoat=A.clearcoat,this.clearcoatMap=A.clearcoatMap,this.clearcoatRoughness=A.clearcoatRoughness,this.clearcoatRoughnessMap=A.clearcoatRoughnessMap,this.clearcoatNormalMap=A.clearcoatNormalMap,this.clearcoatNormalScale.copy(A.clearcoatNormalScale),this.dispersion=A.dispersion,this.ior=A.ior,this.iridescence=A.iridescence,this.iridescenceMap=A.iridescenceMap,this.iridescenceIOR=A.iridescenceIOR,this.iridescenceThicknessRange=[...A.iridescenceThicknessRange],this.iridescenceThicknessMap=A.iridescenceThicknessMap,this.sheen=A.sheen,this.sheenColor.copy(A.sheenColor),this.sheenColorMap=A.sheenColorMap,this.sheenRoughness=A.sheenRoughness,this.sheenRoughnessMap=A.sheenRoughnessMap,this.transmission=A.transmission,this.transmissionMap=A.transmissionMap,this.thickness=A.thickness,this.thicknessMap=A.thicknessMap,this.attenuationDistance=A.attenuationDistance,this.attenuationColor.copy(A.attenuationColor),this.specularIntensity=A.specularIntensity,this.specularIntensityMap=A.specularIntensityMap,this.specularColor.copy(A.specularColor),this.specularColorMap=A.specularColorMap,this}}class vB extends ut{constructor(A){super(),this.isMeshNormalMaterial=!0,this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Ea,this.normalScale=new bA(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.flatShading=!1,this.setValues(A)}copy(A){return super.copy(A),this.bumpMap=A.bumpMap,this.bumpScale=A.bumpScale,this.normalMap=A.normalMap,this.normalMapType=A.normalMapType,this.normalScale.copy(A.normalScale),this.displacementMap=A.displacementMap,this.displacementScale=A.displacementScale,this.displacementBias=A.displacementBias,this.wireframe=A.wireframe,this.wireframeLinewidth=A.wireframeLinewidth,this.flatShading=A.flatShading,this}}class TB extends ut{constructor(A){super(),this.isMeshDepthMaterial=!0,this.type="MeshDepthMaterial",this.depthPacking=SQ,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.setValues(A)}copy(A){return super.copy(A),this.depthPacking=A.depthPacking,this.map=A.map,this.alphaMap=A.alphaMap,this.displacementMap=A.displacementMap,this.displacementScale=A.displacementScale,this.displacementBias=A.displacementBias,this.wireframe=A.wireframe,this.wireframeLinewidth=A.wireframeLinewidth,this}}class bB extends ut{constructor(A){super(),this.isMeshDistanceMaterial=!0,this.type="MeshDistanceMaterial",this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.setValues(A)}copy(A){return super.copy(A),this.map=A.map,this.alphaMap=A.alphaMap,this.displacementMap=A.displacementMap,this.displacementScale=A.displacementScale,this.displacementBias=A.displacementBias,this}}function ps(i,A,e){return!i||!e&&i.constructor===A?i:typeof A.BYTES_PER_ELEMENT=="number"?new A(i):Array.prototype.slice.call(i)}function kB(i){return ArrayBuffer.isView(i)&&!(i instanceof DataView)}function HB(i){function A(n,s){return i[n]-i[s]}const e=i.length,t=new Array(e);for(let n=0;n!==e;++n)t[n]=n;return t.sort(A),t}function Ng(i,A,e){const t=i.length,n=new i.constructor(t);for(let s=0,o=0;o!==t;++s){const r=e[s]*A;for(let a=0;a!==A;++a)n[o++]=i[r+a]}return n}function UE(i,A,e,t){let n=1,s=i[0];for(;s!==void 0&&s[t]===void 0;)s=i[n++];if(s===void 0)return;let o=s[t];if(o!==void 0)if(Array.isArray(o))do o=s[t],o!==void 0&&(A.push(s.time),e.push.apply(e,o)),s=i[n++];while(s!==void 0);else if(o.toArray!==void 0)do o=s[t],o!==void 0&&(A.push(s.time),o.toArray(e,e.length)),s=i[n++];while(s!==void 0);else do o=s[t],o!==void 0&&(A.push(s.time),e.push(o)),s=i[n++];while(s!==void 0)}class zn{constructor(A,e,t,n){this.parameterPositions=A,this._cachedIndex=0,this.resultBuffer=n!==void 0?n:new e.constructor(t),this.sampleValues=e,this.valueSize=t,this.settings=null,this.DefaultSettings_={}}evaluate(A){const e=this.parameterPositions;let t=this._cachedIndex,n=e[t],s=e[t-1];t:{A:{let o;e:{i:if(!(A<n)){for(let r=t+2;;){if(n===void 0){if(A<s)break i;return t=e.length,this._cachedIndex=t,this.copySampleValue_(t-1)}if(t===r)break;if(s=n,n=e[++t],A<n)break A}o=e.length;break e}if(!(A>=s)){const r=e[1];A<r&&(t=2,s=r);for(let a=t-2;;){if(s===void 0)return this._cachedIndex=0,this.copySampleValue_(0);if(t===a)break;if(n=s,s=e[--t-1],A>=s)break A}o=t,t=0;break e}break t}for(;t<o;){const r=t+o>>>1;A<e[r]?o=r:t=r+1}if(n=e[t],s=e[t-1],s===void 0)return this._cachedIndex=0,this.copySampleValue_(0);if(n===void 0)return t=e.length,this._cachedIndex=t,this.copySampleValue_(t-1)}this._cachedIndex=t,this.intervalChanged_(t,s,n)}return this.interpolate_(t,s,A,n)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(A){const e=this.resultBuffer,t=this.sampleValues,n=this.valueSize,s=A*n;for(let o=0;o!==n;++o)e[o]=t[s+o];return e}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}}class PB extends zn{constructor(A,e,t,n){super(A,e,t,n),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:qa,endingEnd:qa}}intervalChanged_(A,e,t){const n=this.parameterPositions;let s=A-2,o=A+1,r=n[s],a=n[o];if(r===void 0)switch(this.getSettings_().endingStart){case Wa:s=A,r=2*e-t;break;case Va:s=n.length-2,r=e+n[s]-n[s+1];break;default:s=A,r=t}if(a===void 0)switch(this.getSettings_().endingEnd){case Wa:o=A,a=2*t-e;break;case Va:o=1,a=t+n[1]-n[0];break;default:o=A-1,a=e}const g=(t-e)*.5,I=this.valueSize;this._weightPrev=g/(e-r),this._weightNext=g/(a-t),this._offsetPrev=s*I,this._offsetNext=o*I}interpolate_(A,e,t,n){const s=this.resultBuffer,o=this.sampleValues,r=this.valueSize,a=A*r,g=a-r,I=this._offsetPrev,E=this._offsetNext,C=this._weightPrev,Q=this._weightNext,h=(t-e)/(n-e),l=h*h,B=l*h,c=-C*B+2*C*l-C*h,R=(1+C)*B+(-1.5-2*C)*l+(-.5+C)*h+1,p=(-1-Q)*B+(1.5+Q)*l+.5*h,d=Q*B-Q*l;for(let w=0;w!==r;++w)s[w]=c*o[I+w]+R*o[g+w]+p*o[a+w]+d*o[E+w];return s}}class OB extends zn{constructor(A,e,t,n){super(A,e,t,n)}interpolate_(A,e,t,n){const s=this.resultBuffer,o=this.sampleValues,r=this.valueSize,a=A*r,g=a-r,I=(t-e)/(n-e),E=1-I;for(let C=0;C!==r;++C)s[C]=o[g+C]*E+o[a+C]*I;return s}}class JB extends zn{constructor(A,e,t,n){super(A,e,t,n)}interpolate_(A){return this.copySampleValue_(A-1)}}class Nt{constructor(A,e,t,n){if(A===void 0)throw new Error("THREE.KeyframeTrack: track name is undefined");if(e===void 0||e.length===0)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+A);this.name=A,this.times=ps(e,this.TimeBufferType),this.values=ps(t,this.ValueBufferType),this.setInterpolation(n||this.DefaultInterpolation)}static toJSON(A){const e=A.constructor;let t;if(e.toJSON!==this.toJSON)t=e.toJSON(A);else{t={name:A.name,times:ps(A.times,Array),values:ps(A.values,Array)};const n=A.getInterpolation();n!==A.DefaultInterpolation&&(t.interpolation=n)}return t.type=A.ValueTypeName,t}InterpolantFactoryMethodDiscrete(A){return new JB(this.times,this.values,this.getValueSize(),A)}InterpolantFactoryMethodLinear(A){return new OB(this.times,this.values,this.getValueSize(),A)}InterpolantFactoryMethodSmooth(A){return new PB(this.times,this.values,this.getValueSize(),A)}setInterpolation(A){let e;switch(A){case Pn:e=this.InterpolantFactoryMethodDiscrete;break;case On:e=this.InterpolantFactoryMethodLinear;break;case Io:e=this.InterpolantFactoryMethodSmooth;break}if(e===void 0){const t="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(this.createInterpolant===void 0)if(A!==this.DefaultInterpolation)this.setInterpolation(this.DefaultInterpolation);else throw new Error(t);return console.warn("THREE.KeyframeTrack:",t),this}return this.createInterpolant=e,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return Pn;case this.InterpolantFactoryMethodLinear:return On;case this.InterpolantFactoryMethodSmooth:return Io}}getValueSize(){return this.values.length/this.times.length}shift(A){if(A!==0){const e=this.times;for(let t=0,n=e.length;t!==n;++t)e[t]+=A}return this}scale(A){if(A!==1){const e=this.times;for(let t=0,n=e.length;t!==n;++t)e[t]*=A}return this}trim(A,e){const t=this.times,n=t.length;let s=0,o=n-1;for(;s!==n&&t[s]<A;)++s;for(;o!==-1&&t[o]>e;)--o;if(++o,s!==0||o!==n){s>=o&&(o=Math.max(o,1),s=o-1);const r=this.getValueSize();this.times=t.slice(s,o),this.values=this.values.slice(s*r,o*r)}return this}validate(){let A=!0;const e=this.getValueSize();e-Math.floor(e)!==0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),A=!1);const t=this.times,n=this.values,s=t.length;s===0&&(console.error("THREE.KeyframeTrack: Track is empty.",this),A=!1);let o=null;for(let r=0;r!==s;r++){const a=t[r];if(typeof a=="number"&&isNaN(a)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,r,a),A=!1;break}if(o!==null&&o>a){console.error("THREE.KeyframeTrack: Out of order keys.",this,r,a,o),A=!1;break}o=a}if(n!==void 0&&kB(n))for(let r=0,a=n.length;r!==a;++r){const g=n[r];if(isNaN(g)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,r,g),A=!1;break}}return A}optimize(){const A=this.times.slice(),e=this.values.slice(),t=this.getValueSize(),n=this.getInterpolation()===Io,s=A.length-1;let o=1;for(let r=1;r<s;++r){let a=!1;const g=A[r],I=A[r+1];if(g!==I&&(r!==1||g!==A[0]))if(n)a=!0;else{const E=r*t,C=E-t,Q=E+t;for(let h=0;h!==t;++h){const l=e[E+h];if(l!==e[C+h]||l!==e[Q+h]){a=!0;break}}}if(a){if(r!==o){A[o]=A[r];const E=r*t,C=o*t;for(let Q=0;Q!==t;++Q)e[C+Q]=e[E+Q]}++o}}if(s>0){A[o]=A[s];for(let r=s*t,a=o*t,g=0;g!==t;++g)e[a+g]=e[r+g];++o}return o!==A.length?(this.times=A.slice(0,o),this.values=e.slice(0,o*t)):(this.times=A,this.values=e),this}clone(){const A=this.times.slice(),e=this.values.slice(),t=this.constructor,n=new t(this.name,A,e);return n.createInterpolant=this.createInterpolant,n}}Nt.prototype.TimeBufferType=Float32Array;Nt.prototype.ValueBufferType=Float32Array;Nt.prototype.DefaultInterpolation=On;class cn extends Nt{constructor(A,e,t){super(A,e,t)}}cn.prototype.ValueTypeName="bool";cn.prototype.ValueBufferType=Array;cn.prototype.DefaultInterpolation=Pn;cn.prototype.InterpolantFactoryMethodLinear=void 0;cn.prototype.InterpolantFactoryMethodSmooth=void 0;class GE extends Nt{}GE.prototype.ValueTypeName="color";class Cn extends Nt{}Cn.prototype.ValueTypeName="number";class KB extends zn{constructor(A,e,t,n){super(A,e,t,n)}interpolate_(A,e,t,n){const s=this.resultBuffer,o=this.sampleValues,r=this.valueSize,a=(t-e)/(n-e);let g=A*r;for(let I=g+r;g!==I;g+=4)Ii.slerpFlat(s,0,o,g-r,o,g,a);return s}}class Qn extends Nt{InterpolantFactoryMethodLinear(A){return new KB(this.times,this.values,this.getValueSize(),A)}}Qn.prototype.ValueTypeName="quaternion";Qn.prototype.InterpolantFactoryMethodSmooth=void 0;class hn extends Nt{constructor(A,e,t){super(A,e,t)}}hn.prototype.ValueTypeName="string";hn.prototype.ValueBufferType=Array;hn.prototype.DefaultInterpolation=Pn;hn.prototype.InterpolantFactoryMethodLinear=void 0;hn.prototype.InterpolantFactoryMethodSmooth=void 0;class Bn extends Nt{}Bn.prototype.ValueTypeName="vector";class YB{constructor(A="",e=-1,t=[],n=RQ){this.name=A,this.tracks=t,this.duration=e,this.blendMode=n,this.uuid=dt(),this.duration<0&&this.resetDuration()}static parse(A){const e=[],t=A.tracks,n=1/(A.fps||1);for(let o=0,r=t.length;o!==r;++o)e.push(WB(t[o]).scale(n));const s=new this(A.name,A.duration,e,A.blendMode);return s.uuid=A.uuid,s}static toJSON(A){const e=[],t=A.tracks,n={name:A.name,duration:A.duration,tracks:e,uuid:A.uuid,blendMode:A.blendMode};for(let s=0,o=t.length;s!==o;++s)e.push(Nt.toJSON(t[s]));return n}static CreateFromMorphTargetSequence(A,e,t,n){const s=e.length,o=[];for(let r=0;r<s;r++){let a=[],g=[];a.push((r+s-1)%s,r,(r+1)%s),g.push(0,1,0);const I=HB(a);a=Ng(a,1,I),g=Ng(g,1,I),!n&&a[0]===0&&(a.push(s),g.push(g[0])),o.push(new Cn(".morphTargetInfluences["+e[r].name+"]",a,g).scale(1/t))}return new this(A,-1,o)}static findByName(A,e){let t=A;if(!Array.isArray(A)){const n=A;t=n.geometry&&n.geometry.animations||n.animations}for(let n=0;n<t.length;n++)if(t[n].name===e)return t[n];return null}static CreateClipsFromMorphTargetSequences(A,e,t){const n={},s=/^([\w-]*?)([\d]+)$/;for(let r=0,a=A.length;r<a;r++){const g=A[r],I=g.name.match(s);if(I&&I.length>1){const E=I[1];let C=n[E];C||(n[E]=C=[]),C.push(g)}}const o=[];for(const r in n)o.push(this.CreateFromMorphTargetSequence(r,n[r],e,t));return o}static parseAnimation(A,e){if(!A)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const t=function(E,C,Q,h,l){if(Q.length!==0){const B=[],c=[];UE(Q,B,c,h),B.length!==0&&l.push(new E(C,B,c))}},n=[],s=A.name||"default",o=A.fps||30,r=A.blendMode;let a=A.length||-1;const g=A.hierarchy||[];for(let E=0;E<g.length;E++){const C=g[E].keys;if(!(!C||C.length===0))if(C[0].morphTargets){const Q={};let h;for(h=0;h<C.length;h++)if(C[h].morphTargets)for(let l=0;l<C[h].morphTargets.length;l++)Q[C[h].morphTargets[l]]=-1;for(const l in Q){const B=[],c=[];for(let R=0;R!==C[h].morphTargets.length;++R){const p=C[h];B.push(p.time),c.push(p.morphTarget===l?1:0)}n.push(new Cn(".morphTargetInfluence["+l+"]",B,c))}a=Q.length*o}else{const Q=".bones["+e[E].name+"]";t(Bn,Q+".position",C,"pos",n),t(Qn,Q+".quaternion",C,"rot",n),t(Bn,Q+".scale",C,"scl",n)}}return n.length===0?null:new this(s,a,n,r)}resetDuration(){const A=this.tracks;let e=0;for(let t=0,n=A.length;t!==n;++t){const s=this.tracks[t];e=Math.max(e,s.times[s.times.length-1])}return this.duration=e,this}trim(){for(let A=0;A<this.tracks.length;A++)this.tracks[A].trim(0,this.duration);return this}validate(){let A=!0;for(let e=0;e<this.tracks.length;e++)A=A&&this.tracks[e].validate();return A}optimize(){for(let A=0;A<this.tracks.length;A++)this.tracks[A].optimize();return this}clone(){const A=[];for(let e=0;e<this.tracks.length;e++)A.push(this.tracks[e].clone());return new this.constructor(this.name,this.duration,A,this.blendMode)}toJSON(){return this.constructor.toJSON(this)}}function qB(i){switch(i.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return Cn;case"vector":case"vector2":case"vector3":case"vector4":return Bn;case"color":return GE;case"quaternion":return Qn;case"bool":case"boolean":return cn;case"string":return hn}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+i)}function WB(i){if(i.type===void 0)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const A=qB(i.type);if(i.times===void 0){const e=[],t=[];UE(i.keys,e,t,"value"),i.times=e,i.values=t}return A.parse!==void 0?A.parse(i):new A(i.name,i.times,i.values,i.interpolation)}const si={enabled:!1,files:{},add:function(i,A){this.enabled!==!1&&(this.files[i]=A)},get:function(i){if(this.enabled!==!1)return this.files[i]},remove:function(i){delete this.files[i]},clear:function(){this.files={}}};class vE{constructor(A,e,t){const n=this;let s=!1,o=0,r=0,a;const g=[];this.onStart=void 0,this.onLoad=A,this.onProgress=e,this.onError=t,this.itemStart=function(I){r++,s===!1&&n.onStart!==void 0&&n.onStart(I,o,r),s=!0},this.itemEnd=function(I){o++,n.onProgress!==void 0&&n.onProgress(I,o,r),o===r&&(s=!1,n.onLoad!==void 0&&n.onLoad())},this.itemError=function(I){n.onError!==void 0&&n.onError(I)},this.resolveURL=function(I){return a?a(I):I},this.setURLModifier=function(I){return a=I,this},this.addHandler=function(I,E){return g.push(I,E),this},this.removeHandler=function(I){const E=g.indexOf(I);return E!==-1&&g.splice(E,2),this},this.getHandler=function(I){for(let E=0,C=g.length;E<C;E+=2){const Q=g[E],h=g[E+1];if(Q.global&&(Q.lastIndex=0),Q.test(I))return h}return null}}}const VB=new vE;class Ei{constructor(A){this.manager=A!==void 0?A:VB,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(A,e){const t=this;return new Promise(function(n,s){t.load(A,n,e,s)})}parse(){}setCrossOrigin(A){return this.crossOrigin=A,this}setWithCredentials(A){return this.withCredentials=A,this}setPath(A){return this.path=A,this}setResourcePath(A){return this.resourcePath=A,this}setRequestHeader(A){return this.requestHeader=A,this}}Ei.DEFAULT_MATERIAL_NAME="__DEFAULT";const vt={};class zB extends Error{constructor(A,e){super(A),this.response=e}}class TE extends Ei{constructor(A){super(A)}load(A,e,t,n){A===void 0&&(A=""),this.path!==void 0&&(A=this.path+A),A=this.manager.resolveURL(A);const s=si.get(A);if(s!==void 0)return this.manager.itemStart(A),setTimeout(()=>{e&&e(s),this.manager.itemEnd(A)},0),s;if(vt[A]!==void 0){vt[A].push({onLoad:e,onProgress:t,onError:n});return}vt[A]=[],vt[A].push({onLoad:e,onProgress:t,onError:n});const o=new Request(A,{headers:new Headers(this.requestHeader),credentials:this.withCredentials?"include":"same-origin"}),r=this.mimeType,a=this.responseType;fetch(o).then(g=>{if(g.status===200||g.status===0){if(g.status===0&&console.warn("THREE.FileLoader: HTTP Status 0 received."),typeof ReadableStream>"u"||g.body===void 0||g.body.getReader===void 0)return g;const I=vt[A],E=g.body.getReader(),C=g.headers.get("X-File-Size")||g.headers.get("Content-Length"),Q=C?parseInt(C):0,h=Q!==0;let l=0;const B=new ReadableStream({start(c){R();function R(){E.read().then(({done:p,value:d})=>{if(p)c.close();else{l+=d.byteLength;const w=new ProgressEvent("progress",{lengthComputable:h,loaded:l,total:Q});for(let S=0,F=I.length;S<F;S++){const N=I[S];N.onProgress&&N.onProgress(w)}c.enqueue(d),R()}},p=>{c.error(p)})}}});return new Response(B)}else throw new zB(`fetch for "${g.url}" responded with ${g.status}: ${g.statusText}`,g)}).then(g=>{switch(a){case"arraybuffer":return g.arrayBuffer();case"blob":return g.blob();case"document":return g.text().then(I=>new DOMParser().parseFromString(I,r));case"json":return g.json();default:if(r===void 0)return g.text();{const E=/charset="?([^;"\s]*)"?/i.exec(r),C=E&&E[1]?E[1].toLowerCase():void 0,Q=new TextDecoder(C);return g.arrayBuffer().then(h=>Q.decode(h))}}}).then(g=>{si.add(A,g);const I=vt[A];delete vt[A];for(let E=0,C=I.length;E<C;E++){const Q=I[E];Q.onLoad&&Q.onLoad(g)}}).catch(g=>{const I=vt[A];if(I===void 0)throw this.manager.itemError(A),g;delete vt[A];for(let E=0,C=I.length;E<C;E++){const Q=I[E];Q.onError&&Q.onError(g)}this.manager.itemError(A)}).finally(()=>{this.manager.itemEnd(A)}),this.manager.itemStart(A)}setResponseType(A){return this.responseType=A,this}setMimeType(A){return this.mimeType=A,this}}class bE extends Ei{constructor(A){super(A)}load(A,e,t,n){this.path!==void 0&&(A=this.path+A),A=this.manager.resolveURL(A);const s=this,o=si.get(A);if(o!==void 0)return s.manager.itemStart(A),setTimeout(function(){e&&e(o),s.manager.itemEnd(A)},0),o;const r=Jn("img");function a(){I(),si.add(A,this),e&&e(this),s.manager.itemEnd(A)}function g(E){I(),n&&n(E),s.manager.itemError(A),s.manager.itemEnd(A)}function I(){r.removeEventListener("load",a,!1),r.removeEventListener("error",g,!1)}return r.addEventListener("load",a,!1),r.addEventListener("error",g,!1),A.slice(0,5)!=="data:"&&this.crossOrigin!==void 0&&(r.crossOrigin=this.crossOrigin),s.manager.itemStart(A),r.src=A,r}}class XB extends Ei{constructor(A){super(A)}load(A,e,t,n){const s=new de,o=new bE(this.manager);return o.setCrossOrigin(this.crossOrigin),o.setPath(this.path),o.load(A,function(r){s.image=r,s.needsUpdate=!0,e!==void 0&&e(s)},t,n),s}}class ua extends Be{constructor(A,e=1){super(),this.isLight=!0,this.type="Light",this.color=new GA(A),this.intensity=e}dispose(){}copy(A,e){return super.copy(A,e),this.color.copy(A.color),this.intensity=A.intensity,this}toJSON(A){const e=super.toJSON(A);return e.object.color=this.color.getHex(),e.object.intensity=this.intensity,this.groundColor!==void 0&&(e.object.groundColor=this.groundColor.getHex()),this.distance!==void 0&&(e.object.distance=this.distance),this.angle!==void 0&&(e.object.angle=this.angle),this.decay!==void 0&&(e.object.decay=this.decay),this.penumbra!==void 0&&(e.object.penumbra=this.penumbra),this.shadow!==void 0&&(e.object.shadow=this.shadow.toJSON()),this.target!==void 0&&(e.object.target=this.target.uuid),e}}const Go=new UA,xg=new L,Fg=new L;class fa{constructor(A){this.camera=A,this.intensity=1,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new bA(512,512),this.map=null,this.mapPass=null,this.matrix=new UA,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new to,this._frameExtents=new bA(1,1),this._viewportCount=1,this._viewports=[new YA(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(A){const e=this.camera,t=this.matrix;xg.setFromMatrixPosition(A.matrixWorld),e.position.copy(xg),Fg.setFromMatrixPosition(A.target.matrixWorld),e.lookAt(Fg),e.updateMatrixWorld(),Go.multiplyMatrices(e.projectionMatrix,e.matrixWorldInverse),this._frustum.setFromProjectionMatrix(Go),t.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),t.multiply(Go)}getViewport(A){return this._viewports[A]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(A){return this.camera=A.camera.clone(),this.intensity=A.intensity,this.bias=A.bias,this.radius=A.radius,this.mapSize.copy(A.mapSize),this}clone(){return new this.constructor().copy(this)}toJSON(){const A={};return this.intensity!==1&&(A.intensity=this.intensity),this.bias!==0&&(A.bias=this.bias),this.normalBias!==0&&(A.normalBias=this.normalBias),this.radius!==1&&(A.radius=this.radius),(this.mapSize.x!==512||this.mapSize.y!==512)&&(A.mapSize=this.mapSize.toArray()),A.camera=this.camera.toJSON(!1).object,delete A.camera.matrix,A}}class ZB extends fa{constructor(){super(new Le(50,1,.5,500)),this.isSpotLightShadow=!0,this.focus=1}updateMatrices(A){const e=this.camera,t=In*2*A.angle*this.focus,n=this.mapSize.width/this.mapSize.height,s=A.distance||e.far;(t!==e.fov||n!==e.aspect||s!==e.far)&&(e.fov=t,e.aspect=n,e.far=s,e.updateProjectionMatrix()),super.updateMatrices(A)}copy(A){return super.copy(A),this.focus=A.focus,this}}class jB extends ua{constructor(A,e,t=0,n=Math.PI/3,s=0,o=2){super(A,e),this.isSpotLight=!0,this.type="SpotLight",this.position.copy(Be.DEFAULT_UP),this.updateMatrix(),this.target=new Be,this.distance=t,this.angle=n,this.penumbra=s,this.decay=o,this.map=null,this.shadow=new ZB}get power(){return this.intensity*Math.PI}set power(A){this.intensity=A/Math.PI}dispose(){this.shadow.dispose()}copy(A,e){return super.copy(A,e),this.distance=A.distance,this.angle=A.angle,this.penumbra=A.penumbra,this.decay=A.decay,this.target=A.target.clone(),this.shadow=A.shadow.clone(),this}}const Lg=new UA,Sn=new L,vo=new L;class $B extends fa{constructor(){super(new Le(90,1,.5,500)),this.isPointLightShadow=!0,this._frameExtents=new bA(4,2),this._viewportCount=6,this._viewports=[new YA(2,1,1,1),new YA(0,1,1,1),new YA(3,1,1,1),new YA(1,1,1,1),new YA(3,0,1,1),new YA(1,0,1,1)],this._cubeDirections=[new L(1,0,0),new L(-1,0,0),new L(0,0,1),new L(0,0,-1),new L(0,1,0),new L(0,-1,0)],this._cubeUps=[new L(0,1,0),new L(0,1,0),new L(0,1,0),new L(0,1,0),new L(0,0,1),new L(0,0,-1)]}updateMatrices(A,e=0){const t=this.camera,n=this.matrix,s=A.distance||t.far;s!==t.far&&(t.far=s,t.updateProjectionMatrix()),Sn.setFromMatrixPosition(A.matrixWorld),t.position.copy(Sn),vo.copy(t.position),vo.add(this._cubeDirections[e]),t.up.copy(this._cubeUps[e]),t.lookAt(vo),t.updateMatrixWorld(),n.makeTranslation(-Sn.x,-Sn.y,-Sn.z),Lg.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse),this._frustum.setFromProjectionMatrix(Lg)}}class Ac extends ua{constructor(A,e,t=0,n=2){super(A,e),this.isPointLight=!0,this.type="PointLight",this.distance=t,this.decay=n,this.shadow=new $B}get power(){return this.intensity*4*Math.PI}set power(A){this.intensity=A/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(A,e){return super.copy(A,e),this.distance=A.distance,this.decay=A.decay,this.shadow=A.shadow.clone(),this}}class pa extends SE{constructor(A=-1,e=1,t=1,n=-1,s=.1,o=2e3){super(),this.isOrthographicCamera=!0,this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=A,this.right=e,this.top=t,this.bottom=n,this.near=s,this.far=o,this.updateProjectionMatrix()}copy(A,e){return super.copy(A,e),this.left=A.left,this.right=A.right,this.top=A.top,this.bottom=A.bottom,this.near=A.near,this.far=A.far,this.zoom=A.zoom,this.view=A.view===null?null:Object.assign({},A.view),this}setViewOffset(A,e,t,n,s,o){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=A,this.view.fullHeight=e,this.view.offsetX=t,this.view.offsetY=n,this.view.width=s,this.view.height=o,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const A=(this.right-this.left)/(2*this.zoom),e=(this.top-this.bottom)/(2*this.zoom),t=(this.right+this.left)/2,n=(this.top+this.bottom)/2;let s=t-A,o=t+A,r=n+e,a=n-e;if(this.view!==null&&this.view.enabled){const g=(this.right-this.left)/this.view.fullWidth/this.zoom,I=(this.top-this.bottom)/this.view.fullHeight/this.zoom;s+=g*this.view.offsetX,o=s+g*this.view.width,r-=I*this.view.offsetY,a=r-I*this.view.height}this.projectionMatrix.makeOrthographic(s,o,r,a,this.near,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(A){const e=super.toJSON(A);return e.object.zoom=this.zoom,e.object.left=this.left,e.object.right=this.right,e.object.top=this.top,e.object.bottom=this.bottom,e.object.near=this.near,e.object.far=this.far,this.view!==null&&(e.object.view=Object.assign({},this.view)),e}}class ec extends fa{constructor(){super(new pa(-5,5,5,-5,.5,500)),this.isDirectionalLightShadow=!0}}class tc extends ua{constructor(A,e){super(A,e),this.isDirectionalLight=!0,this.type="DirectionalLight",this.position.copy(Be.DEFAULT_UP),this.updateMatrix(),this.target=new Be,this.shadow=new ec}dispose(){this.shadow.dispose()}copy(A){return super.copy(A),this.target=A.target.clone(),this.shadow=A.shadow.clone(),this}}class Tn{static decodeText(A){if(console.warn("THREE.LoaderUtils: decodeText() has been deprecated with r165 and will be removed with r175. Use TextDecoder instead."),typeof TextDecoder<"u")return new TextDecoder().decode(A);let e="";for(let t=0,n=A.length;t<n;t++)e+=String.fromCharCode(A[t]);try{return decodeURIComponent(escape(e))}catch{return e}}static extractUrlBase(A){const e=A.lastIndexOf("/");return e===-1?"./":A.slice(0,e+1)}static resolveURL(A,e){return typeof A!="string"||A===""?"":(/^https?:\/\//i.test(e)&&/^\//.test(A)&&(e=e.replace(/(^https?:\/\/[^\/]+).*/i,"$1")),/^(https?:)?\/\//i.test(A)||/^data:.*,.*$/i.test(A)||/^blob:.*$/i.test(A)?A:e+A)}}class Yr extends Xe{constructor(){super(),this.isInstancedBufferGeometry=!0,this.type="InstancedBufferGeometry",this.instanceCount=1/0}copy(A){return super.copy(A),this.instanceCount=A.instanceCount,this}toJSON(){const A=super.toJSON();return A.instanceCount=this.instanceCount,A.isInstancedBufferGeometry=!0,A}}class ic extends Ei{constructor(A){super(A),this.isImageBitmapLoader=!0,typeof createImageBitmap>"u"&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),typeof fetch>"u"&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),this.options={premultiplyAlpha:"none"}}setOptions(A){return this.options=A,this}load(A,e,t,n){A===void 0&&(A=""),this.path!==void 0&&(A=this.path+A),A=this.manager.resolveURL(A);const s=this,o=si.get(A);if(o!==void 0){if(s.manager.itemStart(A),o.then){o.then(g=>{e&&e(g),s.manager.itemEnd(A)}).catch(g=>{n&&n(g)});return}return setTimeout(function(){e&&e(o),s.manager.itemEnd(A)},0),o}const r={};r.credentials=this.crossOrigin==="anonymous"?"same-origin":"include",r.headers=this.requestHeader;const a=fetch(A,r).then(function(g){return g.blob()}).then(function(g){return createImageBitmap(g,Object.assign(s.options,{colorSpaceConversion:"none"}))}).then(function(g){return si.add(A,g),e&&e(g),s.manager.itemEnd(A),g}).catch(function(g){n&&n(g),si.remove(A),s.manager.itemError(A),s.manager.itemEnd(A)});si.add(A,a),s.manager.itemStart(A)}}class nc extends Le{constructor(A=[]){super(),this.isArrayCamera=!0,this.cameras=A}}class sc{constructor(A=!0){this.autoStart=A,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}start(){this.startTime=_g(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0}stop(){this.getElapsedTime(),this.running=!1,this.autoStart=!1}getElapsedTime(){return this.getDelta(),this.elapsedTime}getDelta(){let A=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){const e=_g();A=(e-this.oldTime)/1e3,this.oldTime=e,this.elapsedTime+=A}return A}}function _g(){return performance.now()}const Da="\\[\\]\\.:\\/",oc=new RegExp("["+Da+"]","g"),ma="[^"+Da+"]",rc="[^"+Da.replace("\\.","")+"]",ac=/((?:WC+[\/:])*)/.source.replace("WC",ma),gc=/(WCOD+)?/.source.replace("WCOD",rc),Ic=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",ma),Ec=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",ma),Cc=new RegExp("^"+ac+gc+Ic+Ec+"$"),Qc=["material","materials","bones","map"];class Bc{constructor(A,e,t){const n=t||ae.parseTrackName(e);this._targetGroup=A,this._bindings=A.subscribe_(e,n)}getValue(A,e){this.bind();const t=this._targetGroup.nCachedObjects_,n=this._bindings[t];n!==void 0&&n.getValue(A,e)}setValue(A,e){const t=this._bindings;for(let n=this._targetGroup.nCachedObjects_,s=t.length;n!==s;++n)t[n].setValue(A,e)}bind(){const A=this._bindings;for(let e=this._targetGroup.nCachedObjects_,t=A.length;e!==t;++e)A[e].bind()}unbind(){const A=this._bindings;for(let e=this._targetGroup.nCachedObjects_,t=A.length;e!==t;++e)A[e].unbind()}}class ae{constructor(A,e,t){this.path=e,this.parsedPath=t||ae.parseTrackName(e),this.node=ae.findNode(A,this.parsedPath.nodeName),this.rootNode=A,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(A,e,t){return A&&A.isAnimationObjectGroup?new ae.Composite(A,e,t):new ae(A,e,t)}static sanitizeNodeName(A){return A.replace(/\s/g,"_").replace(oc,"")}static parseTrackName(A){const e=Cc.exec(A);if(e===null)throw new Error("PropertyBinding: Cannot parse trackName: "+A);const t={nodeName:e[2],objectName:e[3],objectIndex:e[4],propertyName:e[5],propertyIndex:e[6]},n=t.nodeName&&t.nodeName.lastIndexOf(".");if(n!==void 0&&n!==-1){const s=t.nodeName.substring(n+1);Qc.indexOf(s)!==-1&&(t.nodeName=t.nodeName.substring(0,n),t.objectName=s)}if(t.propertyName===null||t.propertyName.length===0)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+A);return t}static findNode(A,e){if(e===void 0||e===""||e==="."||e===-1||e===A.name||e===A.uuid)return A;if(A.skeleton){const t=A.skeleton.getBoneByName(e);if(t!==void 0)return t}if(A.children){const t=function(s){for(let o=0;o<s.length;o++){const r=s[o];if(r.name===e||r.uuid===e)return r;const a=t(r.children);if(a)return a}return null},n=t(A.children);if(n)return n}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(A,e){A[e]=this.targetObject[this.propertyName]}_getValue_array(A,e){const t=this.resolvedProperty;for(let n=0,s=t.length;n!==s;++n)A[e++]=t[n]}_getValue_arrayElement(A,e){A[e]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(A,e){this.resolvedProperty.toArray(A,e)}_setValue_direct(A,e){this.targetObject[this.propertyName]=A[e]}_setValue_direct_setNeedsUpdate(A,e){this.targetObject[this.propertyName]=A[e],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(A,e){this.targetObject[this.propertyName]=A[e],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(A,e){const t=this.resolvedProperty;for(let n=0,s=t.length;n!==s;++n)t[n]=A[e++]}_setValue_array_setNeedsUpdate(A,e){const t=this.resolvedProperty;for(let n=0,s=t.length;n!==s;++n)t[n]=A[e++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(A,e){const t=this.resolvedProperty;for(let n=0,s=t.length;n!==s;++n)t[n]=A[e++];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_arrayElement(A,e){this.resolvedProperty[this.propertyIndex]=A[e]}_setValue_arrayElement_setNeedsUpdate(A,e){this.resolvedProperty[this.propertyIndex]=A[e],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(A,e){this.resolvedProperty[this.propertyIndex]=A[e],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(A,e){this.resolvedProperty.fromArray(A,e)}_setValue_fromArray_setNeedsUpdate(A,e){this.resolvedProperty.fromArray(A,e),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(A,e){this.resolvedProperty.fromArray(A,e),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(A,e){this.bind(),this.getValue(A,e)}_setValue_unbound(A,e){this.bind(),this.setValue(A,e)}bind(){let A=this.node;const e=this.parsedPath,t=e.objectName,n=e.propertyName;let s=e.propertyIndex;if(A||(A=ae.findNode(this.rootNode,e.nodeName),this.node=A),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!A){console.warn("THREE.PropertyBinding: No target node found for track: "+this.path+".");return}if(t){let g=e.objectIndex;switch(t){case"materials":if(!A.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!A.material.materials){console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);return}A=A.material.materials;break;case"bones":if(!A.skeleton){console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);return}A=A.skeleton.bones;for(let I=0;I<A.length;I++)if(A[I].name===g){g=I;break}break;case"map":if("map"in A){A=A.map;break}if(!A.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!A.material.map){console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",this);return}A=A.material.map;break;default:if(A[t]===void 0){console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);return}A=A[t]}if(g!==void 0){if(A[g]===void 0){console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,A);return}A=A[g]}}const o=A[n];if(o===void 0){const g=e.nodeName;console.error("THREE.PropertyBinding: Trying to update property for track: "+g+"."+n+" but it wasn't found.",A);return}let r=this.Versioning.None;this.targetObject=A,A.needsUpdate!==void 0?r=this.Versioning.NeedsUpdate:A.matrixWorldNeedsUpdate!==void 0&&(r=this.Versioning.MatrixWorldNeedsUpdate);let a=this.BindingType.Direct;if(s!==void 0){if(n==="morphTargetInfluences"){if(!A.geometry){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);return}if(!A.geometry.morphAttributes){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);return}A.morphTargetDictionary[s]!==void 0&&(s=A.morphTargetDictionary[s])}a=this.BindingType.ArrayElement,this.resolvedProperty=o,this.propertyIndex=s}else o.fromArray!==void 0&&o.toArray!==void 0?(a=this.BindingType.HasFromToArray,this.resolvedProperty=o):Array.isArray(o)?(a=this.BindingType.EntireArray,this.resolvedProperty=o):this.propertyName=n;this.getValue=this.GetterByBindingType[a],this.setValue=this.SetterByBindingTypeAndVersioning[a][r]}unbind(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}ae.Composite=Bc;ae.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3};ae.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2};ae.prototype.GetterByBindingType=[ae.prototype._getValue_direct,ae.prototype._getValue_array,ae.prototype._getValue_arrayElement,ae.prototype._getValue_toArray];ae.prototype.SetterByBindingTypeAndVersioning=[[ae.prototype._setValue_direct,ae.prototype._setValue_direct_setNeedsUpdate,ae.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[ae.prototype._setValue_array,ae.prototype._setValue_array_setNeedsUpdate,ae.prototype._setValue_array_setMatrixWorldNeedsUpdate],[ae.prototype._setValue_arrayElement,ae.prototype._setValue_arrayElement_setNeedsUpdate,ae.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[ae.prototype._setValue_fromArray,ae.prototype._setValue_fromArray_setNeedsUpdate,ae.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];const Ug=new UA;class cc{constructor(A,e,t=0,n=1/0){this.ray=new Mi(A,e),this.near=t,this.far=n,this.camera=null,this.layers=new Ba,this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}}}set(A,e){this.ray.set(A,e)}setFromCamera(A,e){e.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(e.matrixWorld),this.ray.direction.set(A.x,A.y,.5).unproject(e).sub(this.ray.origin).normalize(),this.camera=e):e.isOrthographicCamera?(this.ray.origin.set(A.x,A.y,(e.near+e.far)/(e.near-e.far)).unproject(e),this.ray.direction.set(0,0,-1).transformDirection(e.matrixWorld),this.camera=e):console.error("THREE.Raycaster: Unsupported camera type: "+e.type)}setFromXRController(A){return Ug.identity().extractRotation(A.matrixWorld),this.ray.origin.setFromMatrixPosition(A.matrixWorld),this.ray.direction.set(0,0,-1).applyMatrix4(Ug),this}intersectObject(A,e=!0,t=[]){return qr(A,this,t,e),t.sort(Gg),t}intersectObjects(A,e=!0,t=[]){for(let n=0,s=A.length;n<s;n++)qr(A[n],this,t,e);return t.sort(Gg),t}}function Gg(i,A){return i.distance-A.distance}function qr(i,A,e,t){let n=!0;if(i.layers.test(A.layers)&&i.raycast(A,e)===!1&&(n=!1),n===!0&&t===!0){const s=i.children;for(let o=0,r=s.length;o<r;o++)qr(s[o],A,e,!0)}}const vg=new bA;class hc{constructor(A=new bA(1/0,1/0),e=new bA(-1/0,-1/0)){this.isBox2=!0,this.min=A,this.max=e}set(A,e){return this.min.copy(A),this.max.copy(e),this}setFromPoints(A){this.makeEmpty();for(let e=0,t=A.length;e<t;e++)this.expandByPoint(A[e]);return this}setFromCenterAndSize(A,e){const t=vg.copy(e).multiplyScalar(.5);return this.min.copy(A).sub(t),this.max.copy(A).add(t),this}clone(){return new this.constructor().copy(this)}copy(A){return this.min.copy(A.min),this.max.copy(A.max),this}makeEmpty(){return this.min.x=this.min.y=1/0,this.max.x=this.max.y=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y}getCenter(A){return this.isEmpty()?A.set(0,0):A.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(A){return this.isEmpty()?A.set(0,0):A.subVectors(this.max,this.min)}expandByPoint(A){return this.min.min(A),this.max.max(A),this}expandByVector(A){return this.min.sub(A),this.max.add(A),this}expandByScalar(A){return this.min.addScalar(-A),this.max.addScalar(A),this}containsPoint(A){return A.x>=this.min.x&&A.x<=this.max.x&&A.y>=this.min.y&&A.y<=this.max.y}containsBox(A){return this.min.x<=A.min.x&&A.max.x<=this.max.x&&this.min.y<=A.min.y&&A.max.y<=this.max.y}getParameter(A,e){return e.set((A.x-this.min.x)/(this.max.x-this.min.x),(A.y-this.min.y)/(this.max.y-this.min.y))}intersectsBox(A){return A.max.x>=this.min.x&&A.min.x<=this.max.x&&A.max.y>=this.min.y&&A.min.y<=this.max.y}clampPoint(A,e){return e.copy(A).clamp(this.min,this.max)}distanceToPoint(A){return this.clampPoint(A,vg).distanceTo(A)}intersect(A){return this.min.max(A.min),this.max.min(A.max),this.isEmpty()&&this.makeEmpty(),this}union(A){return this.min.min(A.min),this.max.max(A.max),this}translate(A){return this.min.add(A),this.max.add(A),this}equals(A){return A.min.equals(this.min)&&A.max.equals(this.max)}}const Tg=new L,Ds=new L;class lc{constructor(A=new L,e=new L){this.start=A,this.end=e}set(A,e){return this.start.copy(A),this.end.copy(e),this}copy(A){return this.start.copy(A.start),this.end.copy(A.end),this}getCenter(A){return A.addVectors(this.start,this.end).multiplyScalar(.5)}delta(A){return A.subVectors(this.end,this.start)}distanceSq(){return this.start.distanceToSquared(this.end)}distance(){return this.start.distanceTo(this.end)}at(A,e){return this.delta(e).multiplyScalar(A).add(this.start)}closestPointToPointParameter(A,e){Tg.subVectors(A,this.start),Ds.subVectors(this.end,this.start);const t=Ds.dot(Ds);let s=Ds.dot(Tg)/t;return e&&(s=zA(s,0,1)),s}closestPointToPoint(A,e,t){const n=this.closestPointToPointParameter(A,e);return this.delta(t).multiplyScalar(n).add(this.start)}applyMatrix4(A){return this.start.applyMatrix4(A),this.end.applyMatrix4(A),this}equals(A){return A.start.equals(this.start)&&A.end.equals(this.end)}clone(){return new this.constructor().copy(this)}}class dc extends Si{constructor(A,e=null){super(),this.object=A,this.domElement=e,this.enabled=!0,this.state=-1,this.keys={},this.mouseButtons={LEFT:null,MIDDLE:null,RIGHT:null},this.touches={ONE:null,TWO:null}}connect(){}disconnect(){}dispose(){}update(){}}function bg(i,A,e,t){const n=uc(t);switch(e){case EE:return i*A;case QE:return i*A;case BE:return i*A*2;case aa:return i*A/n.components*n.byteLength;case ga:return i*A/n.components*n.byteLength;case cE:return i*A*2/n.components*n.byteLength;case Ia:return i*A*2/n.components*n.byteLength;case CE:return i*A*3/n.components*n.byteLength;case et:return i*A*4/n.components*n.byteLength;case mt:return i*A*4/n.components*n.byteLength;case _s:case Us:return Math.floor((i+3)/4)*Math.floor((A+3)/4)*8;case Gs:case vs:return Math.floor((i+3)/4)*Math.floor((A+3)/4)*16;case lr:case ur:return Math.max(i,16)*Math.max(A,8)/4;case hr:case dr:return Math.max(i,8)*Math.max(A,8)/2;case fr:case pr:return Math.floor((i+3)/4)*Math.floor((A+3)/4)*8;case Dr:return Math.floor((i+3)/4)*Math.floor((A+3)/4)*16;case mr:return Math.floor((i+3)/4)*Math.floor((A+3)/4)*16;case yr:return Math.floor((i+4)/5)*Math.floor((A+3)/4)*16;case Rr:return Math.floor((i+4)/5)*Math.floor((A+4)/5)*16;case wr:return Math.floor((i+5)/6)*Math.floor((A+4)/5)*16;case Sr:return Math.floor((i+5)/6)*Math.floor((A+5)/6)*16;case Mr:return Math.floor((i+7)/8)*Math.floor((A+4)/5)*16;case Nr:return Math.floor((i+7)/8)*Math.floor((A+5)/6)*16;case xr:return Math.floor((i+7)/8)*Math.floor((A+7)/8)*16;case Fr:return Math.floor((i+9)/10)*Math.floor((A+4)/5)*16;case Lr:return Math.floor((i+9)/10)*Math.floor((A+5)/6)*16;case _r:return Math.floor((i+9)/10)*Math.floor((A+7)/8)*16;case Ur:return Math.floor((i+9)/10)*Math.floor((A+9)/10)*16;case Gr:return Math.floor((i+11)/12)*Math.floor((A+9)/10)*16;case vr:return Math.floor((i+11)/12)*Math.floor((A+11)/12)*16;case Ts:case Tr:case br:return Math.ceil(i/4)*Math.ceil(A/4)*16;case hE:case kr:return Math.ceil(i/4)*Math.ceil(A/4)*8;case Hr:case Pr:return Math.ceil(i/4)*Math.ceil(A/4)*16}throw new Error(`Unable to determine texture byte length for ${e} format.`)}function uc(i){switch(i){case qt:case aE:return{byteLength:1,components:1};case Hn:case gE:case qn:return{byteLength:2,components:1};case oa:case ra:return{byteLength:2,components:4};case Oe:case sa:case lt:return{byteLength:4,components:1};case IE:return{byteLength:4,components:3}}throw new Error(`Unknown texture type ${i}.`)}typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:na}}));typeof window<"u"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=na);/**
 * @license
 * Copyright 2010-2024 Three.js Authors
 * SPDX-License-Identifier: MIT
 */function kE(){let i=null,A=!1,e=null,t=null;function n(s,o){e(s,o),t=i.requestAnimationFrame(n)}return{start:function(){A!==!0&&e!==null&&(t=i.requestAnimationFrame(n),A=!0)},stop:function(){i.cancelAnimationFrame(t),A=!1},setAnimationLoop:function(s){e=s},setContext:function(s){i=s}}}function fc(i){const A=new WeakMap;function e(r,a){const g=r.array,I=r.usage,E=g.byteLength,C=i.createBuffer();i.bindBuffer(a,C),i.bufferData(a,g,I),r.onUploadCallback();let Q;if(g instanceof Float32Array)Q=i.FLOAT;else if(g instanceof Uint16Array)r.isFloat16BufferAttribute?Q=i.HALF_FLOAT:Q=i.UNSIGNED_SHORT;else if(g instanceof Int16Array)Q=i.SHORT;else if(g instanceof Uint32Array)Q=i.UNSIGNED_INT;else if(g instanceof Int32Array)Q=i.INT;else if(g instanceof Int8Array)Q=i.BYTE;else if(g instanceof Uint8Array)Q=i.UNSIGNED_BYTE;else if(g instanceof Uint8ClampedArray)Q=i.UNSIGNED_BYTE;else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: "+g);return{buffer:C,type:Q,bytesPerElement:g.BYTES_PER_ELEMENT,version:r.version,size:E}}function t(r,a,g){const I=a.array,E=a.updateRanges;if(i.bindBuffer(g,r),E.length===0)i.bufferSubData(g,0,I);else{E.sort((Q,h)=>Q.start-h.start);let C=0;for(let Q=1;Q<E.length;Q++){const h=E[C],l=E[Q];l.start<=h.start+h.count+1?h.count=Math.max(h.count,l.start+l.count-h.start):(++C,E[C]=l)}E.length=C+1;for(let Q=0,h=E.length;Q<h;Q++){const l=E[Q];i.bufferSubData(g,l.start*I.BYTES_PER_ELEMENT,I,l.start,l.count)}a.clearUpdateRanges()}a.onUploadCallback()}function n(r){return r.isInterleavedBufferAttribute&&(r=r.data),A.get(r)}function s(r){r.isInterleavedBufferAttribute&&(r=r.data);const a=A.get(r);a&&(i.deleteBuffer(a.buffer),A.delete(r))}function o(r,a){if(r.isInterleavedBufferAttribute&&(r=r.data),r.isGLBufferAttribute){const I=A.get(r);(!I||I.version<r.version)&&A.set(r,{buffer:r.buffer,type:r.type,bytesPerElement:r.elementSize,version:r.version});return}const g=A.get(r);if(g===void 0)A.set(r,e(r,a));else if(g.version<r.version){if(g.size!==r.array.byteLength)throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");t(g.buffer,r,a),g.version=r.version}}return{get:n,remove:s,update:o}}var pc=`#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,Dc=`#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,mc=`#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,yc=`#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,Rc=`#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`,wc=`#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,Sc=`#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,Mc=`#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,Nc=`#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`,xc=`#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`,Fc=`vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,Lc=`vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,_c=`float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,Uc=`#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,Gc=`#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,vc=`#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`,Tc=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,bc=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,kc=`#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,Hc=`#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,Pc=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,Oc=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`,Jc=`#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`,Kc=`#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,Yc=`#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,qc=`vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,Wc=`#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,Vc=`#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,zc=`#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE
		emissiveColor = sRGBTransferEOTF( emissiveColor );
	#endif
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,Xc=`#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,Zc="gl_FragColor = linearToOutputTexel( gl_FragColor );",jc=`vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferEOTF( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,$c=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,Ah=`#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,eh=`#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,th=`#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,ih=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,nh=`#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,sh=`#ifdef USE_FOG
	varying float vFogDepth;
#endif`,oh=`#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,rh=`#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,ah=`#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,gh=`#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,Ih=`LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,Eh=`varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,Ch=`uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,Qh=`#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,Bh=`ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,ch=`varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,hh=`BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,lh=`varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,dh=`PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`,uh=`struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,fh=`
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,ph=`#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,Dh=`#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`,mh=`#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,yh=`#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,Rh=`#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,wh=`#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`,Sh=`#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,Mh=`#ifdef USE_MAP
	uniform sampler2D map;
#endif`,Nh=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,xh=`#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,Fh=`float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,Lh=`#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,_h=`#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`,Uh=`#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,Gh=`#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,vh=`#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`,Th=`#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,bh=`float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`,kh=`#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,Hh=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,Ph=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,Oh=`#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,Jh=`#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,Kh=`#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`,Yh=`#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,qh=`#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,Wh=`#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,Vh=`#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,zh=`vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,Xh=`#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,Zh=`vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,jh=`#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,$h=`#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,Al=`float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,el=`#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,tl=`#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`,il=`#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,nl=`#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,sl=`float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,ol=`#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,rl=`#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,al=`#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,gl=`#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,Il=`float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,El=`#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,Cl=`#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,Ql=`#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 CineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,Bl=`#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,cl=`#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
		
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
		
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		
		#else
		
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,hl=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,ll=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,dl=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,ul=`#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;const fl=`varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,pl=`uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,Dl=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,ml=`#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,yl=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,Rl=`uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,wl=`#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,Sl=`#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`,Ml=`#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,Nl=`#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,xl=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,Fl=`uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,Ll=`uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,_l=`uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,Ul=`#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,Gl=`uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,vl=`#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,Tl=`#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,bl=`#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,kl=`#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Hl=`#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,Pl=`#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,Ol=`#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,Jl=`#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Kl=`#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,Yl=`#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,ql=`#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,Wl=`#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Vl=`uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,zl=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,Xl=`#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,Zl=`uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,jl=`uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix[ 3 ];
	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,$l=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,OA={alphahash_fragment:pc,alphahash_pars_fragment:Dc,alphamap_fragment:mc,alphamap_pars_fragment:yc,alphatest_fragment:Rc,alphatest_pars_fragment:wc,aomap_fragment:Sc,aomap_pars_fragment:Mc,batching_pars_vertex:Nc,batching_vertex:xc,begin_vertex:Fc,beginnormal_vertex:Lc,bsdfs:_c,iridescence_fragment:Uc,bumpmap_pars_fragment:Gc,clipping_planes_fragment:vc,clipping_planes_pars_fragment:Tc,clipping_planes_pars_vertex:bc,clipping_planes_vertex:kc,color_fragment:Hc,color_pars_fragment:Pc,color_pars_vertex:Oc,color_vertex:Jc,common:Kc,cube_uv_reflection_fragment:Yc,defaultnormal_vertex:qc,displacementmap_pars_vertex:Wc,displacementmap_vertex:Vc,emissivemap_fragment:zc,emissivemap_pars_fragment:Xc,colorspace_fragment:Zc,colorspace_pars_fragment:jc,envmap_fragment:$c,envmap_common_pars_fragment:Ah,envmap_pars_fragment:eh,envmap_pars_vertex:th,envmap_physical_pars_fragment:Qh,envmap_vertex:ih,fog_vertex:nh,fog_pars_vertex:sh,fog_fragment:oh,fog_pars_fragment:rh,gradientmap_pars_fragment:ah,lightmap_pars_fragment:gh,lights_lambert_fragment:Ih,lights_lambert_pars_fragment:Eh,lights_pars_begin:Ch,lights_toon_fragment:Bh,lights_toon_pars_fragment:ch,lights_phong_fragment:hh,lights_phong_pars_fragment:lh,lights_physical_fragment:dh,lights_physical_pars_fragment:uh,lights_fragment_begin:fh,lights_fragment_maps:ph,lights_fragment_end:Dh,logdepthbuf_fragment:mh,logdepthbuf_pars_fragment:yh,logdepthbuf_pars_vertex:Rh,logdepthbuf_vertex:wh,map_fragment:Sh,map_pars_fragment:Mh,map_particle_fragment:Nh,map_particle_pars_fragment:xh,metalnessmap_fragment:Fh,metalnessmap_pars_fragment:Lh,morphinstance_vertex:_h,morphcolor_vertex:Uh,morphnormal_vertex:Gh,morphtarget_pars_vertex:vh,morphtarget_vertex:Th,normal_fragment_begin:bh,normal_fragment_maps:kh,normal_pars_fragment:Hh,normal_pars_vertex:Ph,normal_vertex:Oh,normalmap_pars_fragment:Jh,clearcoat_normal_fragment_begin:Kh,clearcoat_normal_fragment_maps:Yh,clearcoat_pars_fragment:qh,iridescence_pars_fragment:Wh,opaque_fragment:Vh,packing:zh,premultiplied_alpha_fragment:Xh,project_vertex:Zh,dithering_fragment:jh,dithering_pars_fragment:$h,roughnessmap_fragment:Al,roughnessmap_pars_fragment:el,shadowmap_pars_fragment:tl,shadowmap_pars_vertex:il,shadowmap_vertex:nl,shadowmask_pars_fragment:sl,skinbase_vertex:ol,skinning_pars_vertex:rl,skinning_vertex:al,skinnormal_vertex:gl,specularmap_fragment:Il,specularmap_pars_fragment:El,tonemapping_fragment:Cl,tonemapping_pars_fragment:Ql,transmission_fragment:Bl,transmission_pars_fragment:cl,uv_pars_fragment:hl,uv_pars_vertex:ll,uv_vertex:dl,worldpos_vertex:ul,background_vert:fl,background_frag:pl,backgroundCube_vert:Dl,backgroundCube_frag:ml,cube_vert:yl,cube_frag:Rl,depth_vert:wl,depth_frag:Sl,distanceRGBA_vert:Ml,distanceRGBA_frag:Nl,equirect_vert:xl,equirect_frag:Fl,linedashed_vert:Ll,linedashed_frag:_l,meshbasic_vert:Ul,meshbasic_frag:Gl,meshlambert_vert:vl,meshlambert_frag:Tl,meshmatcap_vert:bl,meshmatcap_frag:kl,meshnormal_vert:Hl,meshnormal_frag:Pl,meshphong_vert:Ol,meshphong_frag:Jl,meshphysical_vert:Kl,meshphysical_frag:Yl,meshtoon_vert:ql,meshtoon_frag:Wl,points_vert:Vl,points_frag:zl,shadow_vert:Xl,shadow_frag:Zl,sprite_vert:jl,sprite_frag:$l},aA={common:{diffuse:{value:new GA(16777215)},opacity:{value:1},map:{value:null},mapTransform:{value:new PA},alphaMap:{value:null},alphaMapTransform:{value:new PA},alphaTest:{value:0}},specularmap:{specularMap:{value:null},specularMapTransform:{value:new PA}},envmap:{envMap:{value:null},envMapRotation:{value:new PA},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1},aoMapTransform:{value:new PA}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1},lightMapTransform:{value:new PA}},bumpmap:{bumpMap:{value:null},bumpMapTransform:{value:new PA},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalMapTransform:{value:new PA},normalScale:{value:new bA(1,1)}},displacementmap:{displacementMap:{value:null},displacementMapTransform:{value:new PA},displacementScale:{value:1},displacementBias:{value:0}},emissivemap:{emissiveMap:{value:null},emissiveMapTransform:{value:new PA}},metalnessmap:{metalnessMap:{value:null},metalnessMapTransform:{value:new PA}},roughnessmap:{roughnessMap:{value:null},roughnessMapTransform:{value:new PA}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new GA(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotLightMap:{value:[]},spotShadowMap:{value:[]},spotLightMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new GA(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaMapTransform:{value:new PA},alphaTest:{value:0},uvTransform:{value:new PA}},sprite:{diffuse:{value:new GA(16777215)},opacity:{value:1},center:{value:new bA(.5,.5)},rotation:{value:0},map:{value:null},mapTransform:{value:new PA},alphaMap:{value:null},alphaMapTransform:{value:new PA},alphaTest:{value:0}}},Qt={basic:{uniforms:Ge([aA.common,aA.specularmap,aA.envmap,aA.aomap,aA.lightmap,aA.fog]),vertexShader:OA.meshbasic_vert,fragmentShader:OA.meshbasic_frag},lambert:{uniforms:Ge([aA.common,aA.specularmap,aA.envmap,aA.aomap,aA.lightmap,aA.emissivemap,aA.bumpmap,aA.normalmap,aA.displacementmap,aA.fog,aA.lights,{emissive:{value:new GA(0)}}]),vertexShader:OA.meshlambert_vert,fragmentShader:OA.meshlambert_frag},phong:{uniforms:Ge([aA.common,aA.specularmap,aA.envmap,aA.aomap,aA.lightmap,aA.emissivemap,aA.bumpmap,aA.normalmap,aA.displacementmap,aA.fog,aA.lights,{emissive:{value:new GA(0)},specular:{value:new GA(1118481)},shininess:{value:30}}]),vertexShader:OA.meshphong_vert,fragmentShader:OA.meshphong_frag},standard:{uniforms:Ge([aA.common,aA.envmap,aA.aomap,aA.lightmap,aA.emissivemap,aA.bumpmap,aA.normalmap,aA.displacementmap,aA.roughnessmap,aA.metalnessmap,aA.fog,aA.lights,{emissive:{value:new GA(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:OA.meshphysical_vert,fragmentShader:OA.meshphysical_frag},toon:{uniforms:Ge([aA.common,aA.aomap,aA.lightmap,aA.emissivemap,aA.bumpmap,aA.normalmap,aA.displacementmap,aA.gradientmap,aA.fog,aA.lights,{emissive:{value:new GA(0)}}]),vertexShader:OA.meshtoon_vert,fragmentShader:OA.meshtoon_frag},matcap:{uniforms:Ge([aA.common,aA.bumpmap,aA.normalmap,aA.displacementmap,aA.fog,{matcap:{value:null}}]),vertexShader:OA.meshmatcap_vert,fragmentShader:OA.meshmatcap_frag},points:{uniforms:Ge([aA.points,aA.fog]),vertexShader:OA.points_vert,fragmentShader:OA.points_frag},dashed:{uniforms:Ge([aA.common,aA.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:OA.linedashed_vert,fragmentShader:OA.linedashed_frag},depth:{uniforms:Ge([aA.common,aA.displacementmap]),vertexShader:OA.depth_vert,fragmentShader:OA.depth_frag},normal:{uniforms:Ge([aA.common,aA.bumpmap,aA.normalmap,aA.displacementmap,{opacity:{value:1}}]),vertexShader:OA.meshnormal_vert,fragmentShader:OA.meshnormal_frag},sprite:{uniforms:Ge([aA.sprite,aA.fog]),vertexShader:OA.sprite_vert,fragmentShader:OA.sprite_frag},background:{uniforms:{uvTransform:{value:new PA},t2D:{value:null},backgroundIntensity:{value:1}},vertexShader:OA.background_vert,fragmentShader:OA.background_frag},backgroundCube:{uniforms:{envMap:{value:null},flipEnvMap:{value:-1},backgroundBlurriness:{value:0},backgroundIntensity:{value:1},backgroundRotation:{value:new PA}},vertexShader:OA.backgroundCube_vert,fragmentShader:OA.backgroundCube_frag},cube:{uniforms:{tCube:{value:null},tFlip:{value:-1},opacity:{value:1}},vertexShader:OA.cube_vert,fragmentShader:OA.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:OA.equirect_vert,fragmentShader:OA.equirect_frag},distanceRGBA:{uniforms:Ge([aA.common,aA.displacementmap,{referencePosition:{value:new L},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:OA.distanceRGBA_vert,fragmentShader:OA.distanceRGBA_frag},shadow:{uniforms:Ge([aA.lights,aA.fog,{color:{value:new GA(0)},opacity:{value:1}}]),vertexShader:OA.shadow_vert,fragmentShader:OA.shadow_frag}};Qt.physical={uniforms:Ge([Qt.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatMapTransform:{value:new PA},clearcoatNormalMap:{value:null},clearcoatNormalMapTransform:{value:new PA},clearcoatNormalScale:{value:new bA(1,1)},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatRoughnessMapTransform:{value:new PA},dispersion:{value:0},iridescence:{value:0},iridescenceMap:{value:null},iridescenceMapTransform:{value:new PA},iridescenceIOR:{value:1.3},iridescenceThicknessMinimum:{value:100},iridescenceThicknessMaximum:{value:400},iridescenceThicknessMap:{value:null},iridescenceThicknessMapTransform:{value:new PA},sheen:{value:0},sheenColor:{value:new GA(0)},sheenColorMap:{value:null},sheenColorMapTransform:{value:new PA},sheenRoughness:{value:1},sheenRoughnessMap:{value:null},sheenRoughnessMapTransform:{value:new PA},transmission:{value:0},transmissionMap:{value:null},transmissionMapTransform:{value:new PA},transmissionSamplerSize:{value:new bA},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},thicknessMapTransform:{value:new PA},attenuationDistance:{value:0},attenuationColor:{value:new GA(0)},specularColor:{value:new GA(1,1,1)},specularColorMap:{value:null},specularColorMapTransform:{value:new PA},specularIntensity:{value:1},specularIntensityMap:{value:null},specularIntensityMapTransform:{value:new PA},anisotropyVector:{value:new bA},anisotropyMap:{value:null},anisotropyMapTransform:{value:new PA}}]),vertexShader:OA.meshphysical_vert,fragmentShader:OA.meshphysical_frag};const ms={r:0,b:0,g:0},di=new pt,Ad=new UA;function ed(i,A,e,t,n,s,o){const r=new GA(0);let a=s===!0?0:1,g,I,E=null,C=0,Q=null;function h(p){let d=p.isScene===!0?p.background:null;return d&&d.isTexture&&(d=(p.backgroundBlurriness>0?e:A).get(d)),d}function l(p){let d=!1;const w=h(p);w===null?c(r,a):w&&w.isColor&&(c(w,1),d=!0);const S=i.xr.getEnvironmentBlendMode();S==="additive"?t.buffers.color.setClear(0,0,0,1,o):S==="alpha-blend"&&t.buffers.color.setClear(0,0,0,0,o),(i.autoClear||d)&&(t.buffers.depth.setTest(!0),t.buffers.depth.setMask(!0),t.buffers.color.setMask(!0),i.clear(i.autoClearColor,i.autoClearDepth,i.autoClearStencil))}function B(p,d){const w=h(d);w&&(w.isCubeTexture||w.mapping===eo)?(I===void 0&&(I=new ve(new Wn(1,1,1),new Wt({name:"BackgroundCubeMaterial",uniforms:En(Qt.backgroundCube.uniforms),vertexShader:Qt.backgroundCube.vertexShader,fragmentShader:Qt.backgroundCube.fragmentShader,side:Je,depthTest:!1,depthWrite:!1,fog:!1})),I.geometry.deleteAttribute("normal"),I.geometry.deleteAttribute("uv"),I.onBeforeRender=function(S,F,N){this.matrixWorld.copyPosition(N.matrixWorld)},Object.defineProperty(I.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),n.update(I)),di.copy(d.backgroundRotation),di.x*=-1,di.y*=-1,di.z*=-1,w.isCubeTexture&&w.isRenderTargetTexture===!1&&(di.y*=-1,di.z*=-1),I.material.uniforms.envMap.value=w,I.material.uniforms.flipEnvMap.value=w.isCubeTexture&&w.isRenderTargetTexture===!1?-1:1,I.material.uniforms.backgroundBlurriness.value=d.backgroundBlurriness,I.material.uniforms.backgroundIntensity.value=d.backgroundIntensity,I.material.uniforms.backgroundRotation.value.setFromMatrix4(Ad.makeRotationFromEuler(di)),I.material.toneMapped=$A.getTransfer(w.colorSpace)!==ge,(E!==w||C!==w.version||Q!==i.toneMapping)&&(I.material.needsUpdate=!0,E=w,C=w.version,Q=i.toneMapping),I.layers.enableAll(),p.unshift(I,I.geometry,I.material,0,0,null)):w&&w.isTexture&&(g===void 0&&(g=new ve(new Vn(2,2),new Wt({name:"BackgroundMaterial",uniforms:En(Qt.background.uniforms),vertexShader:Qt.background.vertexShader,fragmentShader:Qt.background.fragmentShader,side:ft,depthTest:!1,depthWrite:!1,fog:!1})),g.geometry.deleteAttribute("normal"),Object.defineProperty(g.material,"map",{get:function(){return this.uniforms.t2D.value}}),n.update(g)),g.material.uniforms.t2D.value=w,g.material.uniforms.backgroundIntensity.value=d.backgroundIntensity,g.material.toneMapped=$A.getTransfer(w.colorSpace)!==ge,w.matrixAutoUpdate===!0&&w.updateMatrix(),g.material.uniforms.uvTransform.value.copy(w.matrix),(E!==w||C!==w.version||Q!==i.toneMapping)&&(g.material.needsUpdate=!0,E=w,C=w.version,Q=i.toneMapping),g.layers.enableAll(),p.unshift(g,g.geometry,g.material,0,0,null))}function c(p,d){p.getRGB(ms,RE(i)),t.buffers.color.setClear(ms.r,ms.g,ms.b,d,o)}function R(){I!==void 0&&(I.geometry.dispose(),I.material.dispose()),g!==void 0&&(g.geometry.dispose(),g.material.dispose())}return{getClearColor:function(){return r},setClearColor:function(p,d=1){r.set(p),a=d,c(r,a)},getClearAlpha:function(){return a},setClearAlpha:function(p){a=p,c(r,a)},render:l,addToRenderList:B,dispose:R}}function td(i,A){const e=i.getParameter(i.MAX_VERTEX_ATTRIBS),t={},n=C(null);let s=n,o=!1;function r(f,m,T,M,_){let P=!1;const b=E(M,T,m);s!==b&&(s=b,g(s.object)),P=Q(f,M,T,_),P&&h(f,M,T,_),_!==null&&A.update(_,i.ELEMENT_ARRAY_BUFFER),(P||o)&&(o=!1,d(f,m,T,M),_!==null&&i.bindBuffer(i.ELEMENT_ARRAY_BUFFER,A.get(_).buffer))}function a(){return i.createVertexArray()}function g(f){return i.bindVertexArray(f)}function I(f){return i.deleteVertexArray(f)}function E(f,m,T){const M=T.wireframe===!0;let _=t[f.id];_===void 0&&(_={},t[f.id]=_);let P=_[m.id];P===void 0&&(P={},_[m.id]=P);let b=P[M];return b===void 0&&(b=C(a()),P[M]=b),b}function C(f){const m=[],T=[],M=[];for(let _=0;_<e;_++)m[_]=0,T[_]=0,M[_]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:m,enabledAttributes:T,attributeDivisors:M,object:f,attributes:{},index:null}}function Q(f,m,T,M){const _=s.attributes,P=m.attributes;let b=0;const z=T.getAttributes();for(const O in z)if(z[O].location>=0){const oA=_[O];let gA=P[O];if(gA===void 0&&(O==="instanceMatrix"&&f.instanceMatrix&&(gA=f.instanceMatrix),O==="instanceColor"&&f.instanceColor&&(gA=f.instanceColor)),oA===void 0||oA.attribute!==gA||gA&&oA.data!==gA.data)return!0;b++}return s.attributesNum!==b||s.index!==M}function h(f,m,T,M){const _={},P=m.attributes;let b=0;const z=T.getAttributes();for(const O in z)if(z[O].location>=0){let oA=P[O];oA===void 0&&(O==="instanceMatrix"&&f.instanceMatrix&&(oA=f.instanceMatrix),O==="instanceColor"&&f.instanceColor&&(oA=f.instanceColor));const gA={};gA.attribute=oA,oA&&oA.data&&(gA.data=oA.data),_[O]=gA,b++}s.attributes=_,s.attributesNum=b,s.index=M}function l(){const f=s.newAttributes;for(let m=0,T=f.length;m<T;m++)f[m]=0}function B(f){c(f,0)}function c(f,m){const T=s.newAttributes,M=s.enabledAttributes,_=s.attributeDivisors;T[f]=1,M[f]===0&&(i.enableVertexAttribArray(f),M[f]=1),_[f]!==m&&(i.vertexAttribDivisor(f,m),_[f]=m)}function R(){const f=s.newAttributes,m=s.enabledAttributes;for(let T=0,M=m.length;T<M;T++)m[T]!==f[T]&&(i.disableVertexAttribArray(T),m[T]=0)}function p(f,m,T,M,_,P,b){b===!0?i.vertexAttribIPointer(f,m,T,_,P):i.vertexAttribPointer(f,m,T,M,_,P)}function d(f,m,T,M){l();const _=M.attributes,P=T.getAttributes(),b=m.defaultAttributeValues;for(const z in P){const O=P[z];if(O.location>=0){let eA=_[z];if(eA===void 0&&(z==="instanceMatrix"&&f.instanceMatrix&&(eA=f.instanceMatrix),z==="instanceColor"&&f.instanceColor&&(eA=f.instanceColor)),eA!==void 0){const oA=eA.normalized,gA=eA.itemSize,pA=A.get(eA);if(pA===void 0)continue;const qA=pA.buffer,X=pA.type,AA=pA.bytesPerElement,hA=X===i.INT||X===i.UNSIGNED_INT||eA.gpuType===sa;if(eA.isInterleavedBufferAttribute){const rA=eA.data,mA=rA.stride,LA=eA.offset;if(rA.isInstancedInterleavedBuffer){for(let EA=0;EA<O.locationSize;EA++)c(O.location+EA,rA.meshPerAttribute);f.isInstancedMesh!==!0&&M._maxInstanceCount===void 0&&(M._maxInstanceCount=rA.meshPerAttribute*rA.count)}else for(let EA=0;EA<O.locationSize;EA++)B(O.location+EA);i.bindBuffer(i.ARRAY_BUFFER,qA);for(let EA=0;EA<O.locationSize;EA++)p(O.location+EA,gA/O.locationSize,X,oA,mA*AA,(LA+gA/O.locationSize*EA)*AA,hA)}else{if(eA.isInstancedBufferAttribute){for(let rA=0;rA<O.locationSize;rA++)c(O.location+rA,eA.meshPerAttribute);f.isInstancedMesh!==!0&&M._maxInstanceCount===void 0&&(M._maxInstanceCount=eA.meshPerAttribute*eA.count)}else for(let rA=0;rA<O.locationSize;rA++)B(O.location+rA);i.bindBuffer(i.ARRAY_BUFFER,qA);for(let rA=0;rA<O.locationSize;rA++)p(O.location+rA,gA/O.locationSize,X,oA,gA*AA,gA/O.locationSize*rA*AA,hA)}}else if(b!==void 0){const oA=b[z];if(oA!==void 0)switch(oA.length){case 2:i.vertexAttrib2fv(O.location,oA);break;case 3:i.vertexAttrib3fv(O.location,oA);break;case 4:i.vertexAttrib4fv(O.location,oA);break;default:i.vertexAttrib1fv(O.location,oA)}}}}R()}function w(){N();for(const f in t){const m=t[f];for(const T in m){const M=m[T];for(const _ in M)I(M[_].object),delete M[_];delete m[T]}delete t[f]}}function S(f){if(t[f.id]===void 0)return;const m=t[f.id];for(const T in m){const M=m[T];for(const _ in M)I(M[_].object),delete M[_];delete m[T]}delete t[f.id]}function F(f){for(const m in t){const T=t[m];if(T[f.id]===void 0)continue;const M=T[f.id];for(const _ in M)I(M[_].object),delete M[_];delete T[f.id]}}function N(){u(),o=!0,s!==n&&(s=n,g(s.object))}function u(){n.geometry=null,n.program=null,n.wireframe=!1}return{setup:r,reset:N,resetDefaultState:u,dispose:w,releaseStatesOfGeometry:S,releaseStatesOfProgram:F,initAttributes:l,enableAttribute:B,disableUnusedAttributes:R}}function id(i,A,e){let t;function n(g){t=g}function s(g,I){i.drawArrays(t,g,I),e.update(I,t,1)}function o(g,I,E){E!==0&&(i.drawArraysInstanced(t,g,I,E),e.update(I,t,E))}function r(g,I,E){if(E===0)return;A.get("WEBGL_multi_draw").multiDrawArraysWEBGL(t,g,0,I,0,E);let Q=0;for(let h=0;h<E;h++)Q+=I[h];e.update(Q,t,1)}function a(g,I,E,C){if(E===0)return;const Q=A.get("WEBGL_multi_draw");if(Q===null)for(let h=0;h<g.length;h++)o(g[h],I[h],C[h]);else{Q.multiDrawArraysInstancedWEBGL(t,g,0,I,0,C,0,E);let h=0;for(let l=0;l<E;l++)h+=I[l]*C[l];e.update(h,t,1)}}this.setMode=n,this.render=s,this.renderInstances=o,this.renderMultiDraw=r,this.renderMultiDrawInstances=a}function nd(i,A,e,t){let n;function s(){if(n!==void 0)return n;if(A.has("EXT_texture_filter_anisotropic")===!0){const F=A.get("EXT_texture_filter_anisotropic");n=i.getParameter(F.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else n=0;return n}function o(F){return!(F!==et&&t.convert(F)!==i.getParameter(i.IMPLEMENTATION_COLOR_READ_FORMAT))}function r(F){const N=F===qn&&(A.has("EXT_color_buffer_half_float")||A.has("EXT_color_buffer_float"));return!(F!==qt&&t.convert(F)!==i.getParameter(i.IMPLEMENTATION_COLOR_READ_TYPE)&&F!==lt&&!N)}function a(F){if(F==="highp"){if(i.getShaderPrecisionFormat(i.VERTEX_SHADER,i.HIGH_FLOAT).precision>0&&i.getShaderPrecisionFormat(i.FRAGMENT_SHADER,i.HIGH_FLOAT).precision>0)return"highp";F="mediump"}return F==="mediump"&&i.getShaderPrecisionFormat(i.VERTEX_SHADER,i.MEDIUM_FLOAT).precision>0&&i.getShaderPrecisionFormat(i.FRAGMENT_SHADER,i.MEDIUM_FLOAT).precision>0?"mediump":"lowp"}let g=e.precision!==void 0?e.precision:"highp";const I=a(g);I!==g&&(console.warn("THREE.WebGLRenderer:",g,"not supported, using",I,"instead."),g=I);const E=e.logarithmicDepthBuffer===!0,C=e.reverseDepthBuffer===!0&&A.has("EXT_clip_control"),Q=i.getParameter(i.MAX_TEXTURE_IMAGE_UNITS),h=i.getParameter(i.MAX_VERTEX_TEXTURE_IMAGE_UNITS),l=i.getParameter(i.MAX_TEXTURE_SIZE),B=i.getParameter(i.MAX_CUBE_MAP_TEXTURE_SIZE),c=i.getParameter(i.MAX_VERTEX_ATTRIBS),R=i.getParameter(i.MAX_VERTEX_UNIFORM_VECTORS),p=i.getParameter(i.MAX_VARYING_VECTORS),d=i.getParameter(i.MAX_FRAGMENT_UNIFORM_VECTORS),w=h>0,S=i.getParameter(i.MAX_SAMPLES);return{isWebGL2:!0,getMaxAnisotropy:s,getMaxPrecision:a,textureFormatReadable:o,textureTypeReadable:r,precision:g,logarithmicDepthBuffer:E,reverseDepthBuffer:C,maxTextures:Q,maxVertexTextures:h,maxTextureSize:l,maxCubemapSize:B,maxAttributes:c,maxVertexUniforms:R,maxVaryings:p,maxFragmentUniforms:d,vertexTextures:w,maxSamples:S}}function sd(i){const A=this;let e=null,t=0,n=!1,s=!1;const o=new Ht,r=new PA,a={value:null,needsUpdate:!1};this.uniform=a,this.numPlanes=0,this.numIntersection=0,this.init=function(E,C){const Q=E.length!==0||C||t!==0||n;return n=C,t=E.length,Q},this.beginShadows=function(){s=!0,I(null)},this.endShadows=function(){s=!1},this.setGlobalState=function(E,C){e=I(E,C,0)},this.setState=function(E,C,Q){const h=E.clippingPlanes,l=E.clipIntersection,B=E.clipShadows,c=i.get(E);if(!n||h===null||h.length===0||s&&!B)s?I(null):g();else{const R=s?0:t,p=R*4;let d=c.clippingState||null;a.value=d,d=I(h,C,p,Q);for(let w=0;w!==p;++w)d[w]=e[w];c.clippingState=d,this.numIntersection=l?this.numPlanes:0,this.numPlanes+=R}};function g(){a.value!==e&&(a.value=e,a.needsUpdate=t>0),A.numPlanes=t,A.numIntersection=0}function I(E,C,Q,h){const l=E!==null?E.length:0;let B=null;if(l!==0){if(B=a.value,h!==!0||B===null){const c=Q+l*4,R=C.matrixWorldInverse;r.getNormalMatrix(R),(B===null||B.length<c)&&(B=new Float32Array(c));for(let p=0,d=Q;p!==l;++p,d+=4)o.copy(E[p]).applyMatrix4(R,r),o.normal.toArray(B,d),B[d+3]=o.constant}a.value=B,a.needsUpdate=!0}return A.numPlanes=l,A.numIntersection=0,B}}function od(i){let A=new WeakMap;function e(o,r){return r===Br?o.mapping=sn:r===cr&&(o.mapping=on),o}function t(o){if(o&&o.isTexture){const r=o.mapping;if(r===Br||r===cr)if(A.has(o)){const a=A.get(o).texture;return e(a,o.mapping)}else{const a=o.image;if(a&&a.height>0){const g=new yB(a.height);return g.fromEquirectangularTexture(i,o),A.set(o,g),o.addEventListener("dispose",n),e(g.texture,o.mapping)}else return null}}return o}function n(o){const r=o.target;r.removeEventListener("dispose",n);const a=A.get(r);a!==void 0&&(A.delete(r),a.dispose())}function s(){A=new WeakMap}return{get:t,dispose:s}}const Zi=4,kg=[.125,.215,.35,.446,.526,.582],mi=20,To=new pa,Hg=new GA;let bo=null,ko=0,Ho=0,Po=!1;const pi=(1+Math.sqrt(5))/2,Yi=1/pi,Pg=[new L(-pi,Yi,0),new L(pi,Yi,0),new L(-Yi,0,pi),new L(Yi,0,pi),new L(0,pi,-Yi),new L(0,pi,Yi),new L(-1,1,-1),new L(1,1,-1),new L(-1,1,1),new L(1,1,1)];class Og{constructor(A){this._renderer=A,this._pingPongRenderTarget=null,this._lodMax=0,this._cubeSize=0,this._lodPlanes=[],this._sizeLods=[],this._sigmas=[],this._blurMaterial=null,this._cubemapMaterial=null,this._equirectMaterial=null,this._compileMaterial(this._blurMaterial)}fromScene(A,e=0,t=.1,n=100){bo=this._renderer.getRenderTarget(),ko=this._renderer.getActiveCubeFace(),Ho=this._renderer.getActiveMipmapLevel(),Po=this._renderer.xr.enabled,this._renderer.xr.enabled=!1,this._setSize(256);const s=this._allocateTargets();return s.depthBuffer=!0,this._sceneToCubeUV(A,t,n,s),e>0&&this._blur(s,0,0,e),this._applyPMREM(s),this._cleanup(s),s}fromEquirectangular(A,e=null){return this._fromTexture(A,e)}fromCubemap(A,e=null){return this._fromTexture(A,e)}compileCubemapShader(){this._cubemapMaterial===null&&(this._cubemapMaterial=Yg(),this._compileMaterial(this._cubemapMaterial))}compileEquirectangularShader(){this._equirectMaterial===null&&(this._equirectMaterial=Kg(),this._compileMaterial(this._equirectMaterial))}dispose(){this._dispose(),this._cubemapMaterial!==null&&this._cubemapMaterial.dispose(),this._equirectMaterial!==null&&this._equirectMaterial.dispose()}_setSize(A){this._lodMax=Math.floor(Math.log2(A)),this._cubeSize=Math.pow(2,this._lodMax)}_dispose(){this._blurMaterial!==null&&this._blurMaterial.dispose(),this._pingPongRenderTarget!==null&&this._pingPongRenderTarget.dispose();for(let A=0;A<this._lodPlanes.length;A++)this._lodPlanes[A].dispose()}_cleanup(A){this._renderer.setRenderTarget(bo,ko,Ho),this._renderer.xr.enabled=Po,A.scissorTest=!1,ys(A,0,0,A.width,A.height)}_fromTexture(A,e){A.mapping===sn||A.mapping===on?this._setSize(A.image.length===0?16:A.image[0].width||A.image[0].image.width):this._setSize(A.image.width/4),bo=this._renderer.getRenderTarget(),ko=this._renderer.getActiveCubeFace(),Ho=this._renderer.getActiveMipmapLevel(),Po=this._renderer.xr.enabled,this._renderer.xr.enabled=!1;const t=e||this._allocateTargets();return this._textureToCubeUV(A,t),this._applyPMREM(t),this._cleanup(t),t}_allocateTargets(){const A=3*Math.max(this._cubeSize,112),e=4*this._cubeSize,t={magFilter:ze,minFilter:ze,generateMipmaps:!1,type:qn,format:et,colorSpace:be,depthBuffer:!1},n=Jg(A,e,t);if(this._pingPongRenderTarget===null||this._pingPongRenderTarget.width!==A||this._pingPongRenderTarget.height!==e){this._pingPongRenderTarget!==null&&this._dispose(),this._pingPongRenderTarget=Jg(A,e,t);const{_lodMax:s}=this;({sizeLods:this._sizeLods,lodPlanes:this._lodPlanes,sigmas:this._sigmas}=rd(s)),this._blurMaterial=ad(s,A,e)}return n}_compileMaterial(A){const e=new ve(this._lodPlanes[0],A);this._renderer.compile(e,To)}_sceneToCubeUV(A,e,t,n){const r=new Le(90,1,e,t),a=[1,-1,1,1,1,1],g=[1,1,1,-1,-1,-1],I=this._renderer,E=I.autoClear,C=I.toneMapping;I.getClearColor(Hg),I.toneMapping=ai,I.autoClear=!1;const Q=new tt({name:"PMREM.Background",side:Je,depthWrite:!1,depthTest:!1}),h=new ve(new Wn,Q);let l=!1;const B=A.background;B?B.isColor&&(Q.color.copy(B),A.background=null,l=!0):(Q.color.copy(Hg),l=!0);for(let c=0;c<6;c++){const R=c%3;R===0?(r.up.set(0,a[c],0),r.lookAt(g[c],0,0)):R===1?(r.up.set(0,0,a[c]),r.lookAt(0,g[c],0)):(r.up.set(0,a[c],0),r.lookAt(0,0,g[c]));const p=this._cubeSize;ys(n,R*p,c>2?p:0,p,p),I.setRenderTarget(n),l&&I.render(h,r),I.render(A,r)}h.geometry.dispose(),h.material.dispose(),I.toneMapping=C,I.autoClear=E,A.background=B}_textureToCubeUV(A,e){const t=this._renderer,n=A.mapping===sn||A.mapping===on;n?(this._cubemapMaterial===null&&(this._cubemapMaterial=Yg()),this._cubemapMaterial.uniforms.flipEnvMap.value=A.isRenderTargetTexture===!1?-1:1):this._equirectMaterial===null&&(this._equirectMaterial=Kg());const s=n?this._cubemapMaterial:this._equirectMaterial,o=new ve(this._lodPlanes[0],s),r=s.uniforms;r.envMap.value=A;const a=this._cubeSize;ys(e,0,0,3*a,2*a),t.setRenderTarget(e),t.render(o,To)}_applyPMREM(A){const e=this._renderer,t=e.autoClear;e.autoClear=!1;const n=this._lodPlanes.length;for(let s=1;s<n;s++){const o=Math.sqrt(this._sigmas[s]*this._sigmas[s]-this._sigmas[s-1]*this._sigmas[s-1]),r=Pg[(n-s-1)%Pg.length];this._blur(A,s-1,s,o,r)}e.autoClear=t}_blur(A,e,t,n,s){const o=this._pingPongRenderTarget;this._halfBlur(A,o,e,t,n,"latitudinal",s),this._halfBlur(o,A,t,t,n,"longitudinal",s)}_halfBlur(A,e,t,n,s,o,r){const a=this._renderer,g=this._blurMaterial;o!=="latitudinal"&&o!=="longitudinal"&&console.error("blur direction must be either latitudinal or longitudinal!");const I=3,E=new ve(this._lodPlanes[n],g),C=g.uniforms,Q=this._sizeLods[t]-1,h=isFinite(s)?Math.PI/(2*Q):2*Math.PI/(2*mi-1),l=s/h,B=isFinite(s)?1+Math.floor(I*l):mi;B>mi&&console.warn(`sigmaRadians, ${s}, is too large and will clip, as it requested ${B} samples when the maximum is set to ${mi}`);const c=[];let R=0;for(let F=0;F<mi;++F){const N=F/l,u=Math.exp(-N*N/2);c.push(u),F===0?R+=u:F<B&&(R+=2*u)}for(let F=0;F<c.length;F++)c[F]=c[F]/R;C.envMap.value=A.texture,C.samples.value=B,C.weights.value=c,C.latitudinal.value=o==="latitudinal",r&&(C.poleAxis.value=r);const{_lodMax:p}=this;C.dTheta.value=h,C.mipInt.value=p-t;const d=this._sizeLods[n],w=3*d*(n>p-Zi?n-p+Zi:0),S=4*(this._cubeSize-d);ys(e,w,S,3*d,2*d),a.setRenderTarget(e),a.render(E,To)}}function rd(i){const A=[],e=[],t=[];let n=i;const s=i-Zi+1+kg.length;for(let o=0;o<s;o++){const r=Math.pow(2,n);e.push(r);let a=1/r;o>i-Zi?a=kg[o-i+Zi-1]:o===0&&(a=0),t.push(a);const g=1/(r-2),I=-g,E=1+g,C=[I,I,E,I,E,E,I,I,E,E,I,E],Q=6,h=6,l=3,B=2,c=1,R=new Float32Array(l*h*Q),p=new Float32Array(B*h*Q),d=new Float32Array(c*h*Q);for(let S=0;S<Q;S++){const F=S%3*2/3-1,N=S>2?0:-1,u=[F,N,0,F+2/3,N,0,F+2/3,N+1,0,F,N,0,F+2/3,N+1,0,F,N+1,0];R.set(u,l*h*S),p.set(C,B*h*S);const f=[S,S,S,S,S,S];d.set(f,c*h*S)}const w=new Xe;w.setAttribute("position",new Qe(R,l)),w.setAttribute("uv",new Qe(p,B)),w.setAttribute("faceIndex",new Qe(d,c)),A.push(w),n>Zi&&n--}return{lodPlanes:A,sizeLods:e,sigmas:t}}function Jg(i,A,e){const t=new wi(i,A,e);return t.texture.mapping=eo,t.texture.name="PMREM.cubeUv",t.scissorTest=!0,t}function ys(i,A,e,t,n){i.viewport.set(A,e,t,n),i.scissor.set(A,e,t,n)}function ad(i,A,e){const t=new Float32Array(mi),n=new L(0,1,0);return new Wt({name:"SphericalGaussianBlur",defines:{n:mi,CUBEUV_TEXEL_WIDTH:1/A,CUBEUV_TEXEL_HEIGHT:1/e,CUBEUV_MAX_MIP:`${i}.0`},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:t},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:n}},vertexShader:ya(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,blending:ri,depthTest:!1,depthWrite:!1})}function Kg(){return new Wt({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null}},vertexShader:ya(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,blending:ri,depthTest:!1,depthWrite:!1})}function Yg(){return new Wt({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},flipEnvMap:{value:-1}},vertexShader:ya(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,blending:ri,depthTest:!1,depthWrite:!1})}function ya(){return`

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`}function gd(i){let A=new WeakMap,e=null;function t(r){if(r&&r.isTexture){const a=r.mapping,g=a===Br||a===cr,I=a===sn||a===on;if(g||I){let E=A.get(r);const C=E!==void 0?E.texture.pmremVersion:0;if(r.isRenderTargetTexture&&r.pmremVersion!==C)return e===null&&(e=new Og(i)),E=g?e.fromEquirectangular(r,E):e.fromCubemap(r,E),E.texture.pmremVersion=r.pmremVersion,A.set(r,E),E.texture;if(E!==void 0)return E.texture;{const Q=r.image;return g&&Q&&Q.height>0||I&&Q&&n(Q)?(e===null&&(e=new Og(i)),E=g?e.fromEquirectangular(r):e.fromCubemap(r),E.texture.pmremVersion=r.pmremVersion,A.set(r,E),r.addEventListener("dispose",s),E.texture):null}}}return r}function n(r){let a=0;const g=6;for(let I=0;I<g;I++)r[I]!==void 0&&a++;return a===g}function s(r){const a=r.target;a.removeEventListener("dispose",s);const g=A.get(a);g!==void 0&&(A.delete(a),g.dispose())}function o(){A=new WeakMap,e!==null&&(e.dispose(),e=null)}return{get:t,dispose:o}}function Id(i){const A={};function e(t){if(A[t]!==void 0)return A[t];let n;switch(t){case"WEBGL_depth_texture":n=i.getExtension("WEBGL_depth_texture")||i.getExtension("MOZ_WEBGL_depth_texture")||i.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":n=i.getExtension("EXT_texture_filter_anisotropic")||i.getExtension("MOZ_EXT_texture_filter_anisotropic")||i.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":n=i.getExtension("WEBGL_compressed_texture_s3tc")||i.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||i.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":n=i.getExtension("WEBGL_compressed_texture_pvrtc")||i.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:n=i.getExtension(t)}return A[t]=n,n}return{has:function(t){return e(t)!==null},init:function(){e("EXT_color_buffer_float"),e("WEBGL_clip_cull_distance"),e("OES_texture_float_linear"),e("EXT_color_buffer_half_float"),e("WEBGL_multisampled_render_to_texture"),e("WEBGL_render_shared_exponent")},get:function(t){const n=e(t);return n===null&&Xi("THREE.WebGLRenderer: "+t+" extension not supported."),n}}}function Ed(i,A,e,t){const n={},s=new WeakMap;function o(E){const C=E.target;C.index!==null&&A.remove(C.index);for(const h in C.attributes)A.remove(C.attributes[h]);C.removeEventListener("dispose",o),delete n[C.id];const Q=s.get(C);Q&&(A.remove(Q),s.delete(C)),t.releaseStatesOfGeometry(C),C.isInstancedBufferGeometry===!0&&delete C._maxInstanceCount,e.memory.geometries--}function r(E,C){return n[C.id]===!0||(C.addEventListener("dispose",o),n[C.id]=!0,e.memory.geometries++),C}function a(E){const C=E.attributes;for(const Q in C)A.update(C[Q],i.ARRAY_BUFFER)}function g(E){const C=[],Q=E.index,h=E.attributes.position;let l=0;if(Q!==null){const R=Q.array;l=Q.version;for(let p=0,d=R.length;p<d;p+=3){const w=R[p+0],S=R[p+1],F=R[p+2];C.push(w,S,S,F,F,w)}}else if(h!==void 0){const R=h.array;l=h.version;for(let p=0,d=R.length/3-1;p<d;p+=3){const w=p+0,S=p+1,F=p+2;C.push(w,S,S,F,F,w)}}else return;const B=new(uE(C)?yE:mE)(C,1);B.version=l;const c=s.get(E);c&&A.remove(c),s.set(E,B)}function I(E){const C=s.get(E);if(C){const Q=E.index;Q!==null&&C.version<Q.version&&g(E)}else g(E);return s.get(E)}return{get:r,update:a,getWireframeAttribute:I}}function Cd(i,A,e){let t;function n(C){t=C}let s,o;function r(C){s=C.type,o=C.bytesPerElement}function a(C,Q){i.drawElements(t,Q,s,C*o),e.update(Q,t,1)}function g(C,Q,h){h!==0&&(i.drawElementsInstanced(t,Q,s,C*o,h),e.update(Q,t,h))}function I(C,Q,h){if(h===0)return;A.get("WEBGL_multi_draw").multiDrawElementsWEBGL(t,Q,0,s,C,0,h);let B=0;for(let c=0;c<h;c++)B+=Q[c];e.update(B,t,1)}function E(C,Q,h,l){if(h===0)return;const B=A.get("WEBGL_multi_draw");if(B===null)for(let c=0;c<C.length;c++)g(C[c]/o,Q[c],l[c]);else{B.multiDrawElementsInstancedWEBGL(t,Q,0,s,C,0,l,0,h);let c=0;for(let R=0;R<h;R++)c+=Q[R]*l[R];e.update(c,t,1)}}this.setMode=n,this.setIndex=r,this.render=a,this.renderInstances=g,this.renderMultiDraw=I,this.renderMultiDrawInstances=E}function Qd(i){const A={geometries:0,textures:0},e={frame:0,calls:0,triangles:0,points:0,lines:0};function t(s,o,r){switch(e.calls++,o){case i.TRIANGLES:e.triangles+=r*(s/3);break;case i.LINES:e.lines+=r*(s/2);break;case i.LINE_STRIP:e.lines+=r*(s-1);break;case i.LINE_LOOP:e.lines+=r*s;break;case i.POINTS:e.points+=r*s;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",o);break}}function n(){e.calls=0,e.triangles=0,e.points=0,e.lines=0}return{memory:A,render:e,programs:null,autoReset:!0,reset:n,update:t}}function Bd(i,A,e){const t=new WeakMap,n=new YA;function s(o,r,a){const g=o.morphTargetInfluences,I=r.morphAttributes.position||r.morphAttributes.normal||r.morphAttributes.color,E=I!==void 0?I.length:0;let C=t.get(r);if(C===void 0||C.count!==E){let u=function(){F.dispose(),t.delete(r),r.removeEventListener("dispose",u)};C!==void 0&&C.texture.dispose();const Q=r.morphAttributes.position!==void 0,h=r.morphAttributes.normal!==void 0,l=r.morphAttributes.color!==void 0,B=r.morphAttributes.position||[],c=r.morphAttributes.normal||[],R=r.morphAttributes.color||[];let p=0;Q===!0&&(p=1),h===!0&&(p=2),l===!0&&(p=3);let d=r.attributes.position.count*p,w=1;d>A.maxTextureSize&&(w=Math.ceil(d/A.maxTextureSize),d=A.maxTextureSize);const S=new Float32Array(d*w*4*E),F=new pE(S,d,w,E);F.type=lt,F.needsUpdate=!0;const N=p*4;for(let f=0;f<E;f++){const m=B[f],T=c[f],M=R[f],_=d*w*4*f;for(let P=0;P<m.count;P++){const b=P*N;Q===!0&&(n.fromBufferAttribute(m,P),S[_+b+0]=n.x,S[_+b+1]=n.y,S[_+b+2]=n.z,S[_+b+3]=0),h===!0&&(n.fromBufferAttribute(T,P),S[_+b+4]=n.x,S[_+b+5]=n.y,S[_+b+6]=n.z,S[_+b+7]=0),l===!0&&(n.fromBufferAttribute(M,P),S[_+b+8]=n.x,S[_+b+9]=n.y,S[_+b+10]=n.z,S[_+b+11]=M.itemSize===4?n.w:1)}}C={count:E,texture:F,size:new bA(d,w)},t.set(r,C),r.addEventListener("dispose",u)}if(o.isInstancedMesh===!0&&o.morphTexture!==null)a.getUniforms().setValue(i,"morphTexture",o.morphTexture,e);else{let Q=0;for(let l=0;l<g.length;l++)Q+=g[l];const h=r.morphTargetsRelative?1:1-Q;a.getUniforms().setValue(i,"morphTargetBaseInfluence",h),a.getUniforms().setValue(i,"morphTargetInfluences",g)}a.getUniforms().setValue(i,"morphTargetsTexture",C.texture,e),a.getUniforms().setValue(i,"morphTargetsTextureSize",C.size)}return{update:s}}function cd(i,A,e,t){let n=new WeakMap;function s(a){const g=t.render.frame,I=a.geometry,E=A.get(a,I);if(n.get(E)!==g&&(A.update(E),n.set(E,g)),a.isInstancedMesh&&(a.hasEventListener("dispose",r)===!1&&a.addEventListener("dispose",r),n.get(a)!==g&&(e.update(a.instanceMatrix,i.ARRAY_BUFFER),a.instanceColor!==null&&e.update(a.instanceColor,i.ARRAY_BUFFER),n.set(a,g))),a.isSkinnedMesh){const C=a.skeleton;n.get(C)!==g&&(C.update(),n.set(C,g))}return E}function o(){n=new WeakMap}function r(a){const g=a.target;g.removeEventListener("dispose",r),e.remove(g.instanceMatrix),g.instanceColor!==null&&e.remove(g.instanceColor)}return{update:s,dispose:o}}const HE=new de,qg=new _E(1,1),PE=new pE,OE=new gB,JE=new ME,Wg=[],Vg=[],zg=new Float32Array(16),Xg=new Float32Array(9),Zg=new Float32Array(4);function ln(i,A,e){const t=i[0];if(t<=0||t>0)return i;const n=A*e;let s=Wg[n];if(s===void 0&&(s=new Float32Array(n),Wg[n]=s),A!==0){t.toArray(s,0);for(let o=1,r=0;o!==A;++o)r+=e,i[o].toArray(s,r)}return s}function me(i,A){if(i.length!==A.length)return!1;for(let e=0,t=i.length;e<t;e++)if(i[e]!==A[e])return!1;return!0}function ye(i,A){for(let e=0,t=A.length;e<t;e++)i[e]=A[e]}function no(i,A){let e=Vg[A];e===void 0&&(e=new Int32Array(A),Vg[A]=e);for(let t=0;t!==A;++t)e[t]=i.allocateTextureUnit();return e}function hd(i,A){const e=this.cache;e[0]!==A&&(i.uniform1f(this.addr,A),e[0]=A)}function ld(i,A){const e=this.cache;if(A.x!==void 0)(e[0]!==A.x||e[1]!==A.y)&&(i.uniform2f(this.addr,A.x,A.y),e[0]=A.x,e[1]=A.y);else{if(me(e,A))return;i.uniform2fv(this.addr,A),ye(e,A)}}function dd(i,A){const e=this.cache;if(A.x!==void 0)(e[0]!==A.x||e[1]!==A.y||e[2]!==A.z)&&(i.uniform3f(this.addr,A.x,A.y,A.z),e[0]=A.x,e[1]=A.y,e[2]=A.z);else if(A.r!==void 0)(e[0]!==A.r||e[1]!==A.g||e[2]!==A.b)&&(i.uniform3f(this.addr,A.r,A.g,A.b),e[0]=A.r,e[1]=A.g,e[2]=A.b);else{if(me(e,A))return;i.uniform3fv(this.addr,A),ye(e,A)}}function ud(i,A){const e=this.cache;if(A.x!==void 0)(e[0]!==A.x||e[1]!==A.y||e[2]!==A.z||e[3]!==A.w)&&(i.uniform4f(this.addr,A.x,A.y,A.z,A.w),e[0]=A.x,e[1]=A.y,e[2]=A.z,e[3]=A.w);else{if(me(e,A))return;i.uniform4fv(this.addr,A),ye(e,A)}}function fd(i,A){const e=this.cache,t=A.elements;if(t===void 0){if(me(e,A))return;i.uniformMatrix2fv(this.addr,!1,A),ye(e,A)}else{if(me(e,t))return;Zg.set(t),i.uniformMatrix2fv(this.addr,!1,Zg),ye(e,t)}}function pd(i,A){const e=this.cache,t=A.elements;if(t===void 0){if(me(e,A))return;i.uniformMatrix3fv(this.addr,!1,A),ye(e,A)}else{if(me(e,t))return;Xg.set(t),i.uniformMatrix3fv(this.addr,!1,Xg),ye(e,t)}}function Dd(i,A){const e=this.cache,t=A.elements;if(t===void 0){if(me(e,A))return;i.uniformMatrix4fv(this.addr,!1,A),ye(e,A)}else{if(me(e,t))return;zg.set(t),i.uniformMatrix4fv(this.addr,!1,zg),ye(e,t)}}function md(i,A){const e=this.cache;e[0]!==A&&(i.uniform1i(this.addr,A),e[0]=A)}function yd(i,A){const e=this.cache;if(A.x!==void 0)(e[0]!==A.x||e[1]!==A.y)&&(i.uniform2i(this.addr,A.x,A.y),e[0]=A.x,e[1]=A.y);else{if(me(e,A))return;i.uniform2iv(this.addr,A),ye(e,A)}}function Rd(i,A){const e=this.cache;if(A.x!==void 0)(e[0]!==A.x||e[1]!==A.y||e[2]!==A.z)&&(i.uniform3i(this.addr,A.x,A.y,A.z),e[0]=A.x,e[1]=A.y,e[2]=A.z);else{if(me(e,A))return;i.uniform3iv(this.addr,A),ye(e,A)}}function wd(i,A){const e=this.cache;if(A.x!==void 0)(e[0]!==A.x||e[1]!==A.y||e[2]!==A.z||e[3]!==A.w)&&(i.uniform4i(this.addr,A.x,A.y,A.z,A.w),e[0]=A.x,e[1]=A.y,e[2]=A.z,e[3]=A.w);else{if(me(e,A))return;i.uniform4iv(this.addr,A),ye(e,A)}}function Sd(i,A){const e=this.cache;e[0]!==A&&(i.uniform1ui(this.addr,A),e[0]=A)}function Md(i,A){const e=this.cache;if(A.x!==void 0)(e[0]!==A.x||e[1]!==A.y)&&(i.uniform2ui(this.addr,A.x,A.y),e[0]=A.x,e[1]=A.y);else{if(me(e,A))return;i.uniform2uiv(this.addr,A),ye(e,A)}}function Nd(i,A){const e=this.cache;if(A.x!==void 0)(e[0]!==A.x||e[1]!==A.y||e[2]!==A.z)&&(i.uniform3ui(this.addr,A.x,A.y,A.z),e[0]=A.x,e[1]=A.y,e[2]=A.z);else{if(me(e,A))return;i.uniform3uiv(this.addr,A),ye(e,A)}}function xd(i,A){const e=this.cache;if(A.x!==void 0)(e[0]!==A.x||e[1]!==A.y||e[2]!==A.z||e[3]!==A.w)&&(i.uniform4ui(this.addr,A.x,A.y,A.z,A.w),e[0]=A.x,e[1]=A.y,e[2]=A.z,e[3]=A.w);else{if(me(e,A))return;i.uniform4uiv(this.addr,A),ye(e,A)}}function Fd(i,A,e){const t=this.cache,n=e.allocateTextureUnit();t[0]!==n&&(i.uniform1i(this.addr,n),t[0]=n);let s;this.type===i.SAMPLER_2D_SHADOW?(qg.compareFunction=dE,s=qg):s=HE,e.setTexture2D(A||s,n)}function Ld(i,A,e){const t=this.cache,n=e.allocateTextureUnit();t[0]!==n&&(i.uniform1i(this.addr,n),t[0]=n),e.setTexture3D(A||OE,n)}function _d(i,A,e){const t=this.cache,n=e.allocateTextureUnit();t[0]!==n&&(i.uniform1i(this.addr,n),t[0]=n),e.setTextureCube(A||JE,n)}function Ud(i,A,e){const t=this.cache,n=e.allocateTextureUnit();t[0]!==n&&(i.uniform1i(this.addr,n),t[0]=n),e.setTexture2DArray(A||PE,n)}function Gd(i){switch(i){case 5126:return hd;case 35664:return ld;case 35665:return dd;case 35666:return ud;case 35674:return fd;case 35675:return pd;case 35676:return Dd;case 5124:case 35670:return md;case 35667:case 35671:return yd;case 35668:case 35672:return Rd;case 35669:case 35673:return wd;case 5125:return Sd;case 36294:return Md;case 36295:return Nd;case 36296:return xd;case 35678:case 36198:case 36298:case 36306:case 35682:return Fd;case 35679:case 36299:case 36307:return Ld;case 35680:case 36300:case 36308:case 36293:return _d;case 36289:case 36303:case 36311:case 36292:return Ud}}function vd(i,A){i.uniform1fv(this.addr,A)}function Td(i,A){const e=ln(A,this.size,2);i.uniform2fv(this.addr,e)}function bd(i,A){const e=ln(A,this.size,3);i.uniform3fv(this.addr,e)}function kd(i,A){const e=ln(A,this.size,4);i.uniform4fv(this.addr,e)}function Hd(i,A){const e=ln(A,this.size,4);i.uniformMatrix2fv(this.addr,!1,e)}function Pd(i,A){const e=ln(A,this.size,9);i.uniformMatrix3fv(this.addr,!1,e)}function Od(i,A){const e=ln(A,this.size,16);i.uniformMatrix4fv(this.addr,!1,e)}function Jd(i,A){i.uniform1iv(this.addr,A)}function Kd(i,A){i.uniform2iv(this.addr,A)}function Yd(i,A){i.uniform3iv(this.addr,A)}function qd(i,A){i.uniform4iv(this.addr,A)}function Wd(i,A){i.uniform1uiv(this.addr,A)}function Vd(i,A){i.uniform2uiv(this.addr,A)}function zd(i,A){i.uniform3uiv(this.addr,A)}function Xd(i,A){i.uniform4uiv(this.addr,A)}function Zd(i,A,e){const t=this.cache,n=A.length,s=no(e,n);me(t,s)||(i.uniform1iv(this.addr,s),ye(t,s));for(let o=0;o!==n;++o)e.setTexture2D(A[o]||HE,s[o])}function jd(i,A,e){const t=this.cache,n=A.length,s=no(e,n);me(t,s)||(i.uniform1iv(this.addr,s),ye(t,s));for(let o=0;o!==n;++o)e.setTexture3D(A[o]||OE,s[o])}function $d(i,A,e){const t=this.cache,n=A.length,s=no(e,n);me(t,s)||(i.uniform1iv(this.addr,s),ye(t,s));for(let o=0;o!==n;++o)e.setTextureCube(A[o]||JE,s[o])}function Au(i,A,e){const t=this.cache,n=A.length,s=no(e,n);me(t,s)||(i.uniform1iv(this.addr,s),ye(t,s));for(let o=0;o!==n;++o)e.setTexture2DArray(A[o]||PE,s[o])}function eu(i){switch(i){case 5126:return vd;case 35664:return Td;case 35665:return bd;case 35666:return kd;case 35674:return Hd;case 35675:return Pd;case 35676:return Od;case 5124:case 35670:return Jd;case 35667:case 35671:return Kd;case 35668:case 35672:return Yd;case 35669:case 35673:return qd;case 5125:return Wd;case 36294:return Vd;case 36295:return zd;case 36296:return Xd;case 35678:case 36198:case 36298:case 36306:case 35682:return Zd;case 35679:case 36299:case 36307:return jd;case 35680:case 36300:case 36308:case 36293:return $d;case 36289:case 36303:case 36311:case 36292:return Au}}class tu{constructor(A,e,t){this.id=A,this.addr=t,this.cache=[],this.type=e.type,this.setValue=Gd(e.type)}}class iu{constructor(A,e,t){this.id=A,this.addr=t,this.cache=[],this.type=e.type,this.size=e.size,this.setValue=eu(e.type)}}class nu{constructor(A){this.id=A,this.seq=[],this.map={}}setValue(A,e,t){const n=this.seq;for(let s=0,o=n.length;s!==o;++s){const r=n[s];r.setValue(A,e[r.id],t)}}}const Oo=/(\w+)(\])?(\[|\.)?/g;function jg(i,A){i.seq.push(A),i.map[A.id]=A}function su(i,A,e){const t=i.name,n=t.length;for(Oo.lastIndex=0;;){const s=Oo.exec(t),o=Oo.lastIndex;let r=s[1];const a=s[2]==="]",g=s[3];if(a&&(r=r|0),g===void 0||g==="["&&o+2===n){jg(e,g===void 0?new tu(r,i,A):new iu(r,i,A));break}else{let E=e.map[r];E===void 0&&(E=new nu(r),jg(e,E)),e=E}}}class bs{constructor(A,e){this.seq=[],this.map={};const t=A.getProgramParameter(e,A.ACTIVE_UNIFORMS);for(let n=0;n<t;++n){const s=A.getActiveUniform(e,n),o=A.getUniformLocation(e,s.name);su(s,o,this)}}setValue(A,e,t,n){const s=this.map[e];s!==void 0&&s.setValue(A,t,n)}setOptional(A,e,t){const n=e[t];n!==void 0&&this.setValue(A,t,n)}static upload(A,e,t,n){for(let s=0,o=e.length;s!==o;++s){const r=e[s],a=t[r.id];a.needsUpdate!==!1&&r.setValue(A,a.value,n)}}static seqWithValue(A,e){const t=[];for(let n=0,s=A.length;n!==s;++n){const o=A[n];o.id in e&&t.push(o)}return t}}function $g(i,A,e){const t=i.createShader(A);return i.shaderSource(t,e),i.compileShader(t),t}const ou=37297;let ru=0;function au(i,A){const e=i.split(`
`),t=[],n=Math.max(A-6,0),s=Math.min(A+6,e.length);for(let o=n;o<s;o++){const r=o+1;t.push(`${r===A?">":" "} ${r}: ${e[o]}`)}return t.join(`
`)}const AI=new PA;function gu(i){$A._getMatrix(AI,$A.workingColorSpace,i);const A=`mat3( ${AI.elements.map(e=>e.toFixed(4))} )`;switch($A.getTransfer(i)){case Ks:return[A,"LinearTransferOETF"];case ge:return[A,"sRGBTransferOETF"];default:return console.warn("THREE.WebGLProgram: Unsupported color space: ",i),[A,"LinearTransferOETF"]}}function eI(i,A,e){const t=i.getShaderParameter(A,i.COMPILE_STATUS),n=i.getShaderInfoLog(A).trim();if(t&&n==="")return"";const s=/ERROR: 0:(\d+)/.exec(n);if(s){const o=parseInt(s[1]);return e.toUpperCase()+`

`+n+`

`+au(i.getShaderSource(A),o)}else return n}function Iu(i,A){const e=gu(A);return[`vec4 ${i}( vec4 value ) {`,`	return ${e[1]}( vec4( value.rgb * ${e[0]}, value.a ) );`,"}"].join(`
`)}function Eu(i,A){let e;switch(A){case lQ:e="Linear";break;case dQ:e="Reinhard";break;case uQ:e="Cineon";break;case fQ:e="ACESFilmic";break;case DQ:e="AgX";break;case mQ:e="Neutral";break;case pQ:e="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",A),e="Linear"}return"vec3 "+i+"( vec3 color ) { return "+e+"ToneMapping( color ); }"}const Rs=new L;function Cu(){$A.getLuminanceCoefficients(Rs);const i=Rs.x.toFixed(4),A=Rs.y.toFixed(4),e=Rs.z.toFixed(4);return["float luminance( const in vec3 rgb ) {",`	const vec3 weights = vec3( ${i}, ${A}, ${e} );`,"	return dot( weights, rgb );","}"].join(`
`)}function Qu(i){return[i.extensionClipCullDistance?"#extension GL_ANGLE_clip_cull_distance : require":"",i.extensionMultiDraw?"#extension GL_ANGLE_multi_draw : require":""].filter(Fn).join(`
`)}function Bu(i){const A=[];for(const e in i){const t=i[e];t!==!1&&A.push("#define "+e+" "+t)}return A.join(`
`)}function cu(i,A){const e={},t=i.getProgramParameter(A,i.ACTIVE_ATTRIBUTES);for(let n=0;n<t;n++){const s=i.getActiveAttrib(A,n),o=s.name;let r=1;s.type===i.FLOAT_MAT2&&(r=2),s.type===i.FLOAT_MAT3&&(r=3),s.type===i.FLOAT_MAT4&&(r=4),e[o]={type:s.type,location:i.getAttribLocation(A,o),locationSize:r}}return e}function Fn(i){return i!==""}function tI(i,A){const e=A.numSpotLightShadows+A.numSpotLightMaps-A.numSpotLightShadowsWithMaps;return i.replace(/NUM_DIR_LIGHTS/g,A.numDirLights).replace(/NUM_SPOT_LIGHTS/g,A.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g,A.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g,e).replace(/NUM_RECT_AREA_LIGHTS/g,A.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,A.numPointLights).replace(/NUM_HEMI_LIGHTS/g,A.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,A.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g,A.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g,A.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,A.numPointLightShadows)}function iI(i,A){return i.replace(/NUM_CLIPPING_PLANES/g,A.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,A.numClippingPlanes-A.numClipIntersection)}const hu=/^[ \t]*#include +<([\w\d./]+)>/gm;function Wr(i){return i.replace(hu,du)}const lu=new Map;function du(i,A){let e=OA[A];if(e===void 0){const t=lu.get(A);if(t!==void 0)e=OA[t],console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',A,t);else throw new Error("Can not resolve #include <"+A+">")}return Wr(e)}const uu=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function nI(i){return i.replace(uu,fu)}function fu(i,A,e,t){let n="";for(let s=parseInt(A);s<parseInt(e);s++)n+=t.replace(/\[\s*i\s*\]/g,"[ "+s+" ]").replace(/UNROLLED_LOOP_INDEX/g,s);return n}function sI(i){let A=`precision ${i.precision} float;
	precision ${i.precision} int;
	precision ${i.precision} sampler2D;
	precision ${i.precision} samplerCube;
	precision ${i.precision} sampler3D;
	precision ${i.precision} sampler2DArray;
	precision ${i.precision} sampler2DShadow;
	precision ${i.precision} samplerCubeShadow;
	precision ${i.precision} sampler2DArrayShadow;
	precision ${i.precision} isampler2D;
	precision ${i.precision} isampler3D;
	precision ${i.precision} isamplerCube;
	precision ${i.precision} isampler2DArray;
	precision ${i.precision} usampler2D;
	precision ${i.precision} usampler3D;
	precision ${i.precision} usamplerCube;
	precision ${i.precision} usampler2DArray;
	`;return i.precision==="highp"?A+=`
#define HIGH_PRECISION`:i.precision==="mediump"?A+=`
#define MEDIUM_PRECISION`:i.precision==="lowp"&&(A+=`
#define LOW_PRECISION`),A}function pu(i){let A="SHADOWMAP_TYPE_BASIC";return i.shadowMapType===nE?A="SHADOWMAP_TYPE_PCF":i.shadowMapType===XC?A="SHADOWMAP_TYPE_PCF_SOFT":i.shadowMapType===Tt&&(A="SHADOWMAP_TYPE_VSM"),A}function Du(i){let A="ENVMAP_TYPE_CUBE";if(i.envMap)switch(i.envMapMode){case sn:case on:A="ENVMAP_TYPE_CUBE";break;case eo:A="ENVMAP_TYPE_CUBE_UV";break}return A}function mu(i){let A="ENVMAP_MODE_REFLECTION";if(i.envMap)switch(i.envMapMode){case on:A="ENVMAP_MODE_REFRACTION";break}return A}function yu(i){let A="ENVMAP_BLENDING_NONE";if(i.envMap)switch(i.combine){case sE:A="ENVMAP_BLENDING_MULTIPLY";break;case cQ:A="ENVMAP_BLENDING_MIX";break;case hQ:A="ENVMAP_BLENDING_ADD";break}return A}function Ru(i){const A=i.envMapCubeUVHeight;if(A===null)return null;const e=Math.log2(A)-2,t=1/A;return{texelWidth:1/(3*Math.max(Math.pow(2,e),112)),texelHeight:t,maxMip:e}}function wu(i,A,e,t){const n=i.getContext(),s=e.defines;let o=e.vertexShader,r=e.fragmentShader;const a=pu(e),g=Du(e),I=mu(e),E=yu(e),C=Ru(e),Q=Qu(e),h=Bu(s),l=n.createProgram();let B,c,R=e.glslVersion?"#version "+e.glslVersion+`
`:"";e.isRawShaderMaterial?(B=["#define SHADER_TYPE "+e.shaderType,"#define SHADER_NAME "+e.shaderName,h].filter(Fn).join(`
`),B.length>0&&(B+=`
`),c=["#define SHADER_TYPE "+e.shaderType,"#define SHADER_NAME "+e.shaderName,h].filter(Fn).join(`
`),c.length>0&&(c+=`
`)):(B=[sI(e),"#define SHADER_TYPE "+e.shaderType,"#define SHADER_NAME "+e.shaderName,h,e.extensionClipCullDistance?"#define USE_CLIP_DISTANCE":"",e.batching?"#define USE_BATCHING":"",e.batchingColor?"#define USE_BATCHING_COLOR":"",e.instancing?"#define USE_INSTANCING":"",e.instancingColor?"#define USE_INSTANCING_COLOR":"",e.instancingMorph?"#define USE_INSTANCING_MORPH":"",e.useFog&&e.fog?"#define USE_FOG":"",e.useFog&&e.fogExp2?"#define FOG_EXP2":"",e.map?"#define USE_MAP":"",e.envMap?"#define USE_ENVMAP":"",e.envMap?"#define "+I:"",e.lightMap?"#define USE_LIGHTMAP":"",e.aoMap?"#define USE_AOMAP":"",e.bumpMap?"#define USE_BUMPMAP":"",e.normalMap?"#define USE_NORMALMAP":"",e.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",e.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",e.displacementMap?"#define USE_DISPLACEMENTMAP":"",e.emissiveMap?"#define USE_EMISSIVEMAP":"",e.anisotropy?"#define USE_ANISOTROPY":"",e.anisotropyMap?"#define USE_ANISOTROPYMAP":"",e.clearcoatMap?"#define USE_CLEARCOATMAP":"",e.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",e.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",e.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",e.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",e.specularMap?"#define USE_SPECULARMAP":"",e.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",e.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",e.roughnessMap?"#define USE_ROUGHNESSMAP":"",e.metalnessMap?"#define USE_METALNESSMAP":"",e.alphaMap?"#define USE_ALPHAMAP":"",e.alphaHash?"#define USE_ALPHAHASH":"",e.transmission?"#define USE_TRANSMISSION":"",e.transmissionMap?"#define USE_TRANSMISSIONMAP":"",e.thicknessMap?"#define USE_THICKNESSMAP":"",e.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",e.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",e.mapUv?"#define MAP_UV "+e.mapUv:"",e.alphaMapUv?"#define ALPHAMAP_UV "+e.alphaMapUv:"",e.lightMapUv?"#define LIGHTMAP_UV "+e.lightMapUv:"",e.aoMapUv?"#define AOMAP_UV "+e.aoMapUv:"",e.emissiveMapUv?"#define EMISSIVEMAP_UV "+e.emissiveMapUv:"",e.bumpMapUv?"#define BUMPMAP_UV "+e.bumpMapUv:"",e.normalMapUv?"#define NORMALMAP_UV "+e.normalMapUv:"",e.displacementMapUv?"#define DISPLACEMENTMAP_UV "+e.displacementMapUv:"",e.metalnessMapUv?"#define METALNESSMAP_UV "+e.metalnessMapUv:"",e.roughnessMapUv?"#define ROUGHNESSMAP_UV "+e.roughnessMapUv:"",e.anisotropyMapUv?"#define ANISOTROPYMAP_UV "+e.anisotropyMapUv:"",e.clearcoatMapUv?"#define CLEARCOATMAP_UV "+e.clearcoatMapUv:"",e.clearcoatNormalMapUv?"#define CLEARCOAT_NORMALMAP_UV "+e.clearcoatNormalMapUv:"",e.clearcoatRoughnessMapUv?"#define CLEARCOAT_ROUGHNESSMAP_UV "+e.clearcoatRoughnessMapUv:"",e.iridescenceMapUv?"#define IRIDESCENCEMAP_UV "+e.iridescenceMapUv:"",e.iridescenceThicknessMapUv?"#define IRIDESCENCE_THICKNESSMAP_UV "+e.iridescenceThicknessMapUv:"",e.sheenColorMapUv?"#define SHEEN_COLORMAP_UV "+e.sheenColorMapUv:"",e.sheenRoughnessMapUv?"#define SHEEN_ROUGHNESSMAP_UV "+e.sheenRoughnessMapUv:"",e.specularMapUv?"#define SPECULARMAP_UV "+e.specularMapUv:"",e.specularColorMapUv?"#define SPECULAR_COLORMAP_UV "+e.specularColorMapUv:"",e.specularIntensityMapUv?"#define SPECULAR_INTENSITYMAP_UV "+e.specularIntensityMapUv:"",e.transmissionMapUv?"#define TRANSMISSIONMAP_UV "+e.transmissionMapUv:"",e.thicknessMapUv?"#define THICKNESSMAP_UV "+e.thicknessMapUv:"",e.vertexTangents&&e.flatShading===!1?"#define USE_TANGENT":"",e.vertexColors?"#define USE_COLOR":"",e.vertexAlphas?"#define USE_COLOR_ALPHA":"",e.vertexUv1s?"#define USE_UV1":"",e.vertexUv2s?"#define USE_UV2":"",e.vertexUv3s?"#define USE_UV3":"",e.pointsUvs?"#define USE_POINTS_UV":"",e.flatShading?"#define FLAT_SHADED":"",e.skinning?"#define USE_SKINNING":"",e.morphTargets?"#define USE_MORPHTARGETS":"",e.morphNormals&&e.flatShading===!1?"#define USE_MORPHNORMALS":"",e.morphColors?"#define USE_MORPHCOLORS":"",e.morphTargetsCount>0?"#define MORPHTARGETS_TEXTURE_STRIDE "+e.morphTextureStride:"",e.morphTargetsCount>0?"#define MORPHTARGETS_COUNT "+e.morphTargetsCount:"",e.doubleSided?"#define DOUBLE_SIDED":"",e.flipSided?"#define FLIP_SIDED":"",e.shadowMapEnabled?"#define USE_SHADOWMAP":"",e.shadowMapEnabled?"#define "+a:"",e.sizeAttenuation?"#define USE_SIZEATTENUATION":"",e.numLightProbes>0?"#define USE_LIGHT_PROBES":"",e.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",e.reverseDepthBuffer?"#define USE_REVERSEDEPTHBUF":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","	attribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","	attribute vec3 instanceColor;","#endif","#ifdef USE_INSTANCING_MORPH","	uniform sampler2D morphTexture;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_UV1","	attribute vec2 uv1;","#endif","#ifdef USE_UV2","	attribute vec2 uv2;","#endif","#ifdef USE_UV3","	attribute vec2 uv3;","#endif","#ifdef USE_TANGENT","	attribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","	attribute vec4 color;","#elif defined( USE_COLOR )","	attribute vec3 color;","#endif","#ifdef USE_SKINNING","	attribute vec4 skinIndex;","	attribute vec4 skinWeight;","#endif",`
`].filter(Fn).join(`
`),c=[sI(e),"#define SHADER_TYPE "+e.shaderType,"#define SHADER_NAME "+e.shaderName,h,e.useFog&&e.fog?"#define USE_FOG":"",e.useFog&&e.fogExp2?"#define FOG_EXP2":"",e.alphaToCoverage?"#define ALPHA_TO_COVERAGE":"",e.map?"#define USE_MAP":"",e.matcap?"#define USE_MATCAP":"",e.envMap?"#define USE_ENVMAP":"",e.envMap?"#define "+g:"",e.envMap?"#define "+I:"",e.envMap?"#define "+E:"",C?"#define CUBEUV_TEXEL_WIDTH "+C.texelWidth:"",C?"#define CUBEUV_TEXEL_HEIGHT "+C.texelHeight:"",C?"#define CUBEUV_MAX_MIP "+C.maxMip+".0":"",e.lightMap?"#define USE_LIGHTMAP":"",e.aoMap?"#define USE_AOMAP":"",e.bumpMap?"#define USE_BUMPMAP":"",e.normalMap?"#define USE_NORMALMAP":"",e.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",e.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",e.emissiveMap?"#define USE_EMISSIVEMAP":"",e.anisotropy?"#define USE_ANISOTROPY":"",e.anisotropyMap?"#define USE_ANISOTROPYMAP":"",e.clearcoat?"#define USE_CLEARCOAT":"",e.clearcoatMap?"#define USE_CLEARCOATMAP":"",e.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",e.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",e.dispersion?"#define USE_DISPERSION":"",e.iridescence?"#define USE_IRIDESCENCE":"",e.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",e.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",e.specularMap?"#define USE_SPECULARMAP":"",e.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",e.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",e.roughnessMap?"#define USE_ROUGHNESSMAP":"",e.metalnessMap?"#define USE_METALNESSMAP":"",e.alphaMap?"#define USE_ALPHAMAP":"",e.alphaTest?"#define USE_ALPHATEST":"",e.alphaHash?"#define USE_ALPHAHASH":"",e.sheen?"#define USE_SHEEN":"",e.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",e.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",e.transmission?"#define USE_TRANSMISSION":"",e.transmissionMap?"#define USE_TRANSMISSIONMAP":"",e.thicknessMap?"#define USE_THICKNESSMAP":"",e.vertexTangents&&e.flatShading===!1?"#define USE_TANGENT":"",e.vertexColors||e.instancingColor||e.batchingColor?"#define USE_COLOR":"",e.vertexAlphas?"#define USE_COLOR_ALPHA":"",e.vertexUv1s?"#define USE_UV1":"",e.vertexUv2s?"#define USE_UV2":"",e.vertexUv3s?"#define USE_UV3":"",e.pointsUvs?"#define USE_POINTS_UV":"",e.gradientMap?"#define USE_GRADIENTMAP":"",e.flatShading?"#define FLAT_SHADED":"",e.doubleSided?"#define DOUBLE_SIDED":"",e.flipSided?"#define FLIP_SIDED":"",e.shadowMapEnabled?"#define USE_SHADOWMAP":"",e.shadowMapEnabled?"#define "+a:"",e.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",e.numLightProbes>0?"#define USE_LIGHT_PROBES":"",e.decodeVideoTexture?"#define DECODE_VIDEO_TEXTURE":"",e.decodeVideoTextureEmissive?"#define DECODE_VIDEO_TEXTURE_EMISSIVE":"",e.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",e.reverseDepthBuffer?"#define USE_REVERSEDEPTHBUF":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",e.toneMapping!==ai?"#define TONE_MAPPING":"",e.toneMapping!==ai?OA.tonemapping_pars_fragment:"",e.toneMapping!==ai?Eu("toneMapping",e.toneMapping):"",e.dithering?"#define DITHERING":"",e.opaque?"#define OPAQUE":"",OA.colorspace_pars_fragment,Iu("linearToOutputTexel",e.outputColorSpace),Cu(),e.useDepthPacking?"#define DEPTH_PACKING "+e.depthPacking:"",`
`].filter(Fn).join(`
`)),o=Wr(o),o=tI(o,e),o=iI(o,e),r=Wr(r),r=tI(r,e),r=iI(r,e),o=nI(o),r=nI(r),e.isRawShaderMaterial!==!0&&(R=`#version 300 es
`,B=[Q,"#define attribute in","#define varying out","#define texture2D texture"].join(`
`)+`
`+B,c=["#define varying in",e.glslVersion===Xa?"":"layout(location = 0) out highp vec4 pc_fragColor;",e.glslVersion===Xa?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join(`
`)+`
`+c);const p=R+B+o,d=R+c+r,w=$g(n,n.VERTEX_SHADER,p),S=$g(n,n.FRAGMENT_SHADER,d);n.attachShader(l,w),n.attachShader(l,S),e.index0AttributeName!==void 0?n.bindAttribLocation(l,0,e.index0AttributeName):e.morphTargets===!0&&n.bindAttribLocation(l,0,"position"),n.linkProgram(l);function F(m){if(i.debug.checkShaderErrors){const T=n.getProgramInfoLog(l).trim(),M=n.getShaderInfoLog(w).trim(),_=n.getShaderInfoLog(S).trim();let P=!0,b=!0;if(n.getProgramParameter(l,n.LINK_STATUS)===!1)if(P=!1,typeof i.debug.onShaderError=="function")i.debug.onShaderError(n,l,w,S);else{const z=eI(n,w,"vertex"),O=eI(n,S,"fragment");console.error("THREE.WebGLProgram: Shader Error "+n.getError()+" - VALIDATE_STATUS "+n.getProgramParameter(l,n.VALIDATE_STATUS)+`

Material Name: `+m.name+`
Material Type: `+m.type+`

Program Info Log: `+T+`
`+z+`
`+O)}else T!==""?console.warn("THREE.WebGLProgram: Program Info Log:",T):(M===""||_==="")&&(b=!1);b&&(m.diagnostics={runnable:P,programLog:T,vertexShader:{log:M,prefix:B},fragmentShader:{log:_,prefix:c}})}n.deleteShader(w),n.deleteShader(S),N=new bs(n,l),u=cu(n,l)}let N;this.getUniforms=function(){return N===void 0&&F(this),N};let u;this.getAttributes=function(){return u===void 0&&F(this),u};let f=e.rendererExtensionParallelShaderCompile===!1;return this.isReady=function(){return f===!1&&(f=n.getProgramParameter(l,ou)),f},this.destroy=function(){t.releaseStatesOfProgram(this),n.deleteProgram(l),this.program=void 0},this.type=e.shaderType,this.name=e.shaderName,this.id=ru++,this.cacheKey=A,this.usedTimes=1,this.program=l,this.vertexShader=w,this.fragmentShader=S,this}let Su=0;class Mu{constructor(){this.shaderCache=new Map,this.materialCache=new Map}update(A){const e=A.vertexShader,t=A.fragmentShader,n=this._getShaderStage(e),s=this._getShaderStage(t),o=this._getShaderCacheForMaterial(A);return o.has(n)===!1&&(o.add(n),n.usedTimes++),o.has(s)===!1&&(o.add(s),s.usedTimes++),this}remove(A){const e=this.materialCache.get(A);for(const t of e)t.usedTimes--,t.usedTimes===0&&this.shaderCache.delete(t.code);return this.materialCache.delete(A),this}getVertexShaderID(A){return this._getShaderStage(A.vertexShader).id}getFragmentShaderID(A){return this._getShaderStage(A.fragmentShader).id}dispose(){this.shaderCache.clear(),this.materialCache.clear()}_getShaderCacheForMaterial(A){const e=this.materialCache;let t=e.get(A);return t===void 0&&(t=new Set,e.set(A,t)),t}_getShaderStage(A){const e=this.shaderCache;let t=e.get(A);return t===void 0&&(t=new Nu(A),e.set(A,t)),t}}class Nu{constructor(A){this.id=Su++,this.code=A,this.usedTimes=0}}function xu(i,A,e,t,n,s,o){const r=new Ba,a=new Mu,g=new Set,I=[],E=n.logarithmicDepthBuffer,C=n.vertexTextures;let Q=n.precision;const h={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"};function l(u){return g.add(u),u===0?"uv":`uv${u}`}function B(u,f,m,T,M){const _=T.fog,P=M.geometry,b=u.isMeshStandardMaterial?T.environment:null,z=(u.isMeshStandardMaterial?e:A).get(u.envMap||b),O=z&&z.mapping===eo?z.image.height:null,eA=h[u.type];u.precision!==null&&(Q=n.getMaxPrecision(u.precision),Q!==u.precision&&console.warn("THREE.WebGLProgram.getParameters:",u.precision,"not supported, using",Q,"instead."));const oA=P.morphAttributes.position||P.morphAttributes.normal||P.morphAttributes.color,gA=oA!==void 0?oA.length:0;let pA=0;P.morphAttributes.position!==void 0&&(pA=1),P.morphAttributes.normal!==void 0&&(pA=2),P.morphAttributes.color!==void 0&&(pA=3);let qA,X,AA,hA;if(eA){const oe=Qt[eA];qA=oe.vertexShader,X=oe.fragmentShader}else qA=u.vertexShader,X=u.fragmentShader,a.update(u),AA=a.getVertexShaderID(u),hA=a.getFragmentShaderID(u);const rA=i.getRenderTarget(),mA=i.state.buffers.depth.getReversed(),LA=M.isInstancedMesh===!0,EA=M.isBatchedMesh===!0,xA=!!u.map,yA=!!u.matcap,WA=!!z,U=!!u.aoMap,ke=!!u.lightMap,VA=!!u.bumpMap,JA=!!u.normalMap,wA=!!u.displacementMap,Ie=!!u.emissiveMap,MA=!!u.metalnessMap,x=!!u.roughnessMap,D=u.anisotropy>0,Y=u.clearcoat>0,$=u.dispersion>0,tA=u.iridescence>0,j=u.sheen>0,RA=u.transmission>0,CA=D&&!!u.anisotropyMap,cA=Y&&!!u.clearcoatMap,ZA=Y&&!!u.clearcoatNormalMap,nA=Y&&!!u.clearcoatRoughnessMap,dA=tA&&!!u.iridescenceMap,NA=tA&&!!u.iridescenceThicknessMap,K=j&&!!u.sheenColorMap,J=j&&!!u.sheenRoughnessMap,lA=!!u.specularMap,uA=!!u.specularColorMap,kA=!!u.specularIntensityMap,v=RA&&!!u.transmissionMap,iA=RA&&!!u.thicknessMap,q=!!u.gradientMap,Z=!!u.alphaMap,IA=u.alphaTest>0,BA=!!u.alphaHash,HA=!!u.extensions;let he=ai;u.toneMapped&&(rA===null||rA.isXRRenderTarget===!0)&&(he=i.toneMapping);const Me={shaderID:eA,shaderType:u.type,shaderName:u.name,vertexShader:qA,fragmentShader:X,defines:u.defines,customVertexShaderID:AA,customFragmentShaderID:hA,isRawShaderMaterial:u.isRawShaderMaterial===!0,glslVersion:u.glslVersion,precision:Q,batching:EA,batchingColor:EA&&M._colorsTexture!==null,instancing:LA,instancingColor:LA&&M.instanceColor!==null,instancingMorph:LA&&M.morphTexture!==null,supportsVertexTextures:C,outputColorSpace:rA===null?i.outputColorSpace:rA.isXRRenderTarget===!0?rA.texture.colorSpace:be,alphaToCoverage:!!u.alphaToCoverage,map:xA,matcap:yA,envMap:WA,envMapMode:WA&&z.mapping,envMapCubeUVHeight:O,aoMap:U,lightMap:ke,bumpMap:VA,normalMap:JA,displacementMap:C&&wA,emissiveMap:Ie,normalMapObjectSpace:JA&&u.normalMapType===NQ,normalMapTangentSpace:JA&&u.normalMapType===Ea,metalnessMap:MA,roughnessMap:x,anisotropy:D,anisotropyMap:CA,clearcoat:Y,clearcoatMap:cA,clearcoatNormalMap:ZA,clearcoatRoughnessMap:nA,dispersion:$,iridescence:tA,iridescenceMap:dA,iridescenceThicknessMap:NA,sheen:j,sheenColorMap:K,sheenRoughnessMap:J,specularMap:lA,specularColorMap:uA,specularIntensityMap:kA,transmission:RA,transmissionMap:v,thicknessMap:iA,gradientMap:q,opaque:u.transparent===!1&&u.blending===Ri&&u.alphaToCoverage===!1,alphaMap:Z,alphaTest:IA,alphaHash:BA,combine:u.combine,mapUv:xA&&l(u.map.channel),aoMapUv:U&&l(u.aoMap.channel),lightMapUv:ke&&l(u.lightMap.channel),bumpMapUv:VA&&l(u.bumpMap.channel),normalMapUv:JA&&l(u.normalMap.channel),displacementMapUv:wA&&l(u.displacementMap.channel),emissiveMapUv:Ie&&l(u.emissiveMap.channel),metalnessMapUv:MA&&l(u.metalnessMap.channel),roughnessMapUv:x&&l(u.roughnessMap.channel),anisotropyMapUv:CA&&l(u.anisotropyMap.channel),clearcoatMapUv:cA&&l(u.clearcoatMap.channel),clearcoatNormalMapUv:ZA&&l(u.clearcoatNormalMap.channel),clearcoatRoughnessMapUv:nA&&l(u.clearcoatRoughnessMap.channel),iridescenceMapUv:dA&&l(u.iridescenceMap.channel),iridescenceThicknessMapUv:NA&&l(u.iridescenceThicknessMap.channel),sheenColorMapUv:K&&l(u.sheenColorMap.channel),sheenRoughnessMapUv:J&&l(u.sheenRoughnessMap.channel),specularMapUv:lA&&l(u.specularMap.channel),specularColorMapUv:uA&&l(u.specularColorMap.channel),specularIntensityMapUv:kA&&l(u.specularIntensityMap.channel),transmissionMapUv:v&&l(u.transmissionMap.channel),thicknessMapUv:iA&&l(u.thicknessMap.channel),alphaMapUv:Z&&l(u.alphaMap.channel),vertexTangents:!!P.attributes.tangent&&(JA||D),vertexColors:u.vertexColors,vertexAlphas:u.vertexColors===!0&&!!P.attributes.color&&P.attributes.color.itemSize===4,pointsUvs:M.isPoints===!0&&!!P.attributes.uv&&(xA||Z),fog:!!_,useFog:u.fog===!0,fogExp2:!!_&&_.isFogExp2,flatShading:u.flatShading===!0,sizeAttenuation:u.sizeAttenuation===!0,logarithmicDepthBuffer:E,reverseDepthBuffer:mA,skinning:M.isSkinnedMesh===!0,morphTargets:P.morphAttributes.position!==void 0,morphNormals:P.morphAttributes.normal!==void 0,morphColors:P.morphAttributes.color!==void 0,morphTargetsCount:gA,morphTextureStride:pA,numDirLights:f.directional.length,numPointLights:f.point.length,numSpotLights:f.spot.length,numSpotLightMaps:f.spotLightMap.length,numRectAreaLights:f.rectArea.length,numHemiLights:f.hemi.length,numDirLightShadows:f.directionalShadowMap.length,numPointLightShadows:f.pointShadowMap.length,numSpotLightShadows:f.spotShadowMap.length,numSpotLightShadowsWithMaps:f.numSpotLightShadowsWithMaps,numLightProbes:f.numLightProbes,numClippingPlanes:o.numPlanes,numClipIntersection:o.numIntersection,dithering:u.dithering,shadowMapEnabled:i.shadowMap.enabled&&m.length>0,shadowMapType:i.shadowMap.type,toneMapping:he,decodeVideoTexture:xA&&u.map.isVideoTexture===!0&&$A.getTransfer(u.map.colorSpace)===ge,decodeVideoTextureEmissive:Ie&&u.emissiveMap.isVideoTexture===!0&&$A.getTransfer(u.emissiveMap.colorSpace)===ge,premultipliedAlpha:u.premultipliedAlpha,doubleSided:u.side===Bt,flipSided:u.side===Je,useDepthPacking:u.depthPacking>=0,depthPacking:u.depthPacking||0,index0AttributeName:u.index0AttributeName,extensionClipCullDistance:HA&&u.extensions.clipCullDistance===!0&&t.has("WEBGL_clip_cull_distance"),extensionMultiDraw:(HA&&u.extensions.multiDraw===!0||EA)&&t.has("WEBGL_multi_draw"),rendererExtensionParallelShaderCompile:t.has("KHR_parallel_shader_compile"),customProgramCacheKey:u.customProgramCacheKey()};return Me.vertexUv1s=g.has(1),Me.vertexUv2s=g.has(2),Me.vertexUv3s=g.has(3),g.clear(),Me}function c(u){const f=[];if(u.shaderID?f.push(u.shaderID):(f.push(u.customVertexShaderID),f.push(u.customFragmentShaderID)),u.defines!==void 0)for(const m in u.defines)f.push(m),f.push(u.defines[m]);return u.isRawShaderMaterial===!1&&(R(f,u),p(f,u),f.push(i.outputColorSpace)),f.push(u.customProgramCacheKey),f.join()}function R(u,f){u.push(f.precision),u.push(f.outputColorSpace),u.push(f.envMapMode),u.push(f.envMapCubeUVHeight),u.push(f.mapUv),u.push(f.alphaMapUv),u.push(f.lightMapUv),u.push(f.aoMapUv),u.push(f.bumpMapUv),u.push(f.normalMapUv),u.push(f.displacementMapUv),u.push(f.emissiveMapUv),u.push(f.metalnessMapUv),u.push(f.roughnessMapUv),u.push(f.anisotropyMapUv),u.push(f.clearcoatMapUv),u.push(f.clearcoatNormalMapUv),u.push(f.clearcoatRoughnessMapUv),u.push(f.iridescenceMapUv),u.push(f.iridescenceThicknessMapUv),u.push(f.sheenColorMapUv),u.push(f.sheenRoughnessMapUv),u.push(f.specularMapUv),u.push(f.specularColorMapUv),u.push(f.specularIntensityMapUv),u.push(f.transmissionMapUv),u.push(f.thicknessMapUv),u.push(f.combine),u.push(f.fogExp2),u.push(f.sizeAttenuation),u.push(f.morphTargetsCount),u.push(f.morphAttributeCount),u.push(f.numDirLights),u.push(f.numPointLights),u.push(f.numSpotLights),u.push(f.numSpotLightMaps),u.push(f.numHemiLights),u.push(f.numRectAreaLights),u.push(f.numDirLightShadows),u.push(f.numPointLightShadows),u.push(f.numSpotLightShadows),u.push(f.numSpotLightShadowsWithMaps),u.push(f.numLightProbes),u.push(f.shadowMapType),u.push(f.toneMapping),u.push(f.numClippingPlanes),u.push(f.numClipIntersection),u.push(f.depthPacking)}function p(u,f){r.disableAll(),f.supportsVertexTextures&&r.enable(0),f.instancing&&r.enable(1),f.instancingColor&&r.enable(2),f.instancingMorph&&r.enable(3),f.matcap&&r.enable(4),f.envMap&&r.enable(5),f.normalMapObjectSpace&&r.enable(6),f.normalMapTangentSpace&&r.enable(7),f.clearcoat&&r.enable(8),f.iridescence&&r.enable(9),f.alphaTest&&r.enable(10),f.vertexColors&&r.enable(11),f.vertexAlphas&&r.enable(12),f.vertexUv1s&&r.enable(13),f.vertexUv2s&&r.enable(14),f.vertexUv3s&&r.enable(15),f.vertexTangents&&r.enable(16),f.anisotropy&&r.enable(17),f.alphaHash&&r.enable(18),f.batching&&r.enable(19),f.dispersion&&r.enable(20),f.batchingColor&&r.enable(21),u.push(r.mask),r.disableAll(),f.fog&&r.enable(0),f.useFog&&r.enable(1),f.flatShading&&r.enable(2),f.logarithmicDepthBuffer&&r.enable(3),f.reverseDepthBuffer&&r.enable(4),f.skinning&&r.enable(5),f.morphTargets&&r.enable(6),f.morphNormals&&r.enable(7),f.morphColors&&r.enable(8),f.premultipliedAlpha&&r.enable(9),f.shadowMapEnabled&&r.enable(10),f.doubleSided&&r.enable(11),f.flipSided&&r.enable(12),f.useDepthPacking&&r.enable(13),f.dithering&&r.enable(14),f.transmission&&r.enable(15),f.sheen&&r.enable(16),f.opaque&&r.enable(17),f.pointsUvs&&r.enable(18),f.decodeVideoTexture&&r.enable(19),f.decodeVideoTextureEmissive&&r.enable(20),f.alphaToCoverage&&r.enable(21),u.push(r.mask)}function d(u){const f=h[u.type];let m;if(f){const T=Qt[f];m=wE.clone(T.uniforms)}else m=u.uniforms;return m}function w(u,f){let m;for(let T=0,M=I.length;T<M;T++){const _=I[T];if(_.cacheKey===f){m=_,++m.usedTimes;break}}return m===void 0&&(m=new wu(i,f,u,s),I.push(m)),m}function S(u){if(--u.usedTimes===0){const f=I.indexOf(u);I[f]=I[I.length-1],I.pop(),u.destroy()}}function F(u){a.remove(u)}function N(){a.dispose()}return{getParameters:B,getProgramCacheKey:c,getUniforms:d,acquireProgram:w,releaseProgram:S,releaseShaderCache:F,programs:I,dispose:N}}function Fu(){let i=new WeakMap;function A(o){return i.has(o)}function e(o){let r=i.get(o);return r===void 0&&(r={},i.set(o,r)),r}function t(o){i.delete(o)}function n(o,r,a){i.get(o)[r]=a}function s(){i=new WeakMap}return{has:A,get:e,remove:t,update:n,dispose:s}}function Lu(i,A){return i.groupOrder!==A.groupOrder?i.groupOrder-A.groupOrder:i.renderOrder!==A.renderOrder?i.renderOrder-A.renderOrder:i.material.id!==A.material.id?i.material.id-A.material.id:i.z!==A.z?i.z-A.z:i.id-A.id}function oI(i,A){return i.groupOrder!==A.groupOrder?i.groupOrder-A.groupOrder:i.renderOrder!==A.renderOrder?i.renderOrder-A.renderOrder:i.z!==A.z?A.z-i.z:i.id-A.id}function rI(){const i=[];let A=0;const e=[],t=[],n=[];function s(){A=0,e.length=0,t.length=0,n.length=0}function o(E,C,Q,h,l,B){let c=i[A];return c===void 0?(c={id:E.id,object:E,geometry:C,material:Q,groupOrder:h,renderOrder:E.renderOrder,z:l,group:B},i[A]=c):(c.id=E.id,c.object=E,c.geometry=C,c.material=Q,c.groupOrder=h,c.renderOrder=E.renderOrder,c.z=l,c.group=B),A++,c}function r(E,C,Q,h,l,B){const c=o(E,C,Q,h,l,B);Q.transmission>0?t.push(c):Q.transparent===!0?n.push(c):e.push(c)}function a(E,C,Q,h,l,B){const c=o(E,C,Q,h,l,B);Q.transmission>0?t.unshift(c):Q.transparent===!0?n.unshift(c):e.unshift(c)}function g(E,C){e.length>1&&e.sort(E||Lu),t.length>1&&t.sort(C||oI),n.length>1&&n.sort(C||oI)}function I(){for(let E=A,C=i.length;E<C;E++){const Q=i[E];if(Q.id===null)break;Q.id=null,Q.object=null,Q.geometry=null,Q.material=null,Q.group=null}}return{opaque:e,transmissive:t,transparent:n,init:s,push:r,unshift:a,finish:I,sort:g}}function _u(){let i=new WeakMap;function A(t,n){const s=i.get(t);let o;return s===void 0?(o=new rI,i.set(t,[o])):n>=s.length?(o=new rI,s.push(o)):o=s[n],o}function e(){i=new WeakMap}return{get:A,dispose:e}}function Uu(){const i={};return{get:function(A){if(i[A.id]!==void 0)return i[A.id];let e;switch(A.type){case"DirectionalLight":e={direction:new L,color:new GA};break;case"SpotLight":e={position:new L,direction:new L,color:new GA,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":e={position:new L,color:new GA,distance:0,decay:0};break;case"HemisphereLight":e={direction:new L,skyColor:new GA,groundColor:new GA};break;case"RectAreaLight":e={color:new GA,position:new L,halfWidth:new L,halfHeight:new L};break}return i[A.id]=e,e}}}function Gu(){const i={};return{get:function(A){if(i[A.id]!==void 0)return i[A.id];let e;switch(A.type){case"DirectionalLight":e={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new bA};break;case"SpotLight":e={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new bA};break;case"PointLight":e={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new bA,shadowCameraNear:1,shadowCameraFar:1e3};break}return i[A.id]=e,e}}}let vu=0;function Tu(i,A){return(A.castShadow?2:0)-(i.castShadow?2:0)+(A.map?1:0)-(i.map?1:0)}function bu(i){const A=new Uu,e=Gu(),t={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1,numSpotMaps:-1,numLightProbes:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotLightMap:[],spotShadow:[],spotShadowMap:[],spotLightMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[],numSpotLightShadowsWithMaps:0,numLightProbes:0};for(let g=0;g<9;g++)t.probe.push(new L);const n=new L,s=new UA,o=new UA;function r(g){let I=0,E=0,C=0;for(let u=0;u<9;u++)t.probe[u].set(0,0,0);let Q=0,h=0,l=0,B=0,c=0,R=0,p=0,d=0,w=0,S=0,F=0;g.sort(Tu);for(let u=0,f=g.length;u<f;u++){const m=g[u],T=m.color,M=m.intensity,_=m.distance,P=m.shadow&&m.shadow.map?m.shadow.map.texture:null;if(m.isAmbientLight)I+=T.r*M,E+=T.g*M,C+=T.b*M;else if(m.isLightProbe){for(let b=0;b<9;b++)t.probe[b].addScaledVector(m.sh.coefficients[b],M);F++}else if(m.isDirectionalLight){const b=A.get(m);if(b.color.copy(m.color).multiplyScalar(m.intensity),m.castShadow){const z=m.shadow,O=e.get(m);O.shadowIntensity=z.intensity,O.shadowBias=z.bias,O.shadowNormalBias=z.normalBias,O.shadowRadius=z.radius,O.shadowMapSize=z.mapSize,t.directionalShadow[Q]=O,t.directionalShadowMap[Q]=P,t.directionalShadowMatrix[Q]=m.shadow.matrix,R++}t.directional[Q]=b,Q++}else if(m.isSpotLight){const b=A.get(m);b.position.setFromMatrixPosition(m.matrixWorld),b.color.copy(T).multiplyScalar(M),b.distance=_,b.coneCos=Math.cos(m.angle),b.penumbraCos=Math.cos(m.angle*(1-m.penumbra)),b.decay=m.decay,t.spot[l]=b;const z=m.shadow;if(m.map&&(t.spotLightMap[w]=m.map,w++,z.updateMatrices(m),m.castShadow&&S++),t.spotLightMatrix[l]=z.matrix,m.castShadow){const O=e.get(m);O.shadowIntensity=z.intensity,O.shadowBias=z.bias,O.shadowNormalBias=z.normalBias,O.shadowRadius=z.radius,O.shadowMapSize=z.mapSize,t.spotShadow[l]=O,t.spotShadowMap[l]=P,d++}l++}else if(m.isRectAreaLight){const b=A.get(m);b.color.copy(T).multiplyScalar(M),b.halfWidth.set(m.width*.5,0,0),b.halfHeight.set(0,m.height*.5,0),t.rectArea[B]=b,B++}else if(m.isPointLight){const b=A.get(m);if(b.color.copy(m.color).multiplyScalar(m.intensity),b.distance=m.distance,b.decay=m.decay,m.castShadow){const z=m.shadow,O=e.get(m);O.shadowIntensity=z.intensity,O.shadowBias=z.bias,O.shadowNormalBias=z.normalBias,O.shadowRadius=z.radius,O.shadowMapSize=z.mapSize,O.shadowCameraNear=z.camera.near,O.shadowCameraFar=z.camera.far,t.pointShadow[h]=O,t.pointShadowMap[h]=P,t.pointShadowMatrix[h]=m.shadow.matrix,p++}t.point[h]=b,h++}else if(m.isHemisphereLight){const b=A.get(m);b.skyColor.copy(m.color).multiplyScalar(M),b.groundColor.copy(m.groundColor).multiplyScalar(M),t.hemi[c]=b,c++}}B>0&&(i.has("OES_texture_float_linear")===!0?(t.rectAreaLTC1=aA.LTC_FLOAT_1,t.rectAreaLTC2=aA.LTC_FLOAT_2):(t.rectAreaLTC1=aA.LTC_HALF_1,t.rectAreaLTC2=aA.LTC_HALF_2)),t.ambient[0]=I,t.ambient[1]=E,t.ambient[2]=C;const N=t.hash;(N.directionalLength!==Q||N.pointLength!==h||N.spotLength!==l||N.rectAreaLength!==B||N.hemiLength!==c||N.numDirectionalShadows!==R||N.numPointShadows!==p||N.numSpotShadows!==d||N.numSpotMaps!==w||N.numLightProbes!==F)&&(t.directional.length=Q,t.spot.length=l,t.rectArea.length=B,t.point.length=h,t.hemi.length=c,t.directionalShadow.length=R,t.directionalShadowMap.length=R,t.pointShadow.length=p,t.pointShadowMap.length=p,t.spotShadow.length=d,t.spotShadowMap.length=d,t.directionalShadowMatrix.length=R,t.pointShadowMatrix.length=p,t.spotLightMatrix.length=d+w-S,t.spotLightMap.length=w,t.numSpotLightShadowsWithMaps=S,t.numLightProbes=F,N.directionalLength=Q,N.pointLength=h,N.spotLength=l,N.rectAreaLength=B,N.hemiLength=c,N.numDirectionalShadows=R,N.numPointShadows=p,N.numSpotShadows=d,N.numSpotMaps=w,N.numLightProbes=F,t.version=vu++)}function a(g,I){let E=0,C=0,Q=0,h=0,l=0;const B=I.matrixWorldInverse;for(let c=0,R=g.length;c<R;c++){const p=g[c];if(p.isDirectionalLight){const d=t.directional[E];d.direction.setFromMatrixPosition(p.matrixWorld),n.setFromMatrixPosition(p.target.matrixWorld),d.direction.sub(n),d.direction.transformDirection(B),E++}else if(p.isSpotLight){const d=t.spot[Q];d.position.setFromMatrixPosition(p.matrixWorld),d.position.applyMatrix4(B),d.direction.setFromMatrixPosition(p.matrixWorld),n.setFromMatrixPosition(p.target.matrixWorld),d.direction.sub(n),d.direction.transformDirection(B),Q++}else if(p.isRectAreaLight){const d=t.rectArea[h];d.position.setFromMatrixPosition(p.matrixWorld),d.position.applyMatrix4(B),o.identity(),s.copy(p.matrixWorld),s.premultiply(B),o.extractRotation(s),d.halfWidth.set(p.width*.5,0,0),d.halfHeight.set(0,p.height*.5,0),d.halfWidth.applyMatrix4(o),d.halfHeight.applyMatrix4(o),h++}else if(p.isPointLight){const d=t.point[C];d.position.setFromMatrixPosition(p.matrixWorld),d.position.applyMatrix4(B),C++}else if(p.isHemisphereLight){const d=t.hemi[l];d.direction.setFromMatrixPosition(p.matrixWorld),d.direction.transformDirection(B),l++}}}return{setup:r,setupView:a,state:t}}function aI(i){const A=new bu(i),e=[],t=[];function n(I){g.camera=I,e.length=0,t.length=0}function s(I){e.push(I)}function o(I){t.push(I)}function r(){A.setup(e)}function a(I){A.setupView(e,I)}const g={lightsArray:e,shadowsArray:t,camera:null,lights:A,transmissionRenderTarget:{}};return{init:n,state:g,setupLights:r,setupLightsView:a,pushLight:s,pushShadow:o}}function ku(i){let A=new WeakMap;function e(n,s=0){const o=A.get(n);let r;return o===void 0?(r=new aI(i),A.set(n,[r])):s>=o.length?(r=new aI(i),o.push(r)):r=o[s],r}function t(){A=new WeakMap}return{get:e,dispose:t}}const Hu=`void main() {
	gl_Position = vec4( position, 1.0 );
}`,Pu=`uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;function Ou(i,A,e){let t=new to;const n=new bA,s=new bA,o=new YA,r=new TB({depthPacking:MQ}),a=new bB,g={},I=e.maxTextureSize,E={[ft]:Je,[Je]:ft,[Bt]:Bt},C=new Wt({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new bA},radius:{value:4}},vertexShader:Hu,fragmentShader:Pu}),Q=C.clone();Q.defines.HORIZONTAL_PASS=1;const h=new Xe;h.setAttribute("position",new Qe(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const l=new ve(h,C),B=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=nE;let c=this.type;this.render=function(S,F,N){if(B.enabled===!1||B.autoUpdate===!1&&B.needsUpdate===!1||S.length===0)return;const u=i.getRenderTarget(),f=i.getActiveCubeFace(),m=i.getActiveMipmapLevel(),T=i.state;T.setBlending(ri),T.buffers.color.setClear(1,1,1,1),T.buffers.depth.setTest(!0),T.setScissorTest(!1);const M=c!==Tt&&this.type===Tt,_=c===Tt&&this.type!==Tt;for(let P=0,b=S.length;P<b;P++){const z=S[P],O=z.shadow;if(O===void 0){console.warn("THREE.WebGLShadowMap:",z,"has no shadow.");continue}if(O.autoUpdate===!1&&O.needsUpdate===!1)continue;n.copy(O.mapSize);const eA=O.getFrameExtents();if(n.multiply(eA),s.copy(O.mapSize),(n.x>I||n.y>I)&&(n.x>I&&(s.x=Math.floor(I/eA.x),n.x=s.x*eA.x,O.mapSize.x=s.x),n.y>I&&(s.y=Math.floor(I/eA.y),n.y=s.y*eA.y,O.mapSize.y=s.y)),O.map===null||M===!0||_===!0){const gA=this.type!==Tt?{minFilter:Te,magFilter:Te}:{};O.map!==null&&O.map.dispose(),O.map=new wi(n.x,n.y,gA),O.map.texture.name=z.name+".shadowMap",O.camera.updateProjectionMatrix()}i.setRenderTarget(O.map),i.clear();const oA=O.getViewportCount();for(let gA=0;gA<oA;gA++){const pA=O.getViewport(gA);o.set(s.x*pA.x,s.y*pA.y,s.x*pA.z,s.y*pA.w),T.viewport(o),O.updateMatrices(z,gA),t=O.getFrustum(),d(F,N,O.camera,z,this.type)}O.isPointLightShadow!==!0&&this.type===Tt&&R(O,N),O.needsUpdate=!1}c=this.type,B.needsUpdate=!1,i.setRenderTarget(u,f,m)};function R(S,F){const N=A.update(l);C.defines.VSM_SAMPLES!==S.blurSamples&&(C.defines.VSM_SAMPLES=S.blurSamples,Q.defines.VSM_SAMPLES=S.blurSamples,C.needsUpdate=!0,Q.needsUpdate=!0),S.mapPass===null&&(S.mapPass=new wi(n.x,n.y)),C.uniforms.shadow_pass.value=S.map.texture,C.uniforms.resolution.value=S.mapSize,C.uniforms.radius.value=S.radius,i.setRenderTarget(S.mapPass),i.clear(),i.renderBufferDirect(F,null,N,C,l,null),Q.uniforms.shadow_pass.value=S.mapPass.texture,Q.uniforms.resolution.value=S.mapSize,Q.uniforms.radius.value=S.radius,i.setRenderTarget(S.map),i.clear(),i.renderBufferDirect(F,null,N,Q,l,null)}function p(S,F,N,u){let f=null;const m=N.isPointLight===!0?S.customDistanceMaterial:S.customDepthMaterial;if(m!==void 0)f=m;else if(f=N.isPointLight===!0?a:r,i.localClippingEnabled&&F.clipShadows===!0&&Array.isArray(F.clippingPlanes)&&F.clippingPlanes.length!==0||F.displacementMap&&F.displacementScale!==0||F.alphaMap&&F.alphaTest>0||F.map&&F.alphaTest>0){const T=f.uuid,M=F.uuid;let _=g[T];_===void 0&&(_={},g[T]=_);let P=_[M];P===void 0&&(P=f.clone(),_[M]=P,F.addEventListener("dispose",w)),f=P}if(f.visible=F.visible,f.wireframe=F.wireframe,u===Tt?f.side=F.shadowSide!==null?F.shadowSide:F.side:f.side=F.shadowSide!==null?F.shadowSide:E[F.side],f.alphaMap=F.alphaMap,f.alphaTest=F.alphaTest,f.map=F.map,f.clipShadows=F.clipShadows,f.clippingPlanes=F.clippingPlanes,f.clipIntersection=F.clipIntersection,f.displacementMap=F.displacementMap,f.displacementScale=F.displacementScale,f.displacementBias=F.displacementBias,f.wireframeLinewidth=F.wireframeLinewidth,f.linewidth=F.linewidth,N.isPointLight===!0&&f.isMeshDistanceMaterial===!0){const T=i.properties.get(f);T.light=N}return f}function d(S,F,N,u,f){if(S.visible===!1)return;if(S.layers.test(F.layers)&&(S.isMesh||S.isLine||S.isPoints)&&(S.castShadow||S.receiveShadow&&f===Tt)&&(!S.frustumCulled||t.intersectsObject(S))){S.modelViewMatrix.multiplyMatrices(N.matrixWorldInverse,S.matrixWorld);const M=A.update(S),_=S.material;if(Array.isArray(_)){const P=M.groups;for(let b=0,z=P.length;b<z;b++){const O=P[b],eA=_[O.materialIndex];if(eA&&eA.visible){const oA=p(S,eA,u,f);S.onBeforeShadow(i,S,F,N,M,oA,O),i.renderBufferDirect(N,null,M,oA,S,O),S.onAfterShadow(i,S,F,N,M,oA,O)}}}else if(_.visible){const P=p(S,_,u,f);S.onBeforeShadow(i,S,F,N,M,P,null),i.renderBufferDirect(N,null,M,P,S,null),S.onAfterShadow(i,S,F,N,M,P,null)}}const T=S.children;for(let M=0,_=T.length;M<_;M++)d(T[M],F,N,u,f)}function w(S){S.target.removeEventListener("dispose",w);for(const N in g){const u=g[N],f=S.target.uuid;f in u&&(u[f].dispose(),delete u[f])}}}const Ju={[rr]:ar,[gr]:Cr,[Ir]:Qr,[nn]:Er,[ar]:rr,[Cr]:gr,[Qr]:Ir,[Er]:nn};function Ku(i,A){function e(){let v=!1;const iA=new YA;let q=null;const Z=new YA(0,0,0,0);return{setMask:function(IA){q!==IA&&!v&&(i.colorMask(IA,IA,IA,IA),q=IA)},setLocked:function(IA){v=IA},setClear:function(IA,BA,HA,he,Me){Me===!0&&(IA*=he,BA*=he,HA*=he),iA.set(IA,BA,HA,he),Z.equals(iA)===!1&&(i.clearColor(IA,BA,HA,he),Z.copy(iA))},reset:function(){v=!1,q=null,Z.set(-1,0,0,0)}}}function t(){let v=!1,iA=!1,q=null,Z=null,IA=null;return{setReversed:function(BA){if(iA!==BA){const HA=A.get("EXT_clip_control");iA?HA.clipControlEXT(HA.LOWER_LEFT_EXT,HA.ZERO_TO_ONE_EXT):HA.clipControlEXT(HA.LOWER_LEFT_EXT,HA.NEGATIVE_ONE_TO_ONE_EXT);const he=IA;IA=null,this.setClear(he)}iA=BA},getReversed:function(){return iA},setTest:function(BA){BA?rA(i.DEPTH_TEST):mA(i.DEPTH_TEST)},setMask:function(BA){q!==BA&&!v&&(i.depthMask(BA),q=BA)},setFunc:function(BA){if(iA&&(BA=Ju[BA]),Z!==BA){switch(BA){case rr:i.depthFunc(i.NEVER);break;case ar:i.depthFunc(i.ALWAYS);break;case gr:i.depthFunc(i.LESS);break;case nn:i.depthFunc(i.LEQUAL);break;case Ir:i.depthFunc(i.EQUAL);break;case Er:i.depthFunc(i.GEQUAL);break;case Cr:i.depthFunc(i.GREATER);break;case Qr:i.depthFunc(i.NOTEQUAL);break;default:i.depthFunc(i.LEQUAL)}Z=BA}},setLocked:function(BA){v=BA},setClear:function(BA){IA!==BA&&(iA&&(BA=1-BA),i.clearDepth(BA),IA=BA)},reset:function(){v=!1,q=null,Z=null,IA=null,iA=!1}}}function n(){let v=!1,iA=null,q=null,Z=null,IA=null,BA=null,HA=null,he=null,Me=null;return{setTest:function(oe){v||(oe?rA(i.STENCIL_TEST):mA(i.STENCIL_TEST))},setMask:function(oe){iA!==oe&&!v&&(i.stencilMask(oe),iA=oe)},setFunc:function(oe,at,xt){(q!==oe||Z!==at||IA!==xt)&&(i.stencilFunc(oe,at,xt),q=oe,Z=at,IA=xt)},setOp:function(oe,at,xt){(BA!==oe||HA!==at||he!==xt)&&(i.stencilOp(oe,at,xt),BA=oe,HA=at,he=xt)},setLocked:function(oe){v=oe},setClear:function(oe){Me!==oe&&(i.clearStencil(oe),Me=oe)},reset:function(){v=!1,iA=null,q=null,Z=null,IA=null,BA=null,HA=null,he=null,Me=null}}}const s=new e,o=new t,r=new n,a=new WeakMap,g=new WeakMap;let I={},E={},C=new WeakMap,Q=[],h=null,l=!1,B=null,c=null,R=null,p=null,d=null,w=null,S=null,F=new GA(0,0,0),N=0,u=!1,f=null,m=null,T=null,M=null,_=null;const P=i.getParameter(i.MAX_COMBINED_TEXTURE_IMAGE_UNITS);let b=!1,z=0;const O=i.getParameter(i.VERSION);O.indexOf("WebGL")!==-1?(z=parseFloat(/^WebGL (\d)/.exec(O)[1]),b=z>=1):O.indexOf("OpenGL ES")!==-1&&(z=parseFloat(/^OpenGL ES (\d)/.exec(O)[1]),b=z>=2);let eA=null,oA={};const gA=i.getParameter(i.SCISSOR_BOX),pA=i.getParameter(i.VIEWPORT),qA=new YA().fromArray(gA),X=new YA().fromArray(pA);function AA(v,iA,q,Z){const IA=new Uint8Array(4),BA=i.createTexture();i.bindTexture(v,BA),i.texParameteri(v,i.TEXTURE_MIN_FILTER,i.NEAREST),i.texParameteri(v,i.TEXTURE_MAG_FILTER,i.NEAREST);for(let HA=0;HA<q;HA++)v===i.TEXTURE_3D||v===i.TEXTURE_2D_ARRAY?i.texImage3D(iA,0,i.RGBA,1,1,Z,0,i.RGBA,i.UNSIGNED_BYTE,IA):i.texImage2D(iA+HA,0,i.RGBA,1,1,0,i.RGBA,i.UNSIGNED_BYTE,IA);return BA}const hA={};hA[i.TEXTURE_2D]=AA(i.TEXTURE_2D,i.TEXTURE_2D,1),hA[i.TEXTURE_CUBE_MAP]=AA(i.TEXTURE_CUBE_MAP,i.TEXTURE_CUBE_MAP_POSITIVE_X,6),hA[i.TEXTURE_2D_ARRAY]=AA(i.TEXTURE_2D_ARRAY,i.TEXTURE_2D_ARRAY,1,1),hA[i.TEXTURE_3D]=AA(i.TEXTURE_3D,i.TEXTURE_3D,1,1),s.setClear(0,0,0,1),o.setClear(1),r.setClear(0),rA(i.DEPTH_TEST),o.setFunc(nn),VA(!1),JA(Pa),rA(i.CULL_FACE),U(ri);function rA(v){I[v]!==!0&&(i.enable(v),I[v]=!0)}function mA(v){I[v]!==!1&&(i.disable(v),I[v]=!1)}function LA(v,iA){return E[v]!==iA?(i.bindFramebuffer(v,iA),E[v]=iA,v===i.DRAW_FRAMEBUFFER&&(E[i.FRAMEBUFFER]=iA),v===i.FRAMEBUFFER&&(E[i.DRAW_FRAMEBUFFER]=iA),!0):!1}function EA(v,iA){let q=Q,Z=!1;if(v){q=C.get(iA),q===void 0&&(q=[],C.set(iA,q));const IA=v.textures;if(q.length!==IA.length||q[0]!==i.COLOR_ATTACHMENT0){for(let BA=0,HA=IA.length;BA<HA;BA++)q[BA]=i.COLOR_ATTACHMENT0+BA;q.length=IA.length,Z=!0}}else q[0]!==i.BACK&&(q[0]=i.BACK,Z=!0);Z&&i.drawBuffers(q)}function xA(v){return h!==v?(i.useProgram(v),h=v,!0):!1}const yA={[Di]:i.FUNC_ADD,[jC]:i.FUNC_SUBTRACT,[$C]:i.FUNC_REVERSE_SUBTRACT};yA[AQ]=i.MIN,yA[eQ]=i.MAX;const WA={[tQ]:i.ZERO,[iQ]:i.ONE,[nQ]:i.SRC_COLOR,[sr]:i.SRC_ALPHA,[IQ]:i.SRC_ALPHA_SATURATE,[aQ]:i.DST_COLOR,[oQ]:i.DST_ALPHA,[sQ]:i.ONE_MINUS_SRC_COLOR,[or]:i.ONE_MINUS_SRC_ALPHA,[gQ]:i.ONE_MINUS_DST_COLOR,[rQ]:i.ONE_MINUS_DST_ALPHA,[EQ]:i.CONSTANT_COLOR,[CQ]:i.ONE_MINUS_CONSTANT_COLOR,[QQ]:i.CONSTANT_ALPHA,[BQ]:i.ONE_MINUS_CONSTANT_ALPHA};function U(v,iA,q,Z,IA,BA,HA,he,Me,oe){if(v===ri){l===!0&&(mA(i.BLEND),l=!1);return}if(l===!1&&(rA(i.BLEND),l=!0),v!==ZC){if(v!==B||oe!==u){if((c!==Di||d!==Di)&&(i.blendEquation(i.FUNC_ADD),c=Di,d=Di),oe)switch(v){case Ri:i.blendFuncSeparate(i.ONE,i.ONE_MINUS_SRC_ALPHA,i.ONE,i.ONE_MINUS_SRC_ALPHA);break;case Oa:i.blendFunc(i.ONE,i.ONE);break;case Ja:i.blendFuncSeparate(i.ZERO,i.ONE_MINUS_SRC_COLOR,i.ZERO,i.ONE);break;case Ka:i.blendFuncSeparate(i.ZERO,i.SRC_COLOR,i.ZERO,i.SRC_ALPHA);break;default:console.error("THREE.WebGLState: Invalid blending: ",v);break}else switch(v){case Ri:i.blendFuncSeparate(i.SRC_ALPHA,i.ONE_MINUS_SRC_ALPHA,i.ONE,i.ONE_MINUS_SRC_ALPHA);break;case Oa:i.blendFunc(i.SRC_ALPHA,i.ONE);break;case Ja:i.blendFuncSeparate(i.ZERO,i.ONE_MINUS_SRC_COLOR,i.ZERO,i.ONE);break;case Ka:i.blendFunc(i.ZERO,i.SRC_COLOR);break;default:console.error("THREE.WebGLState: Invalid blending: ",v);break}R=null,p=null,w=null,S=null,F.set(0,0,0),N=0,B=v,u=oe}return}IA=IA||iA,BA=BA||q,HA=HA||Z,(iA!==c||IA!==d)&&(i.blendEquationSeparate(yA[iA],yA[IA]),c=iA,d=IA),(q!==R||Z!==p||BA!==w||HA!==S)&&(i.blendFuncSeparate(WA[q],WA[Z],WA[BA],WA[HA]),R=q,p=Z,w=BA,S=HA),(he.equals(F)===!1||Me!==N)&&(i.blendColor(he.r,he.g,he.b,Me),F.copy(he),N=Me),B=v,u=!1}function ke(v,iA){v.side===Bt?mA(i.CULL_FACE):rA(i.CULL_FACE);let q=v.side===Je;iA&&(q=!q),VA(q),v.blending===Ri&&v.transparent===!1?U(ri):U(v.blending,v.blendEquation,v.blendSrc,v.blendDst,v.blendEquationAlpha,v.blendSrcAlpha,v.blendDstAlpha,v.blendColor,v.blendAlpha,v.premultipliedAlpha),o.setFunc(v.depthFunc),o.setTest(v.depthTest),o.setMask(v.depthWrite),s.setMask(v.colorWrite);const Z=v.stencilWrite;r.setTest(Z),Z&&(r.setMask(v.stencilWriteMask),r.setFunc(v.stencilFunc,v.stencilRef,v.stencilFuncMask),r.setOp(v.stencilFail,v.stencilZFail,v.stencilZPass)),Ie(v.polygonOffset,v.polygonOffsetFactor,v.polygonOffsetUnits),v.alphaToCoverage===!0?rA(i.SAMPLE_ALPHA_TO_COVERAGE):mA(i.SAMPLE_ALPHA_TO_COVERAGE)}function VA(v){f!==v&&(v?i.frontFace(i.CW):i.frontFace(i.CCW),f=v)}function JA(v){v!==VC?(rA(i.CULL_FACE),v!==m&&(v===Pa?i.cullFace(i.BACK):v===zC?i.cullFace(i.FRONT):i.cullFace(i.FRONT_AND_BACK))):mA(i.CULL_FACE),m=v}function wA(v){v!==T&&(b&&i.lineWidth(v),T=v)}function Ie(v,iA,q){v?(rA(i.POLYGON_OFFSET_FILL),(M!==iA||_!==q)&&(i.polygonOffset(iA,q),M=iA,_=q)):mA(i.POLYGON_OFFSET_FILL)}function MA(v){v?rA(i.SCISSOR_TEST):mA(i.SCISSOR_TEST)}function x(v){v===void 0&&(v=i.TEXTURE0+P-1),eA!==v&&(i.activeTexture(v),eA=v)}function D(v,iA,q){q===void 0&&(eA===null?q=i.TEXTURE0+P-1:q=eA);let Z=oA[q];Z===void 0&&(Z={type:void 0,texture:void 0},oA[q]=Z),(Z.type!==v||Z.texture!==iA)&&(eA!==q&&(i.activeTexture(q),eA=q),i.bindTexture(v,iA||hA[v]),Z.type=v,Z.texture=iA)}function Y(){const v=oA[eA];v!==void 0&&v.type!==void 0&&(i.bindTexture(v.type,null),v.type=void 0,v.texture=void 0)}function $(){try{i.compressedTexImage2D.apply(i,arguments)}catch(v){console.error("THREE.WebGLState:",v)}}function tA(){try{i.compressedTexImage3D.apply(i,arguments)}catch(v){console.error("THREE.WebGLState:",v)}}function j(){try{i.texSubImage2D.apply(i,arguments)}catch(v){console.error("THREE.WebGLState:",v)}}function RA(){try{i.texSubImage3D.apply(i,arguments)}catch(v){console.error("THREE.WebGLState:",v)}}function CA(){try{i.compressedTexSubImage2D.apply(i,arguments)}catch(v){console.error("THREE.WebGLState:",v)}}function cA(){try{i.compressedTexSubImage3D.apply(i,arguments)}catch(v){console.error("THREE.WebGLState:",v)}}function ZA(){try{i.texStorage2D.apply(i,arguments)}catch(v){console.error("THREE.WebGLState:",v)}}function nA(){try{i.texStorage3D.apply(i,arguments)}catch(v){console.error("THREE.WebGLState:",v)}}function dA(){try{i.texImage2D.apply(i,arguments)}catch(v){console.error("THREE.WebGLState:",v)}}function NA(){try{i.texImage3D.apply(i,arguments)}catch(v){console.error("THREE.WebGLState:",v)}}function K(v){qA.equals(v)===!1&&(i.scissor(v.x,v.y,v.z,v.w),qA.copy(v))}function J(v){X.equals(v)===!1&&(i.viewport(v.x,v.y,v.z,v.w),X.copy(v))}function lA(v,iA){let q=g.get(iA);q===void 0&&(q=new WeakMap,g.set(iA,q));let Z=q.get(v);Z===void 0&&(Z=i.getUniformBlockIndex(iA,v.name),q.set(v,Z))}function uA(v,iA){const Z=g.get(iA).get(v);a.get(iA)!==Z&&(i.uniformBlockBinding(iA,Z,v.__bindingPointIndex),a.set(iA,Z))}function kA(){i.disable(i.BLEND),i.disable(i.CULL_FACE),i.disable(i.DEPTH_TEST),i.disable(i.POLYGON_OFFSET_FILL),i.disable(i.SCISSOR_TEST),i.disable(i.STENCIL_TEST),i.disable(i.SAMPLE_ALPHA_TO_COVERAGE),i.blendEquation(i.FUNC_ADD),i.blendFunc(i.ONE,i.ZERO),i.blendFuncSeparate(i.ONE,i.ZERO,i.ONE,i.ZERO),i.blendColor(0,0,0,0),i.colorMask(!0,!0,!0,!0),i.clearColor(0,0,0,0),i.depthMask(!0),i.depthFunc(i.LESS),o.setReversed(!1),i.clearDepth(1),i.stencilMask(4294967295),i.stencilFunc(i.ALWAYS,0,4294967295),i.stencilOp(i.KEEP,i.KEEP,i.KEEP),i.clearStencil(0),i.cullFace(i.BACK),i.frontFace(i.CCW),i.polygonOffset(0,0),i.activeTexture(i.TEXTURE0),i.bindFramebuffer(i.FRAMEBUFFER,null),i.bindFramebuffer(i.DRAW_FRAMEBUFFER,null),i.bindFramebuffer(i.READ_FRAMEBUFFER,null),i.useProgram(null),i.lineWidth(1),i.scissor(0,0,i.canvas.width,i.canvas.height),i.viewport(0,0,i.canvas.width,i.canvas.height),I={},eA=null,oA={},E={},C=new WeakMap,Q=[],h=null,l=!1,B=null,c=null,R=null,p=null,d=null,w=null,S=null,F=new GA(0,0,0),N=0,u=!1,f=null,m=null,T=null,M=null,_=null,qA.set(0,0,i.canvas.width,i.canvas.height),X.set(0,0,i.canvas.width,i.canvas.height),s.reset(),o.reset(),r.reset()}return{buffers:{color:s,depth:o,stencil:r},enable:rA,disable:mA,bindFramebuffer:LA,drawBuffers:EA,useProgram:xA,setBlending:U,setMaterial:ke,setFlipSided:VA,setCullFace:JA,setLineWidth:wA,setPolygonOffset:Ie,setScissorTest:MA,activeTexture:x,bindTexture:D,unbindTexture:Y,compressedTexImage2D:$,compressedTexImage3D:tA,texImage2D:dA,texImage3D:NA,updateUBOMapping:lA,uniformBlockBinding:uA,texStorage2D:ZA,texStorage3D:nA,texSubImage2D:j,texSubImage3D:RA,compressedTexSubImage2D:CA,compressedTexSubImage3D:cA,scissor:K,viewport:J,reset:kA}}function Yu(i,A,e,t,n,s,o){const r=A.has("WEBGL_multisampled_render_to_texture")?A.get("WEBGL_multisampled_render_to_texture"):null,a=typeof navigator>"u"?!1:/OculusBrowser/g.test(navigator.userAgent),g=new bA,I=new WeakMap;let E;const C=new WeakMap;let Q=!1;try{Q=typeof OffscreenCanvas<"u"&&new OffscreenCanvas(1,1).getContext("2d")!==null}catch{}function h(x,D){return Q?new OffscreenCanvas(x,D):Jn("canvas")}function l(x,D,Y){let $=1;const tA=MA(x);if((tA.width>Y||tA.height>Y)&&($=Y/Math.max(tA.width,tA.height)),$<1)if(typeof HTMLImageElement<"u"&&x instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&x instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&x instanceof ImageBitmap||typeof VideoFrame<"u"&&x instanceof VideoFrame){const j=Math.floor($*tA.width),RA=Math.floor($*tA.height);E===void 0&&(E=h(j,RA));const CA=D?h(j,RA):E;return CA.width=j,CA.height=RA,CA.getContext("2d").drawImage(x,0,0,j,RA),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+tA.width+"x"+tA.height+") to ("+j+"x"+RA+")."),CA}else return"data"in x&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+tA.width+"x"+tA.height+")."),x;return x}function B(x){return x.generateMipmaps}function c(x){i.generateMipmap(x)}function R(x){return x.isWebGLCubeRenderTarget?i.TEXTURE_CUBE_MAP:x.isWebGL3DRenderTarget?i.TEXTURE_3D:x.isWebGLArrayRenderTarget||x.isCompressedArrayTexture?i.TEXTURE_2D_ARRAY:i.TEXTURE_2D}function p(x,D,Y,$,tA=!1){if(x!==null){if(i[x]!==void 0)return i[x];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+x+"'")}let j=D;if(D===i.RED&&(Y===i.FLOAT&&(j=i.R32F),Y===i.HALF_FLOAT&&(j=i.R16F),Y===i.UNSIGNED_BYTE&&(j=i.R8)),D===i.RED_INTEGER&&(Y===i.UNSIGNED_BYTE&&(j=i.R8UI),Y===i.UNSIGNED_SHORT&&(j=i.R16UI),Y===i.UNSIGNED_INT&&(j=i.R32UI),Y===i.BYTE&&(j=i.R8I),Y===i.SHORT&&(j=i.R16I),Y===i.INT&&(j=i.R32I)),D===i.RG&&(Y===i.FLOAT&&(j=i.RG32F),Y===i.HALF_FLOAT&&(j=i.RG16F),Y===i.UNSIGNED_BYTE&&(j=i.RG8)),D===i.RG_INTEGER&&(Y===i.UNSIGNED_BYTE&&(j=i.RG8UI),Y===i.UNSIGNED_SHORT&&(j=i.RG16UI),Y===i.UNSIGNED_INT&&(j=i.RG32UI),Y===i.BYTE&&(j=i.RG8I),Y===i.SHORT&&(j=i.RG16I),Y===i.INT&&(j=i.RG32I)),D===i.RGB_INTEGER&&(Y===i.UNSIGNED_BYTE&&(j=i.RGB8UI),Y===i.UNSIGNED_SHORT&&(j=i.RGB16UI),Y===i.UNSIGNED_INT&&(j=i.RGB32UI),Y===i.BYTE&&(j=i.RGB8I),Y===i.SHORT&&(j=i.RGB16I),Y===i.INT&&(j=i.RGB32I)),D===i.RGBA_INTEGER&&(Y===i.UNSIGNED_BYTE&&(j=i.RGBA8UI),Y===i.UNSIGNED_SHORT&&(j=i.RGBA16UI),Y===i.UNSIGNED_INT&&(j=i.RGBA32UI),Y===i.BYTE&&(j=i.RGBA8I),Y===i.SHORT&&(j=i.RGBA16I),Y===i.INT&&(j=i.RGBA32I)),D===i.RGB&&Y===i.UNSIGNED_INT_5_9_9_9_REV&&(j=i.RGB9_E5),D===i.RGBA){const RA=tA?Ks:$A.getTransfer($);Y===i.FLOAT&&(j=i.RGBA32F),Y===i.HALF_FLOAT&&(j=i.RGBA16F),Y===i.UNSIGNED_BYTE&&(j=RA===ge?i.SRGB8_ALPHA8:i.RGBA8),Y===i.UNSIGNED_SHORT_4_4_4_4&&(j=i.RGBA4),Y===i.UNSIGNED_SHORT_5_5_5_1&&(j=i.RGB5_A1)}return(j===i.R16F||j===i.R32F||j===i.RG16F||j===i.RG32F||j===i.RGBA16F||j===i.RGBA32F)&&A.get("EXT_color_buffer_float"),j}function d(x,D){let Y;return x?D===null||D===Oe||D===an?Y=i.DEPTH24_STENCIL8:D===lt?Y=i.DEPTH32F_STENCIL8:D===Hn&&(Y=i.DEPTH24_STENCIL8,console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")):D===null||D===Oe||D===an?Y=i.DEPTH_COMPONENT24:D===lt?Y=i.DEPTH_COMPONENT32F:D===Hn&&(Y=i.DEPTH_COMPONENT16),Y}function w(x,D){return B(x)===!0||x.isFramebufferTexture&&x.minFilter!==Te&&x.minFilter!==ze?Math.log2(Math.max(D.width,D.height))+1:x.mipmaps!==void 0&&x.mipmaps.length>0?x.mipmaps.length:x.isCompressedTexture&&Array.isArray(x.image)?D.mipmaps.length:1}function S(x){const D=x.target;D.removeEventListener("dispose",S),N(D),D.isVideoTexture&&I.delete(D)}function F(x){const D=x.target;D.removeEventListener("dispose",F),f(D)}function N(x){const D=t.get(x);if(D.__webglInit===void 0)return;const Y=x.source,$=C.get(Y);if($){const tA=$[D.__cacheKey];tA.usedTimes--,tA.usedTimes===0&&u(x),Object.keys($).length===0&&C.delete(Y)}t.remove(x)}function u(x){const D=t.get(x);i.deleteTexture(D.__webglTexture);const Y=x.source,$=C.get(Y);delete $[D.__cacheKey],o.memory.textures--}function f(x){const D=t.get(x);if(x.depthTexture&&(x.depthTexture.dispose(),t.remove(x.depthTexture)),x.isWebGLCubeRenderTarget)for(let $=0;$<6;$++){if(Array.isArray(D.__webglFramebuffer[$]))for(let tA=0;tA<D.__webglFramebuffer[$].length;tA++)i.deleteFramebuffer(D.__webglFramebuffer[$][tA]);else i.deleteFramebuffer(D.__webglFramebuffer[$]);D.__webglDepthbuffer&&i.deleteRenderbuffer(D.__webglDepthbuffer[$])}else{if(Array.isArray(D.__webglFramebuffer))for(let $=0;$<D.__webglFramebuffer.length;$++)i.deleteFramebuffer(D.__webglFramebuffer[$]);else i.deleteFramebuffer(D.__webglFramebuffer);if(D.__webglDepthbuffer&&i.deleteRenderbuffer(D.__webglDepthbuffer),D.__webglMultisampledFramebuffer&&i.deleteFramebuffer(D.__webglMultisampledFramebuffer),D.__webglColorRenderbuffer)for(let $=0;$<D.__webglColorRenderbuffer.length;$++)D.__webglColorRenderbuffer[$]&&i.deleteRenderbuffer(D.__webglColorRenderbuffer[$]);D.__webglDepthRenderbuffer&&i.deleteRenderbuffer(D.__webglDepthRenderbuffer)}const Y=x.textures;for(let $=0,tA=Y.length;$<tA;$++){const j=t.get(Y[$]);j.__webglTexture&&(i.deleteTexture(j.__webglTexture),o.memory.textures--),t.remove(Y[$])}t.remove(x)}let m=0;function T(){m=0}function M(){const x=m;return x>=n.maxTextures&&console.warn("THREE.WebGLTextures: Trying to use "+x+" texture units while this GPU supports only "+n.maxTextures),m+=1,x}function _(x){const D=[];return D.push(x.wrapS),D.push(x.wrapT),D.push(x.wrapR||0),D.push(x.magFilter),D.push(x.minFilter),D.push(x.anisotropy),D.push(x.internalFormat),D.push(x.format),D.push(x.type),D.push(x.generateMipmaps),D.push(x.premultiplyAlpha),D.push(x.flipY),D.push(x.unpackAlignment),D.push(x.colorSpace),D.join()}function P(x,D){const Y=t.get(x);if(x.isVideoTexture&&wA(x),x.isRenderTargetTexture===!1&&x.version>0&&Y.__version!==x.version){const $=x.image;if($===null)console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");else if($.complete===!1)console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");else{X(Y,x,D);return}}e.bindTexture(i.TEXTURE_2D,Y.__webglTexture,i.TEXTURE0+D)}function b(x,D){const Y=t.get(x);if(x.version>0&&Y.__version!==x.version){X(Y,x,D);return}e.bindTexture(i.TEXTURE_2D_ARRAY,Y.__webglTexture,i.TEXTURE0+D)}function z(x,D){const Y=t.get(x);if(x.version>0&&Y.__version!==x.version){X(Y,x,D);return}e.bindTexture(i.TEXTURE_3D,Y.__webglTexture,i.TEXTURE0+D)}function O(x,D){const Y=t.get(x);if(x.version>0&&Y.__version!==x.version){AA(Y,x,D);return}e.bindTexture(i.TEXTURE_CUBE_MAP,Y.__webglTexture,i.TEXTURE0+D)}const eA={[rn]:i.REPEAT,[ni]:i.CLAMP_TO_EDGE,[Js]:i.MIRRORED_REPEAT},oA={[Te]:i.NEAREST,[rE]:i.NEAREST_MIPMAP_NEAREST,[xn]:i.NEAREST_MIPMAP_LINEAR,[ze]:i.LINEAR,[Ls]:i.LINEAR_MIPMAP_NEAREST,[Ot]:i.LINEAR_MIPMAP_LINEAR},gA={[xQ]:i.NEVER,[vQ]:i.ALWAYS,[FQ]:i.LESS,[dE]:i.LEQUAL,[LQ]:i.EQUAL,[GQ]:i.GEQUAL,[_Q]:i.GREATER,[UQ]:i.NOTEQUAL};function pA(x,D){if(D.type===lt&&A.has("OES_texture_float_linear")===!1&&(D.magFilter===ze||D.magFilter===Ls||D.magFilter===xn||D.magFilter===Ot||D.minFilter===ze||D.minFilter===Ls||D.minFilter===xn||D.minFilter===Ot)&&console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."),i.texParameteri(x,i.TEXTURE_WRAP_S,eA[D.wrapS]),i.texParameteri(x,i.TEXTURE_WRAP_T,eA[D.wrapT]),(x===i.TEXTURE_3D||x===i.TEXTURE_2D_ARRAY)&&i.texParameteri(x,i.TEXTURE_WRAP_R,eA[D.wrapR]),i.texParameteri(x,i.TEXTURE_MAG_FILTER,oA[D.magFilter]),i.texParameteri(x,i.TEXTURE_MIN_FILTER,oA[D.minFilter]),D.compareFunction&&(i.texParameteri(x,i.TEXTURE_COMPARE_MODE,i.COMPARE_REF_TO_TEXTURE),i.texParameteri(x,i.TEXTURE_COMPARE_FUNC,gA[D.compareFunction])),A.has("EXT_texture_filter_anisotropic")===!0){if(D.magFilter===Te||D.minFilter!==xn&&D.minFilter!==Ot||D.type===lt&&A.has("OES_texture_float_linear")===!1)return;if(D.anisotropy>1||t.get(D).__currentAnisotropy){const Y=A.get("EXT_texture_filter_anisotropic");i.texParameterf(x,Y.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(D.anisotropy,n.getMaxAnisotropy())),t.get(D).__currentAnisotropy=D.anisotropy}}}function qA(x,D){let Y=!1;x.__webglInit===void 0&&(x.__webglInit=!0,D.addEventListener("dispose",S));const $=D.source;let tA=C.get($);tA===void 0&&(tA={},C.set($,tA));const j=_(D);if(j!==x.__cacheKey){tA[j]===void 0&&(tA[j]={texture:i.createTexture(),usedTimes:0},o.memory.textures++,Y=!0),tA[j].usedTimes++;const RA=tA[x.__cacheKey];RA!==void 0&&(tA[x.__cacheKey].usedTimes--,RA.usedTimes===0&&u(D)),x.__cacheKey=j,x.__webglTexture=tA[j].texture}return Y}function X(x,D,Y){let $=i.TEXTURE_2D;(D.isDataArrayTexture||D.isCompressedArrayTexture)&&($=i.TEXTURE_2D_ARRAY),D.isData3DTexture&&($=i.TEXTURE_3D);const tA=qA(x,D),j=D.source;e.bindTexture($,x.__webglTexture,i.TEXTURE0+Y);const RA=t.get(j);if(j.version!==RA.__version||tA===!0){e.activeTexture(i.TEXTURE0+Y);const CA=$A.getPrimaries($A.workingColorSpace),cA=D.colorSpace===ii?null:$A.getPrimaries(D.colorSpace),ZA=D.colorSpace===ii||CA===cA?i.NONE:i.BROWSER_DEFAULT_WEBGL;i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL,D.flipY),i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL,D.premultiplyAlpha),i.pixelStorei(i.UNPACK_ALIGNMENT,D.unpackAlignment),i.pixelStorei(i.UNPACK_COLORSPACE_CONVERSION_WEBGL,ZA);let nA=l(D.image,!1,n.maxTextureSize);nA=Ie(D,nA);const dA=s.convert(D.format,D.colorSpace),NA=s.convert(D.type);let K=p(D.internalFormat,dA,NA,D.colorSpace,D.isVideoTexture);pA($,D);let J;const lA=D.mipmaps,uA=D.isVideoTexture!==!0,kA=RA.__version===void 0||tA===!0,v=j.dataReady,iA=w(D,nA);if(D.isDepthTexture)K=d(D.format===gn,D.type),kA&&(uA?e.texStorage2D(i.TEXTURE_2D,1,K,nA.width,nA.height):e.texImage2D(i.TEXTURE_2D,0,K,nA.width,nA.height,0,dA,NA,null));else if(D.isDataTexture)if(lA.length>0){uA&&kA&&e.texStorage2D(i.TEXTURE_2D,iA,K,lA[0].width,lA[0].height);for(let q=0,Z=lA.length;q<Z;q++)J=lA[q],uA?v&&e.texSubImage2D(i.TEXTURE_2D,q,0,0,J.width,J.height,dA,NA,J.data):e.texImage2D(i.TEXTURE_2D,q,K,J.width,J.height,0,dA,NA,J.data);D.generateMipmaps=!1}else uA?(kA&&e.texStorage2D(i.TEXTURE_2D,iA,K,nA.width,nA.height),v&&e.texSubImage2D(i.TEXTURE_2D,0,0,0,nA.width,nA.height,dA,NA,nA.data)):e.texImage2D(i.TEXTURE_2D,0,K,nA.width,nA.height,0,dA,NA,nA.data);else if(D.isCompressedTexture)if(D.isCompressedArrayTexture){uA&&kA&&e.texStorage3D(i.TEXTURE_2D_ARRAY,iA,K,lA[0].width,lA[0].height,nA.depth);for(let q=0,Z=lA.length;q<Z;q++)if(J=lA[q],D.format!==et)if(dA!==null)if(uA){if(v)if(D.layerUpdates.size>0){const IA=bg(J.width,J.height,D.format,D.type);for(const BA of D.layerUpdates){const HA=J.data.subarray(BA*IA/J.data.BYTES_PER_ELEMENT,(BA+1)*IA/J.data.BYTES_PER_ELEMENT);e.compressedTexSubImage3D(i.TEXTURE_2D_ARRAY,q,0,0,BA,J.width,J.height,1,dA,HA)}D.clearLayerUpdates()}else e.compressedTexSubImage3D(i.TEXTURE_2D_ARRAY,q,0,0,0,J.width,J.height,nA.depth,dA,J.data)}else e.compressedTexImage3D(i.TEXTURE_2D_ARRAY,q,K,J.width,J.height,nA.depth,0,J.data,0,0);else console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");else uA?v&&e.texSubImage3D(i.TEXTURE_2D_ARRAY,q,0,0,0,J.width,J.height,nA.depth,dA,NA,J.data):e.texImage3D(i.TEXTURE_2D_ARRAY,q,K,J.width,J.height,nA.depth,0,dA,NA,J.data)}else{uA&&kA&&e.texStorage2D(i.TEXTURE_2D,iA,K,lA[0].width,lA[0].height);for(let q=0,Z=lA.length;q<Z;q++)J=lA[q],D.format!==et?dA!==null?uA?v&&e.compressedTexSubImage2D(i.TEXTURE_2D,q,0,0,J.width,J.height,dA,J.data):e.compressedTexImage2D(i.TEXTURE_2D,q,K,J.width,J.height,0,J.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):uA?v&&e.texSubImage2D(i.TEXTURE_2D,q,0,0,J.width,J.height,dA,NA,J.data):e.texImage2D(i.TEXTURE_2D,q,K,J.width,J.height,0,dA,NA,J.data)}else if(D.isDataArrayTexture)if(uA){if(kA&&e.texStorage3D(i.TEXTURE_2D_ARRAY,iA,K,nA.width,nA.height,nA.depth),v)if(D.layerUpdates.size>0){const q=bg(nA.width,nA.height,D.format,D.type);for(const Z of D.layerUpdates){const IA=nA.data.subarray(Z*q/nA.data.BYTES_PER_ELEMENT,(Z+1)*q/nA.data.BYTES_PER_ELEMENT);e.texSubImage3D(i.TEXTURE_2D_ARRAY,0,0,0,Z,nA.width,nA.height,1,dA,NA,IA)}D.clearLayerUpdates()}else e.texSubImage3D(i.TEXTURE_2D_ARRAY,0,0,0,0,nA.width,nA.height,nA.depth,dA,NA,nA.data)}else e.texImage3D(i.TEXTURE_2D_ARRAY,0,K,nA.width,nA.height,nA.depth,0,dA,NA,nA.data);else if(D.isData3DTexture)uA?(kA&&e.texStorage3D(i.TEXTURE_3D,iA,K,nA.width,nA.height,nA.depth),v&&e.texSubImage3D(i.TEXTURE_3D,0,0,0,0,nA.width,nA.height,nA.depth,dA,NA,nA.data)):e.texImage3D(i.TEXTURE_3D,0,K,nA.width,nA.height,nA.depth,0,dA,NA,nA.data);else if(D.isFramebufferTexture){if(kA)if(uA)e.texStorage2D(i.TEXTURE_2D,iA,K,nA.width,nA.height);else{let q=nA.width,Z=nA.height;for(let IA=0;IA<iA;IA++)e.texImage2D(i.TEXTURE_2D,IA,K,q,Z,0,dA,NA,null),q>>=1,Z>>=1}}else if(lA.length>0){if(uA&&kA){const q=MA(lA[0]);e.texStorage2D(i.TEXTURE_2D,iA,K,q.width,q.height)}for(let q=0,Z=lA.length;q<Z;q++)J=lA[q],uA?v&&e.texSubImage2D(i.TEXTURE_2D,q,0,0,dA,NA,J):e.texImage2D(i.TEXTURE_2D,q,K,dA,NA,J);D.generateMipmaps=!1}else if(uA){if(kA){const q=MA(nA);e.texStorage2D(i.TEXTURE_2D,iA,K,q.width,q.height)}v&&e.texSubImage2D(i.TEXTURE_2D,0,0,0,dA,NA,nA)}else e.texImage2D(i.TEXTURE_2D,0,K,dA,NA,nA);B(D)&&c($),RA.__version=j.version,D.onUpdate&&D.onUpdate(D)}x.__version=D.version}function AA(x,D,Y){if(D.image.length!==6)return;const $=qA(x,D),tA=D.source;e.bindTexture(i.TEXTURE_CUBE_MAP,x.__webglTexture,i.TEXTURE0+Y);const j=t.get(tA);if(tA.version!==j.__version||$===!0){e.activeTexture(i.TEXTURE0+Y);const RA=$A.getPrimaries($A.workingColorSpace),CA=D.colorSpace===ii?null:$A.getPrimaries(D.colorSpace),cA=D.colorSpace===ii||RA===CA?i.NONE:i.BROWSER_DEFAULT_WEBGL;i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL,D.flipY),i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL,D.premultiplyAlpha),i.pixelStorei(i.UNPACK_ALIGNMENT,D.unpackAlignment),i.pixelStorei(i.UNPACK_COLORSPACE_CONVERSION_WEBGL,cA);const ZA=D.isCompressedTexture||D.image[0].isCompressedTexture,nA=D.image[0]&&D.image[0].isDataTexture,dA=[];for(let Z=0;Z<6;Z++)!ZA&&!nA?dA[Z]=l(D.image[Z],!0,n.maxCubemapSize):dA[Z]=nA?D.image[Z].image:D.image[Z],dA[Z]=Ie(D,dA[Z]);const NA=dA[0],K=s.convert(D.format,D.colorSpace),J=s.convert(D.type),lA=p(D.internalFormat,K,J,D.colorSpace),uA=D.isVideoTexture!==!0,kA=j.__version===void 0||$===!0,v=tA.dataReady;let iA=w(D,NA);pA(i.TEXTURE_CUBE_MAP,D);let q;if(ZA){uA&&kA&&e.texStorage2D(i.TEXTURE_CUBE_MAP,iA,lA,NA.width,NA.height);for(let Z=0;Z<6;Z++){q=dA[Z].mipmaps;for(let IA=0;IA<q.length;IA++){const BA=q[IA];D.format!==et?K!==null?uA?v&&e.compressedTexSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X+Z,IA,0,0,BA.width,BA.height,K,BA.data):e.compressedTexImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X+Z,IA,lA,BA.width,BA.height,0,BA.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):uA?v&&e.texSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X+Z,IA,0,0,BA.width,BA.height,K,J,BA.data):e.texImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X+Z,IA,lA,BA.width,BA.height,0,K,J,BA.data)}}}else{if(q=D.mipmaps,uA&&kA){q.length>0&&iA++;const Z=MA(dA[0]);e.texStorage2D(i.TEXTURE_CUBE_MAP,iA,lA,Z.width,Z.height)}for(let Z=0;Z<6;Z++)if(nA){uA?v&&e.texSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X+Z,0,0,0,dA[Z].width,dA[Z].height,K,J,dA[Z].data):e.texImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X+Z,0,lA,dA[Z].width,dA[Z].height,0,K,J,dA[Z].data);for(let IA=0;IA<q.length;IA++){const HA=q[IA].image[Z].image;uA?v&&e.texSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X+Z,IA+1,0,0,HA.width,HA.height,K,J,HA.data):e.texImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X+Z,IA+1,lA,HA.width,HA.height,0,K,J,HA.data)}}else{uA?v&&e.texSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X+Z,0,0,0,K,J,dA[Z]):e.texImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X+Z,0,lA,K,J,dA[Z]);for(let IA=0;IA<q.length;IA++){const BA=q[IA];uA?v&&e.texSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X+Z,IA+1,0,0,K,J,BA.image[Z]):e.texImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X+Z,IA+1,lA,K,J,BA.image[Z])}}}B(D)&&c(i.TEXTURE_CUBE_MAP),j.__version=tA.version,D.onUpdate&&D.onUpdate(D)}x.__version=D.version}function hA(x,D,Y,$,tA,j){const RA=s.convert(Y.format,Y.colorSpace),CA=s.convert(Y.type),cA=p(Y.internalFormat,RA,CA,Y.colorSpace),ZA=t.get(D),nA=t.get(Y);if(nA.__renderTarget=D,!ZA.__hasExternalTextures){const dA=Math.max(1,D.width>>j),NA=Math.max(1,D.height>>j);tA===i.TEXTURE_3D||tA===i.TEXTURE_2D_ARRAY?e.texImage3D(tA,j,cA,dA,NA,D.depth,0,RA,CA,null):e.texImage2D(tA,j,cA,dA,NA,0,RA,CA,null)}e.bindFramebuffer(i.FRAMEBUFFER,x),JA(D)?r.framebufferTexture2DMultisampleEXT(i.FRAMEBUFFER,$,tA,nA.__webglTexture,0,VA(D)):(tA===i.TEXTURE_2D||tA>=i.TEXTURE_CUBE_MAP_POSITIVE_X&&tA<=i.TEXTURE_CUBE_MAP_NEGATIVE_Z)&&i.framebufferTexture2D(i.FRAMEBUFFER,$,tA,nA.__webglTexture,j),e.bindFramebuffer(i.FRAMEBUFFER,null)}function rA(x,D,Y){if(i.bindRenderbuffer(i.RENDERBUFFER,x),D.depthBuffer){const $=D.depthTexture,tA=$&&$.isDepthTexture?$.type:null,j=d(D.stencilBuffer,tA),RA=D.stencilBuffer?i.DEPTH_STENCIL_ATTACHMENT:i.DEPTH_ATTACHMENT,CA=VA(D);JA(D)?r.renderbufferStorageMultisampleEXT(i.RENDERBUFFER,CA,j,D.width,D.height):Y?i.renderbufferStorageMultisample(i.RENDERBUFFER,CA,j,D.width,D.height):i.renderbufferStorage(i.RENDERBUFFER,j,D.width,D.height),i.framebufferRenderbuffer(i.FRAMEBUFFER,RA,i.RENDERBUFFER,x)}else{const $=D.textures;for(let tA=0;tA<$.length;tA++){const j=$[tA],RA=s.convert(j.format,j.colorSpace),CA=s.convert(j.type),cA=p(j.internalFormat,RA,CA,j.colorSpace),ZA=VA(D);Y&&JA(D)===!1?i.renderbufferStorageMultisample(i.RENDERBUFFER,ZA,cA,D.width,D.height):JA(D)?r.renderbufferStorageMultisampleEXT(i.RENDERBUFFER,ZA,cA,D.width,D.height):i.renderbufferStorage(i.RENDERBUFFER,cA,D.width,D.height)}}i.bindRenderbuffer(i.RENDERBUFFER,null)}function mA(x,D){if(D&&D.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(e.bindFramebuffer(i.FRAMEBUFFER,x),!(D.depthTexture&&D.depthTexture.isDepthTexture))throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");const $=t.get(D.depthTexture);$.__renderTarget=D,(!$.__webglTexture||D.depthTexture.image.width!==D.width||D.depthTexture.image.height!==D.height)&&(D.depthTexture.image.width=D.width,D.depthTexture.image.height=D.height,D.depthTexture.needsUpdate=!0),P(D.depthTexture,0);const tA=$.__webglTexture,j=VA(D);if(D.depthTexture.format===$i)JA(D)?r.framebufferTexture2DMultisampleEXT(i.FRAMEBUFFER,i.DEPTH_ATTACHMENT,i.TEXTURE_2D,tA,0,j):i.framebufferTexture2D(i.FRAMEBUFFER,i.DEPTH_ATTACHMENT,i.TEXTURE_2D,tA,0);else if(D.depthTexture.format===gn)JA(D)?r.framebufferTexture2DMultisampleEXT(i.FRAMEBUFFER,i.DEPTH_STENCIL_ATTACHMENT,i.TEXTURE_2D,tA,0,j):i.framebufferTexture2D(i.FRAMEBUFFER,i.DEPTH_STENCIL_ATTACHMENT,i.TEXTURE_2D,tA,0);else throw new Error("Unknown depthTexture format")}function LA(x){const D=t.get(x),Y=x.isWebGLCubeRenderTarget===!0;if(D.__boundDepthTexture!==x.depthTexture){const $=x.depthTexture;if(D.__depthDisposeCallback&&D.__depthDisposeCallback(),$){const tA=()=>{delete D.__boundDepthTexture,delete D.__depthDisposeCallback,$.removeEventListener("dispose",tA)};$.addEventListener("dispose",tA),D.__depthDisposeCallback=tA}D.__boundDepthTexture=$}if(x.depthTexture&&!D.__autoAllocateDepthBuffer){if(Y)throw new Error("target.depthTexture not supported in Cube render targets");mA(D.__webglFramebuffer,x)}else if(Y){D.__webglDepthbuffer=[];for(let $=0;$<6;$++)if(e.bindFramebuffer(i.FRAMEBUFFER,D.__webglFramebuffer[$]),D.__webglDepthbuffer[$]===void 0)D.__webglDepthbuffer[$]=i.createRenderbuffer(),rA(D.__webglDepthbuffer[$],x,!1);else{const tA=x.stencilBuffer?i.DEPTH_STENCIL_ATTACHMENT:i.DEPTH_ATTACHMENT,j=D.__webglDepthbuffer[$];i.bindRenderbuffer(i.RENDERBUFFER,j),i.framebufferRenderbuffer(i.FRAMEBUFFER,tA,i.RENDERBUFFER,j)}}else if(e.bindFramebuffer(i.FRAMEBUFFER,D.__webglFramebuffer),D.__webglDepthbuffer===void 0)D.__webglDepthbuffer=i.createRenderbuffer(),rA(D.__webglDepthbuffer,x,!1);else{const $=x.stencilBuffer?i.DEPTH_STENCIL_ATTACHMENT:i.DEPTH_ATTACHMENT,tA=D.__webglDepthbuffer;i.bindRenderbuffer(i.RENDERBUFFER,tA),i.framebufferRenderbuffer(i.FRAMEBUFFER,$,i.RENDERBUFFER,tA)}e.bindFramebuffer(i.FRAMEBUFFER,null)}function EA(x,D,Y){const $=t.get(x);D!==void 0&&hA($.__webglFramebuffer,x,x.texture,i.COLOR_ATTACHMENT0,i.TEXTURE_2D,0),Y!==void 0&&LA(x)}function xA(x){const D=x.texture,Y=t.get(x),$=t.get(D);x.addEventListener("dispose",F);const tA=x.textures,j=x.isWebGLCubeRenderTarget===!0,RA=tA.length>1;if(RA||($.__webglTexture===void 0&&($.__webglTexture=i.createTexture()),$.__version=D.version,o.memory.textures++),j){Y.__webglFramebuffer=[];for(let CA=0;CA<6;CA++)if(D.mipmaps&&D.mipmaps.length>0){Y.__webglFramebuffer[CA]=[];for(let cA=0;cA<D.mipmaps.length;cA++)Y.__webglFramebuffer[CA][cA]=i.createFramebuffer()}else Y.__webglFramebuffer[CA]=i.createFramebuffer()}else{if(D.mipmaps&&D.mipmaps.length>0){Y.__webglFramebuffer=[];for(let CA=0;CA<D.mipmaps.length;CA++)Y.__webglFramebuffer[CA]=i.createFramebuffer()}else Y.__webglFramebuffer=i.createFramebuffer();if(RA)for(let CA=0,cA=tA.length;CA<cA;CA++){const ZA=t.get(tA[CA]);ZA.__webglTexture===void 0&&(ZA.__webglTexture=i.createTexture(),o.memory.textures++)}if(x.samples>0&&JA(x)===!1){Y.__webglMultisampledFramebuffer=i.createFramebuffer(),Y.__webglColorRenderbuffer=[],e.bindFramebuffer(i.FRAMEBUFFER,Y.__webglMultisampledFramebuffer);for(let CA=0;CA<tA.length;CA++){const cA=tA[CA];Y.__webglColorRenderbuffer[CA]=i.createRenderbuffer(),i.bindRenderbuffer(i.RENDERBUFFER,Y.__webglColorRenderbuffer[CA]);const ZA=s.convert(cA.format,cA.colorSpace),nA=s.convert(cA.type),dA=p(cA.internalFormat,ZA,nA,cA.colorSpace,x.isXRRenderTarget===!0),NA=VA(x);i.renderbufferStorageMultisample(i.RENDERBUFFER,NA,dA,x.width,x.height),i.framebufferRenderbuffer(i.FRAMEBUFFER,i.COLOR_ATTACHMENT0+CA,i.RENDERBUFFER,Y.__webglColorRenderbuffer[CA])}i.bindRenderbuffer(i.RENDERBUFFER,null),x.depthBuffer&&(Y.__webglDepthRenderbuffer=i.createRenderbuffer(),rA(Y.__webglDepthRenderbuffer,x,!0)),e.bindFramebuffer(i.FRAMEBUFFER,null)}}if(j){e.bindTexture(i.TEXTURE_CUBE_MAP,$.__webglTexture),pA(i.TEXTURE_CUBE_MAP,D);for(let CA=0;CA<6;CA++)if(D.mipmaps&&D.mipmaps.length>0)for(let cA=0;cA<D.mipmaps.length;cA++)hA(Y.__webglFramebuffer[CA][cA],x,D,i.COLOR_ATTACHMENT0,i.TEXTURE_CUBE_MAP_POSITIVE_X+CA,cA);else hA(Y.__webglFramebuffer[CA],x,D,i.COLOR_ATTACHMENT0,i.TEXTURE_CUBE_MAP_POSITIVE_X+CA,0);B(D)&&c(i.TEXTURE_CUBE_MAP),e.unbindTexture()}else if(RA){for(let CA=0,cA=tA.length;CA<cA;CA++){const ZA=tA[CA],nA=t.get(ZA);e.bindTexture(i.TEXTURE_2D,nA.__webglTexture),pA(i.TEXTURE_2D,ZA),hA(Y.__webglFramebuffer,x,ZA,i.COLOR_ATTACHMENT0+CA,i.TEXTURE_2D,0),B(ZA)&&c(i.TEXTURE_2D)}e.unbindTexture()}else{let CA=i.TEXTURE_2D;if((x.isWebGL3DRenderTarget||x.isWebGLArrayRenderTarget)&&(CA=x.isWebGL3DRenderTarget?i.TEXTURE_3D:i.TEXTURE_2D_ARRAY),e.bindTexture(CA,$.__webglTexture),pA(CA,D),D.mipmaps&&D.mipmaps.length>0)for(let cA=0;cA<D.mipmaps.length;cA++)hA(Y.__webglFramebuffer[cA],x,D,i.COLOR_ATTACHMENT0,CA,cA);else hA(Y.__webglFramebuffer,x,D,i.COLOR_ATTACHMENT0,CA,0);B(D)&&c(CA),e.unbindTexture()}x.depthBuffer&&LA(x)}function yA(x){const D=x.textures;for(let Y=0,$=D.length;Y<$;Y++){const tA=D[Y];if(B(tA)){const j=R(x),RA=t.get(tA).__webglTexture;e.bindTexture(j,RA),c(j),e.unbindTexture()}}}const WA=[],U=[];function ke(x){if(x.samples>0){if(JA(x)===!1){const D=x.textures,Y=x.width,$=x.height;let tA=i.COLOR_BUFFER_BIT;const j=x.stencilBuffer?i.DEPTH_STENCIL_ATTACHMENT:i.DEPTH_ATTACHMENT,RA=t.get(x),CA=D.length>1;if(CA)for(let cA=0;cA<D.length;cA++)e.bindFramebuffer(i.FRAMEBUFFER,RA.__webglMultisampledFramebuffer),i.framebufferRenderbuffer(i.FRAMEBUFFER,i.COLOR_ATTACHMENT0+cA,i.RENDERBUFFER,null),e.bindFramebuffer(i.FRAMEBUFFER,RA.__webglFramebuffer),i.framebufferTexture2D(i.DRAW_FRAMEBUFFER,i.COLOR_ATTACHMENT0+cA,i.TEXTURE_2D,null,0);e.bindFramebuffer(i.READ_FRAMEBUFFER,RA.__webglMultisampledFramebuffer),e.bindFramebuffer(i.DRAW_FRAMEBUFFER,RA.__webglFramebuffer);for(let cA=0;cA<D.length;cA++){if(x.resolveDepthBuffer&&(x.depthBuffer&&(tA|=i.DEPTH_BUFFER_BIT),x.stencilBuffer&&x.resolveStencilBuffer&&(tA|=i.STENCIL_BUFFER_BIT)),CA){i.framebufferRenderbuffer(i.READ_FRAMEBUFFER,i.COLOR_ATTACHMENT0,i.RENDERBUFFER,RA.__webglColorRenderbuffer[cA]);const ZA=t.get(D[cA]).__webglTexture;i.framebufferTexture2D(i.DRAW_FRAMEBUFFER,i.COLOR_ATTACHMENT0,i.TEXTURE_2D,ZA,0)}i.blitFramebuffer(0,0,Y,$,0,0,Y,$,tA,i.NEAREST),a===!0&&(WA.length=0,U.length=0,WA.push(i.COLOR_ATTACHMENT0+cA),x.depthBuffer&&x.resolveDepthBuffer===!1&&(WA.push(j),U.push(j),i.invalidateFramebuffer(i.DRAW_FRAMEBUFFER,U)),i.invalidateFramebuffer(i.READ_FRAMEBUFFER,WA))}if(e.bindFramebuffer(i.READ_FRAMEBUFFER,null),e.bindFramebuffer(i.DRAW_FRAMEBUFFER,null),CA)for(let cA=0;cA<D.length;cA++){e.bindFramebuffer(i.FRAMEBUFFER,RA.__webglMultisampledFramebuffer),i.framebufferRenderbuffer(i.FRAMEBUFFER,i.COLOR_ATTACHMENT0+cA,i.RENDERBUFFER,RA.__webglColorRenderbuffer[cA]);const ZA=t.get(D[cA]).__webglTexture;e.bindFramebuffer(i.FRAMEBUFFER,RA.__webglFramebuffer),i.framebufferTexture2D(i.DRAW_FRAMEBUFFER,i.COLOR_ATTACHMENT0+cA,i.TEXTURE_2D,ZA,0)}e.bindFramebuffer(i.DRAW_FRAMEBUFFER,RA.__webglMultisampledFramebuffer)}else if(x.depthBuffer&&x.resolveDepthBuffer===!1&&a){const D=x.stencilBuffer?i.DEPTH_STENCIL_ATTACHMENT:i.DEPTH_ATTACHMENT;i.invalidateFramebuffer(i.DRAW_FRAMEBUFFER,[D])}}}function VA(x){return Math.min(n.maxSamples,x.samples)}function JA(x){const D=t.get(x);return x.samples>0&&A.has("WEBGL_multisampled_render_to_texture")===!0&&D.__useRenderToTexture!==!1}function wA(x){const D=o.render.frame;I.get(x)!==D&&(I.set(x,D),x.update())}function Ie(x,D){const Y=x.colorSpace,$=x.format,tA=x.type;return x.isCompressedTexture===!0||x.isVideoTexture===!0||Y!==be&&Y!==ii&&($A.getTransfer(Y)===ge?($!==et||tA!==qt)&&console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."):console.error("THREE.WebGLTextures: Unsupported texture color space:",Y)),D}function MA(x){return typeof HTMLImageElement<"u"&&x instanceof HTMLImageElement?(g.width=x.naturalWidth||x.width,g.height=x.naturalHeight||x.height):typeof VideoFrame<"u"&&x instanceof VideoFrame?(g.width=x.displayWidth,g.height=x.displayHeight):(g.width=x.width,g.height=x.height),g}this.allocateTextureUnit=M,this.resetTextureUnits=T,this.setTexture2D=P,this.setTexture2DArray=b,this.setTexture3D=z,this.setTextureCube=O,this.rebindTextures=EA,this.setupRenderTarget=xA,this.updateRenderTargetMipmap=yA,this.updateMultisampleRenderTarget=ke,this.setupDepthRenderbuffer=LA,this.setupFrameBufferTexture=hA,this.useMultisampledRTT=JA}function qu(i,A){function e(t,n=ii){let s;const o=$A.getTransfer(n);if(t===qt)return i.UNSIGNED_BYTE;if(t===oa)return i.UNSIGNED_SHORT_4_4_4_4;if(t===ra)return i.UNSIGNED_SHORT_5_5_5_1;if(t===IE)return i.UNSIGNED_INT_5_9_9_9_REV;if(t===aE)return i.BYTE;if(t===gE)return i.SHORT;if(t===Hn)return i.UNSIGNED_SHORT;if(t===sa)return i.INT;if(t===Oe)return i.UNSIGNED_INT;if(t===lt)return i.FLOAT;if(t===qn)return i.HALF_FLOAT;if(t===EE)return i.ALPHA;if(t===CE)return i.RGB;if(t===et)return i.RGBA;if(t===QE)return i.LUMINANCE;if(t===BE)return i.LUMINANCE_ALPHA;if(t===$i)return i.DEPTH_COMPONENT;if(t===gn)return i.DEPTH_STENCIL;if(t===aa)return i.RED;if(t===ga)return i.RED_INTEGER;if(t===cE)return i.RG;if(t===Ia)return i.RG_INTEGER;if(t===mt)return i.RGBA_INTEGER;if(t===_s||t===Us||t===Gs||t===vs)if(o===ge)if(s=A.get("WEBGL_compressed_texture_s3tc_srgb"),s!==null){if(t===_s)return s.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(t===Us)return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(t===Gs)return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(t===vs)return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}else return null;else if(s=A.get("WEBGL_compressed_texture_s3tc"),s!==null){if(t===_s)return s.COMPRESSED_RGB_S3TC_DXT1_EXT;if(t===Us)return s.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(t===Gs)return s.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(t===vs)return s.COMPRESSED_RGBA_S3TC_DXT5_EXT}else return null;if(t===hr||t===lr||t===dr||t===ur)if(s=A.get("WEBGL_compressed_texture_pvrtc"),s!==null){if(t===hr)return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(t===lr)return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(t===dr)return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(t===ur)return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}else return null;if(t===fr||t===pr||t===Dr)if(s=A.get("WEBGL_compressed_texture_etc"),s!==null){if(t===fr||t===pr)return o===ge?s.COMPRESSED_SRGB8_ETC2:s.COMPRESSED_RGB8_ETC2;if(t===Dr)return o===ge?s.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:s.COMPRESSED_RGBA8_ETC2_EAC}else return null;if(t===mr||t===yr||t===Rr||t===wr||t===Sr||t===Mr||t===Nr||t===xr||t===Fr||t===Lr||t===_r||t===Ur||t===Gr||t===vr)if(s=A.get("WEBGL_compressed_texture_astc"),s!==null){if(t===mr)return o===ge?s.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:s.COMPRESSED_RGBA_ASTC_4x4_KHR;if(t===yr)return o===ge?s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:s.COMPRESSED_RGBA_ASTC_5x4_KHR;if(t===Rr)return o===ge?s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:s.COMPRESSED_RGBA_ASTC_5x5_KHR;if(t===wr)return o===ge?s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:s.COMPRESSED_RGBA_ASTC_6x5_KHR;if(t===Sr)return o===ge?s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:s.COMPRESSED_RGBA_ASTC_6x6_KHR;if(t===Mr)return o===ge?s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:s.COMPRESSED_RGBA_ASTC_8x5_KHR;if(t===Nr)return o===ge?s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:s.COMPRESSED_RGBA_ASTC_8x6_KHR;if(t===xr)return o===ge?s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:s.COMPRESSED_RGBA_ASTC_8x8_KHR;if(t===Fr)return o===ge?s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:s.COMPRESSED_RGBA_ASTC_10x5_KHR;if(t===Lr)return o===ge?s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:s.COMPRESSED_RGBA_ASTC_10x6_KHR;if(t===_r)return o===ge?s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:s.COMPRESSED_RGBA_ASTC_10x8_KHR;if(t===Ur)return o===ge?s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:s.COMPRESSED_RGBA_ASTC_10x10_KHR;if(t===Gr)return o===ge?s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:s.COMPRESSED_RGBA_ASTC_12x10_KHR;if(t===vr)return o===ge?s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:s.COMPRESSED_RGBA_ASTC_12x12_KHR}else return null;if(t===Ts||t===Tr||t===br)if(s=A.get("EXT_texture_compression_bptc"),s!==null){if(t===Ts)return o===ge?s.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:s.COMPRESSED_RGBA_BPTC_UNORM_EXT;if(t===Tr)return s.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;if(t===br)return s.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT}else return null;if(t===hE||t===kr||t===Hr||t===Pr)if(s=A.get("EXT_texture_compression_rgtc"),s!==null){if(t===Ts)return s.COMPRESSED_RED_RGTC1_EXT;if(t===kr)return s.COMPRESSED_SIGNED_RED_RGTC1_EXT;if(t===Hr)return s.COMPRESSED_RED_GREEN_RGTC2_EXT;if(t===Pr)return s.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT}else return null;return t===an?i.UNSIGNED_INT_24_8:i[t]!==void 0?i[t]:null}return{convert:e}}const Wu={type:"move"};class Jo{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return this._hand===null&&(this._hand=new yi,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return this._targetRay===null&&(this._targetRay=new yi,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new L,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new L),this._targetRay}getGripSpace(){return this._grip===null&&(this._grip=new yi,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new L,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new L),this._grip}dispatchEvent(A){return this._targetRay!==null&&this._targetRay.dispatchEvent(A),this._grip!==null&&this._grip.dispatchEvent(A),this._hand!==null&&this._hand.dispatchEvent(A),this}connect(A){if(A&&A.hand){const e=this._hand;if(e)for(const t of A.hand.values())this._getHandJoint(e,t)}return this.dispatchEvent({type:"connected",data:A}),this}disconnect(A){return this.dispatchEvent({type:"disconnected",data:A}),this._targetRay!==null&&(this._targetRay.visible=!1),this._grip!==null&&(this._grip.visible=!1),this._hand!==null&&(this._hand.visible=!1),this}update(A,e,t){let n=null,s=null,o=null;const r=this._targetRay,a=this._grip,g=this._hand;if(A&&e.session.visibilityState!=="visible-blurred"){if(g&&A.hand){o=!0;for(const l of A.hand.values()){const B=e.getJointPose(l,t),c=this._getHandJoint(g,l);B!==null&&(c.matrix.fromArray(B.transform.matrix),c.matrix.decompose(c.position,c.rotation,c.scale),c.matrixWorldNeedsUpdate=!0,c.jointRadius=B.radius),c.visible=B!==null}const I=g.joints["index-finger-tip"],E=g.joints["thumb-tip"],C=I.position.distanceTo(E.position),Q=.02,h=.005;g.inputState.pinching&&C>Q+h?(g.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:A.handedness,target:this})):!g.inputState.pinching&&C<=Q-h&&(g.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:A.handedness,target:this}))}else a!==null&&A.gripSpace&&(s=e.getPose(A.gripSpace,t),s!==null&&(a.matrix.fromArray(s.transform.matrix),a.matrix.decompose(a.position,a.rotation,a.scale),a.matrixWorldNeedsUpdate=!0,s.linearVelocity?(a.hasLinearVelocity=!0,a.linearVelocity.copy(s.linearVelocity)):a.hasLinearVelocity=!1,s.angularVelocity?(a.hasAngularVelocity=!0,a.angularVelocity.copy(s.angularVelocity)):a.hasAngularVelocity=!1));r!==null&&(n=e.getPose(A.targetRaySpace,t),n===null&&s!==null&&(n=s),n!==null&&(r.matrix.fromArray(n.transform.matrix),r.matrix.decompose(r.position,r.rotation,r.scale),r.matrixWorldNeedsUpdate=!0,n.linearVelocity?(r.hasLinearVelocity=!0,r.linearVelocity.copy(n.linearVelocity)):r.hasLinearVelocity=!1,n.angularVelocity?(r.hasAngularVelocity=!0,r.angularVelocity.copy(n.angularVelocity)):r.hasAngularVelocity=!1,this.dispatchEvent(Wu)))}return r!==null&&(r.visible=n!==null),a!==null&&(a.visible=s!==null),g!==null&&(g.visible=o!==null),this}_getHandJoint(A,e){if(A.joints[e.jointName]===void 0){const t=new yi;t.matrixAutoUpdate=!1,t.visible=!1,A.joints[e.jointName]=t,A.add(t)}return A.joints[e.jointName]}}const Vu=`
void main() {

	gl_Position = vec4( position, 1.0 );

}`,zu=`
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;class Xu{constructor(){this.texture=null,this.mesh=null,this.depthNear=0,this.depthFar=0}init(A,e,t){if(this.texture===null){const n=new de,s=A.properties.get(n);s.__webglTexture=e.texture,(e.depthNear!=t.depthNear||e.depthFar!=t.depthFar)&&(this.depthNear=e.depthNear,this.depthFar=e.depthFar),this.texture=n}}getMesh(A){if(this.texture!==null&&this.mesh===null){const e=A.cameras[0].viewport,t=new Wt({vertexShader:Vu,fragmentShader:zu,uniforms:{depthColor:{value:this.texture},depthWidth:{value:e.z},depthHeight:{value:e.w}}});this.mesh=new ve(new Vn(20,20),t)}return this.mesh}reset(){this.texture=null,this.mesh=null}getDepthTexture(){return this.texture}}class Zu extends Si{constructor(A,e){super();const t=this;let n=null,s=1,o=null,r="local-floor",a=1,g=null,I=null,E=null,C=null,Q=null,h=null;const l=new Xu,B=e.getContextAttributes();let c=null,R=null;const p=[],d=[],w=new bA;let S=null;const F=new Le;F.viewport=new YA;const N=new Le;N.viewport=new YA;const u=[F,N],f=new nc;let m=null,T=null;this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(X){let AA=p[X];return AA===void 0&&(AA=new Jo,p[X]=AA),AA.getTargetRaySpace()},this.getControllerGrip=function(X){let AA=p[X];return AA===void 0&&(AA=new Jo,p[X]=AA),AA.getGripSpace()},this.getHand=function(X){let AA=p[X];return AA===void 0&&(AA=new Jo,p[X]=AA),AA.getHandSpace()};function M(X){const AA=d.indexOf(X.inputSource);if(AA===-1)return;const hA=p[AA];hA!==void 0&&(hA.update(X.inputSource,X.frame,g||o),hA.dispatchEvent({type:X.type,data:X.inputSource}))}function _(){n.removeEventListener("select",M),n.removeEventListener("selectstart",M),n.removeEventListener("selectend",M),n.removeEventListener("squeeze",M),n.removeEventListener("squeezestart",M),n.removeEventListener("squeezeend",M),n.removeEventListener("end",_),n.removeEventListener("inputsourceschange",P);for(let X=0;X<p.length;X++){const AA=d[X];AA!==null&&(d[X]=null,p[X].disconnect(AA))}m=null,T=null,l.reset(),A.setRenderTarget(c),Q=null,C=null,E=null,n=null,R=null,qA.stop(),t.isPresenting=!1,A.setPixelRatio(S),A.setSize(w.width,w.height,!1),t.dispatchEvent({type:"sessionend"})}this.setFramebufferScaleFactor=function(X){s=X,t.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(X){r=X,t.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return g||o},this.setReferenceSpace=function(X){g=X},this.getBaseLayer=function(){return C!==null?C:Q},this.getBinding=function(){return E},this.getFrame=function(){return h},this.getSession=function(){return n},this.setSession=async function(X){if(n=X,n!==null){if(c=A.getRenderTarget(),n.addEventListener("select",M),n.addEventListener("selectstart",M),n.addEventListener("selectend",M),n.addEventListener("squeeze",M),n.addEventListener("squeezestart",M),n.addEventListener("squeezeend",M),n.addEventListener("end",_),n.addEventListener("inputsourceschange",P),B.xrCompatible!==!0&&await e.makeXRCompatible(),S=A.getPixelRatio(),A.getSize(w),n.renderState.layers===void 0){const AA={antialias:B.antialias,alpha:!0,depth:B.depth,stencil:B.stencil,framebufferScaleFactor:s};Q=new XRWebGLLayer(n,e,AA),n.updateRenderState({baseLayer:Q}),A.setPixelRatio(1),A.setSize(Q.framebufferWidth,Q.framebufferHeight,!1),R=new wi(Q.framebufferWidth,Q.framebufferHeight,{format:et,type:qt,colorSpace:A.outputColorSpace,stencilBuffer:B.stencil})}else{let AA=null,hA=null,rA=null;B.depth&&(rA=B.stencil?e.DEPTH24_STENCIL8:e.DEPTH_COMPONENT24,AA=B.stencil?gn:$i,hA=B.stencil?an:Oe);const mA={colorFormat:e.RGBA8,depthFormat:rA,scaleFactor:s};E=new XRWebGLBinding(n,e),C=E.createProjectionLayer(mA),n.updateRenderState({layers:[C]}),A.setPixelRatio(1),A.setSize(C.textureWidth,C.textureHeight,!1),R=new wi(C.textureWidth,C.textureHeight,{format:et,type:qt,depthTexture:new _E(C.textureWidth,C.textureHeight,hA,void 0,void 0,void 0,void 0,void 0,void 0,AA),stencilBuffer:B.stencil,colorSpace:A.outputColorSpace,samples:B.antialias?4:0,resolveDepthBuffer:C.ignoreDepthValues===!1})}R.isXRRenderTarget=!0,this.setFoveation(a),g=null,o=await n.requestReferenceSpace(r),qA.setContext(n),qA.start(),t.isPresenting=!0,t.dispatchEvent({type:"sessionstart"})}},this.getEnvironmentBlendMode=function(){if(n!==null)return n.environmentBlendMode},this.getDepthTexture=function(){return l.getDepthTexture()};function P(X){for(let AA=0;AA<X.removed.length;AA++){const hA=X.removed[AA],rA=d.indexOf(hA);rA>=0&&(d[rA]=null,p[rA].disconnect(hA))}for(let AA=0;AA<X.added.length;AA++){const hA=X.added[AA];let rA=d.indexOf(hA);if(rA===-1){for(let LA=0;LA<p.length;LA++)if(LA>=d.length){d.push(hA),rA=LA;break}else if(d[LA]===null){d[LA]=hA,rA=LA;break}if(rA===-1)break}const mA=p[rA];mA&&mA.connect(hA)}}const b=new L,z=new L;function O(X,AA,hA){b.setFromMatrixPosition(AA.matrixWorld),z.setFromMatrixPosition(hA.matrixWorld);const rA=b.distanceTo(z),mA=AA.projectionMatrix.elements,LA=hA.projectionMatrix.elements,EA=mA[14]/(mA[10]-1),xA=mA[14]/(mA[10]+1),yA=(mA[9]+1)/mA[5],WA=(mA[9]-1)/mA[5],U=(mA[8]-1)/mA[0],ke=(LA[8]+1)/LA[0],VA=EA*U,JA=EA*ke,wA=rA/(-U+ke),Ie=wA*-U;if(AA.matrixWorld.decompose(X.position,X.quaternion,X.scale),X.translateX(Ie),X.translateZ(wA),X.matrixWorld.compose(X.position,X.quaternion,X.scale),X.matrixWorldInverse.copy(X.matrixWorld).invert(),mA[10]===-1)X.projectionMatrix.copy(AA.projectionMatrix),X.projectionMatrixInverse.copy(AA.projectionMatrixInverse);else{const MA=EA+wA,x=xA+wA,D=VA-Ie,Y=JA+(rA-Ie),$=yA*xA/x*MA,tA=WA*xA/x*MA;X.projectionMatrix.makePerspective(D,Y,$,tA,MA,x),X.projectionMatrixInverse.copy(X.projectionMatrix).invert()}}function eA(X,AA){AA===null?X.matrixWorld.copy(X.matrix):X.matrixWorld.multiplyMatrices(AA.matrixWorld,X.matrix),X.matrixWorldInverse.copy(X.matrixWorld).invert()}this.updateCamera=function(X){if(n===null)return;let AA=X.near,hA=X.far;l.texture!==null&&(l.depthNear>0&&(AA=l.depthNear),l.depthFar>0&&(hA=l.depthFar)),f.near=N.near=F.near=AA,f.far=N.far=F.far=hA,(m!==f.near||T!==f.far)&&(n.updateRenderState({depthNear:f.near,depthFar:f.far}),m=f.near,T=f.far),F.layers.mask=X.layers.mask|2,N.layers.mask=X.layers.mask|4,f.layers.mask=F.layers.mask|N.layers.mask;const rA=X.parent,mA=f.cameras;eA(f,rA);for(let LA=0;LA<mA.length;LA++)eA(mA[LA],rA);mA.length===2?O(f,F,N):f.projectionMatrix.copy(F.projectionMatrix),oA(X,f,rA)};function oA(X,AA,hA){hA===null?X.matrix.copy(AA.matrixWorld):(X.matrix.copy(hA.matrixWorld),X.matrix.invert(),X.matrix.multiply(AA.matrixWorld)),X.matrix.decompose(X.position,X.quaternion,X.scale),X.updateMatrixWorld(!0),X.projectionMatrix.copy(AA.projectionMatrix),X.projectionMatrixInverse.copy(AA.projectionMatrixInverse),X.isPerspectiveCamera&&(X.fov=In*2*Math.atan(1/X.projectionMatrix.elements[5]),X.zoom=1)}this.getCamera=function(){return f},this.getFoveation=function(){if(!(C===null&&Q===null))return a},this.setFoveation=function(X){a=X,C!==null&&(C.fixedFoveation=X),Q!==null&&Q.fixedFoveation!==void 0&&(Q.fixedFoveation=X)},this.hasDepthSensing=function(){return l.texture!==null},this.getDepthSensingMesh=function(){return l.getMesh(f)};let gA=null;function pA(X,AA){if(I=AA.getViewerPose(g||o),h=AA,I!==null){const hA=I.views;Q!==null&&(A.setRenderTargetFramebuffer(R,Q.framebuffer),A.setRenderTarget(R));let rA=!1;hA.length!==f.cameras.length&&(f.cameras.length=0,rA=!0);for(let LA=0;LA<hA.length;LA++){const EA=hA[LA];let xA=null;if(Q!==null)xA=Q.getViewport(EA);else{const WA=E.getViewSubImage(C,EA);xA=WA.viewport,LA===0&&(A.setRenderTargetTextures(R,WA.colorTexture,C.ignoreDepthValues?void 0:WA.depthStencilTexture),A.setRenderTarget(R))}let yA=u[LA];yA===void 0&&(yA=new Le,yA.layers.enable(LA),yA.viewport=new YA,u[LA]=yA),yA.matrix.fromArray(EA.transform.matrix),yA.matrix.decompose(yA.position,yA.quaternion,yA.scale),yA.projectionMatrix.fromArray(EA.projectionMatrix),yA.projectionMatrixInverse.copy(yA.projectionMatrix).invert(),yA.viewport.set(xA.x,xA.y,xA.width,xA.height),LA===0&&(f.matrix.copy(yA.matrix),f.matrix.decompose(f.position,f.quaternion,f.scale)),rA===!0&&f.cameras.push(yA)}const mA=n.enabledFeatures;if(mA&&mA.includes("depth-sensing")){const LA=E.getDepthInformation(hA[0]);LA&&LA.isValid&&LA.texture&&l.init(A,LA,n.renderState)}}for(let hA=0;hA<p.length;hA++){const rA=d[hA],mA=p[hA];rA!==null&&mA!==void 0&&mA.update(rA,AA,g||o)}gA&&gA(X,AA),AA.detectedPlanes&&t.dispatchEvent({type:"planesdetected",data:AA}),h=null}const qA=new kE;qA.setAnimationLoop(pA),this.setAnimationLoop=function(X){gA=X},this.dispose=function(){}}}const ui=new pt,ju=new UA;function $u(i,A){function e(B,c){B.matrixAutoUpdate===!0&&B.updateMatrix(),c.value.copy(B.matrix)}function t(B,c){c.color.getRGB(B.fogColor.value,RE(i)),c.isFog?(B.fogNear.value=c.near,B.fogFar.value=c.far):c.isFogExp2&&(B.fogDensity.value=c.density)}function n(B,c,R,p,d){c.isMeshBasicMaterial||c.isMeshLambertMaterial?s(B,c):c.isMeshToonMaterial?(s(B,c),E(B,c)):c.isMeshPhongMaterial?(s(B,c),I(B,c)):c.isMeshStandardMaterial?(s(B,c),C(B,c),c.isMeshPhysicalMaterial&&Q(B,c,d)):c.isMeshMatcapMaterial?(s(B,c),h(B,c)):c.isMeshDepthMaterial?s(B,c):c.isMeshDistanceMaterial?(s(B,c),l(B,c)):c.isMeshNormalMaterial?s(B,c):c.isLineBasicMaterial?(o(B,c),c.isLineDashedMaterial&&r(B,c)):c.isPointsMaterial?a(B,c,R,p):c.isSpriteMaterial?g(B,c):c.isShadowMaterial?(B.color.value.copy(c.color),B.opacity.value=c.opacity):c.isShaderMaterial&&(c.uniformsNeedUpdate=!1)}function s(B,c){B.opacity.value=c.opacity,c.color&&B.diffuse.value.copy(c.color),c.emissive&&B.emissive.value.copy(c.emissive).multiplyScalar(c.emissiveIntensity),c.map&&(B.map.value=c.map,e(c.map,B.mapTransform)),c.alphaMap&&(B.alphaMap.value=c.alphaMap,e(c.alphaMap,B.alphaMapTransform)),c.bumpMap&&(B.bumpMap.value=c.bumpMap,e(c.bumpMap,B.bumpMapTransform),B.bumpScale.value=c.bumpScale,c.side===Je&&(B.bumpScale.value*=-1)),c.normalMap&&(B.normalMap.value=c.normalMap,e(c.normalMap,B.normalMapTransform),B.normalScale.value.copy(c.normalScale),c.side===Je&&B.normalScale.value.negate()),c.displacementMap&&(B.displacementMap.value=c.displacementMap,e(c.displacementMap,B.displacementMapTransform),B.displacementScale.value=c.displacementScale,B.displacementBias.value=c.displacementBias),c.emissiveMap&&(B.emissiveMap.value=c.emissiveMap,e(c.emissiveMap,B.emissiveMapTransform)),c.specularMap&&(B.specularMap.value=c.specularMap,e(c.specularMap,B.specularMapTransform)),c.alphaTest>0&&(B.alphaTest.value=c.alphaTest);const R=A.get(c),p=R.envMap,d=R.envMapRotation;p&&(B.envMap.value=p,ui.copy(d),ui.x*=-1,ui.y*=-1,ui.z*=-1,p.isCubeTexture&&p.isRenderTargetTexture===!1&&(ui.y*=-1,ui.z*=-1),B.envMapRotation.value.setFromMatrix4(ju.makeRotationFromEuler(ui)),B.flipEnvMap.value=p.isCubeTexture&&p.isRenderTargetTexture===!1?-1:1,B.reflectivity.value=c.reflectivity,B.ior.value=c.ior,B.refractionRatio.value=c.refractionRatio),c.lightMap&&(B.lightMap.value=c.lightMap,B.lightMapIntensity.value=c.lightMapIntensity,e(c.lightMap,B.lightMapTransform)),c.aoMap&&(B.aoMap.value=c.aoMap,B.aoMapIntensity.value=c.aoMapIntensity,e(c.aoMap,B.aoMapTransform))}function o(B,c){B.diffuse.value.copy(c.color),B.opacity.value=c.opacity,c.map&&(B.map.value=c.map,e(c.map,B.mapTransform))}function r(B,c){B.dashSize.value=c.dashSize,B.totalSize.value=c.dashSize+c.gapSize,B.scale.value=c.scale}function a(B,c,R,p){B.diffuse.value.copy(c.color),B.opacity.value=c.opacity,B.size.value=c.size*R,B.scale.value=p*.5,c.map&&(B.map.value=c.map,e(c.map,B.uvTransform)),c.alphaMap&&(B.alphaMap.value=c.alphaMap,e(c.alphaMap,B.alphaMapTransform)),c.alphaTest>0&&(B.alphaTest.value=c.alphaTest)}function g(B,c){B.diffuse.value.copy(c.color),B.opacity.value=c.opacity,B.rotation.value=c.rotation,c.map&&(B.map.value=c.map,e(c.map,B.mapTransform)),c.alphaMap&&(B.alphaMap.value=c.alphaMap,e(c.alphaMap,B.alphaMapTransform)),c.alphaTest>0&&(B.alphaTest.value=c.alphaTest)}function I(B,c){B.specular.value.copy(c.specular),B.shininess.value=Math.max(c.shininess,1e-4)}function E(B,c){c.gradientMap&&(B.gradientMap.value=c.gradientMap)}function C(B,c){B.metalness.value=c.metalness,c.metalnessMap&&(B.metalnessMap.value=c.metalnessMap,e(c.metalnessMap,B.metalnessMapTransform)),B.roughness.value=c.roughness,c.roughnessMap&&(B.roughnessMap.value=c.roughnessMap,e(c.roughnessMap,B.roughnessMapTransform)),c.envMap&&(B.envMapIntensity.value=c.envMapIntensity)}function Q(B,c,R){B.ior.value=c.ior,c.sheen>0&&(B.sheenColor.value.copy(c.sheenColor).multiplyScalar(c.sheen),B.sheenRoughness.value=c.sheenRoughness,c.sheenColorMap&&(B.sheenColorMap.value=c.sheenColorMap,e(c.sheenColorMap,B.sheenColorMapTransform)),c.sheenRoughnessMap&&(B.sheenRoughnessMap.value=c.sheenRoughnessMap,e(c.sheenRoughnessMap,B.sheenRoughnessMapTransform))),c.clearcoat>0&&(B.clearcoat.value=c.clearcoat,B.clearcoatRoughness.value=c.clearcoatRoughness,c.clearcoatMap&&(B.clearcoatMap.value=c.clearcoatMap,e(c.clearcoatMap,B.clearcoatMapTransform)),c.clearcoatRoughnessMap&&(B.clearcoatRoughnessMap.value=c.clearcoatRoughnessMap,e(c.clearcoatRoughnessMap,B.clearcoatRoughnessMapTransform)),c.clearcoatNormalMap&&(B.clearcoatNormalMap.value=c.clearcoatNormalMap,e(c.clearcoatNormalMap,B.clearcoatNormalMapTransform),B.clearcoatNormalScale.value.copy(c.clearcoatNormalScale),c.side===Je&&B.clearcoatNormalScale.value.negate())),c.dispersion>0&&(B.dispersion.value=c.dispersion),c.iridescence>0&&(B.iridescence.value=c.iridescence,B.iridescenceIOR.value=c.iridescenceIOR,B.iridescenceThicknessMinimum.value=c.iridescenceThicknessRange[0],B.iridescenceThicknessMaximum.value=c.iridescenceThicknessRange[1],c.iridescenceMap&&(B.iridescenceMap.value=c.iridescenceMap,e(c.iridescenceMap,B.iridescenceMapTransform)),c.iridescenceThicknessMap&&(B.iridescenceThicknessMap.value=c.iridescenceThicknessMap,e(c.iridescenceThicknessMap,B.iridescenceThicknessMapTransform))),c.transmission>0&&(B.transmission.value=c.transmission,B.transmissionSamplerMap.value=R.texture,B.transmissionSamplerSize.value.set(R.width,R.height),c.transmissionMap&&(B.transmissionMap.value=c.transmissionMap,e(c.transmissionMap,B.transmissionMapTransform)),B.thickness.value=c.thickness,c.thicknessMap&&(B.thicknessMap.value=c.thicknessMap,e(c.thicknessMap,B.thicknessMapTransform)),B.attenuationDistance.value=c.attenuationDistance,B.attenuationColor.value.copy(c.attenuationColor)),c.anisotropy>0&&(B.anisotropyVector.value.set(c.anisotropy*Math.cos(c.anisotropyRotation),c.anisotropy*Math.sin(c.anisotropyRotation)),c.anisotropyMap&&(B.anisotropyMap.value=c.anisotropyMap,e(c.anisotropyMap,B.anisotropyMapTransform))),B.specularIntensity.value=c.specularIntensity,B.specularColor.value.copy(c.specularColor),c.specularColorMap&&(B.specularColorMap.value=c.specularColorMap,e(c.specularColorMap,B.specularColorMapTransform)),c.specularIntensityMap&&(B.specularIntensityMap.value=c.specularIntensityMap,e(c.specularIntensityMap,B.specularIntensityMapTransform))}function h(B,c){c.matcap&&(B.matcap.value=c.matcap)}function l(B,c){const R=A.get(c).light;B.referencePosition.value.setFromMatrixPosition(R.matrixWorld),B.nearDistance.value=R.shadow.camera.near,B.farDistance.value=R.shadow.camera.far}return{refreshFogUniforms:t,refreshMaterialUniforms:n}}function Af(i,A,e,t){let n={},s={},o=[];const r=i.getParameter(i.MAX_UNIFORM_BUFFER_BINDINGS);function a(R,p){const d=p.program;t.uniformBlockBinding(R,d)}function g(R,p){let d=n[R.id];d===void 0&&(h(R),d=I(R),n[R.id]=d,R.addEventListener("dispose",B));const w=p.program;t.updateUBOMapping(R,w);const S=A.render.frame;s[R.id]!==S&&(C(R),s[R.id]=S)}function I(R){const p=E();R.__bindingPointIndex=p;const d=i.createBuffer(),w=R.__size,S=R.usage;return i.bindBuffer(i.UNIFORM_BUFFER,d),i.bufferData(i.UNIFORM_BUFFER,w,S),i.bindBuffer(i.UNIFORM_BUFFER,null),i.bindBufferBase(i.UNIFORM_BUFFER,p,d),d}function E(){for(let R=0;R<r;R++)if(o.indexOf(R)===-1)return o.push(R),R;return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),0}function C(R){const p=n[R.id],d=R.uniforms,w=R.__cache;i.bindBuffer(i.UNIFORM_BUFFER,p);for(let S=0,F=d.length;S<F;S++){const N=Array.isArray(d[S])?d[S]:[d[S]];for(let u=0,f=N.length;u<f;u++){const m=N[u];if(Q(m,S,u,w)===!0){const T=m.__offset,M=Array.isArray(m.value)?m.value:[m.value];let _=0;for(let P=0;P<M.length;P++){const b=M[P],z=l(b);typeof b=="number"||typeof b=="boolean"?(m.__data[0]=b,i.bufferSubData(i.UNIFORM_BUFFER,T+_,m.__data)):b.isMatrix3?(m.__data[0]=b.elements[0],m.__data[1]=b.elements[1],m.__data[2]=b.elements[2],m.__data[3]=0,m.__data[4]=b.elements[3],m.__data[5]=b.elements[4],m.__data[6]=b.elements[5],m.__data[7]=0,m.__data[8]=b.elements[6],m.__data[9]=b.elements[7],m.__data[10]=b.elements[8],m.__data[11]=0):(b.toArray(m.__data,_),_+=z.storage/Float32Array.BYTES_PER_ELEMENT)}i.bufferSubData(i.UNIFORM_BUFFER,T,m.__data)}}}i.bindBuffer(i.UNIFORM_BUFFER,null)}function Q(R,p,d,w){const S=R.value,F=p+"_"+d;if(w[F]===void 0)return typeof S=="number"||typeof S=="boolean"?w[F]=S:w[F]=S.clone(),!0;{const N=w[F];if(typeof S=="number"||typeof S=="boolean"){if(N!==S)return w[F]=S,!0}else if(N.equals(S)===!1)return N.copy(S),!0}return!1}function h(R){const p=R.uniforms;let d=0;const w=16;for(let F=0,N=p.length;F<N;F++){const u=Array.isArray(p[F])?p[F]:[p[F]];for(let f=0,m=u.length;f<m;f++){const T=u[f],M=Array.isArray(T.value)?T.value:[T.value];for(let _=0,P=M.length;_<P;_++){const b=M[_],z=l(b),O=d%w,eA=O%z.boundary,oA=O+eA;d+=eA,oA!==0&&w-oA<z.storage&&(d+=w-oA),T.__data=new Float32Array(z.storage/Float32Array.BYTES_PER_ELEMENT),T.__offset=d,d+=z.storage}}}const S=d%w;return S>0&&(d+=w-S),R.__size=d,R.__cache={},this}function l(R){const p={boundary:0,storage:0};return typeof R=="number"||typeof R=="boolean"?(p.boundary=4,p.storage=4):R.isVector2?(p.boundary=8,p.storage=8):R.isVector3||R.isColor?(p.boundary=16,p.storage=12):R.isVector4?(p.boundary=16,p.storage=16):R.isMatrix3?(p.boundary=48,p.storage=48):R.isMatrix4?(p.boundary=64,p.storage=64):R.isTexture?console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."):console.warn("THREE.WebGLRenderer: Unsupported uniform value type.",R),p}function B(R){const p=R.target;p.removeEventListener("dispose",B);const d=o.indexOf(p.__bindingPointIndex);o.splice(d,1),i.deleteBuffer(n[p.id]),delete n[p.id],delete s[p.id]}function c(){for(const R in n)i.deleteBuffer(n[R]);o=[],n={},s={}}return{bind:a,update:g,dispose:c}}class ef{constructor(A={}){const{canvas:e=AB(),context:t=null,depth:n=!0,stencil:s=!1,alpha:o=!1,antialias:r=!1,premultipliedAlpha:a=!0,preserveDrawingBuffer:g=!1,powerPreference:I="default",failIfMajorPerformanceCaveat:E=!1,reverseDepthBuffer:C=!1}=A;this.isWebGLRenderer=!0;let Q;if(t!==null){if(typeof WebGLRenderingContext<"u"&&t instanceof WebGLRenderingContext)throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");Q=t.getContextAttributes().alpha}else Q=o;const h=new Uint32Array(4),l=new Int32Array(4);let B=null,c=null;const R=[],p=[];this.domElement=e,this.debug={checkShaderErrors:!0,onShaderError:null},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this._outputColorSpace=De,this.toneMapping=ai,this.toneMappingExposure=1;const d=this;let w=!1,S=0,F=0,N=null,u=-1,f=null;const m=new YA,T=new YA;let M=null;const _=new GA(0);let P=0,b=e.width,z=e.height,O=1,eA=null,oA=null;const gA=new YA(0,0,b,z),pA=new YA(0,0,b,z);let qA=!1;const X=new to;let AA=!1,hA=!1;const rA=new UA,mA=new UA,LA=new L,EA=new YA,xA={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};let yA=!1;function WA(){return N===null?O:1}let U=t;function ke(y,k){return e.getContext(y,k)}try{const y={alpha:!0,depth:n,stencil:s,antialias:r,premultipliedAlpha:a,preserveDrawingBuffer:g,powerPreference:I,failIfMajorPerformanceCaveat:E};if("setAttribute"in e&&e.setAttribute("data-engine",`three.js r${na}`),e.addEventListener("webglcontextlost",Z,!1),e.addEventListener("webglcontextrestored",IA,!1),e.addEventListener("webglcontextcreationerror",BA,!1),U===null){const k="webgl2";if(U=ke(k,y),U===null)throw ke(k)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}}catch(y){throw console.error("THREE.WebGLRenderer: "+y.message),y}let VA,JA,wA,Ie,MA,x,D,Y,$,tA,j,RA,CA,cA,ZA,nA,dA,NA,K,J,lA,uA,kA,v;function iA(){VA=new Id(U),VA.init(),uA=new qu(U,VA),JA=new nd(U,VA,A,uA),wA=new Ku(U,VA),JA.reverseDepthBuffer&&C&&wA.buffers.depth.setReversed(!0),Ie=new Qd(U),MA=new Fu,x=new Yu(U,VA,wA,MA,JA,uA,Ie),D=new od(d),Y=new gd(d),$=new fc(U),kA=new td(U,$),tA=new Ed(U,$,Ie,kA),j=new cd(U,tA,$,Ie),K=new Bd(U,JA,x),nA=new sd(MA),RA=new xu(d,D,Y,VA,JA,kA,nA),CA=new $u(d,MA),cA=new _u,ZA=new ku(VA),NA=new ed(d,D,Y,wA,j,Q,a),dA=new Ou(d,j,JA),v=new Af(U,Ie,JA,wA),J=new id(U,VA,Ie),lA=new Cd(U,VA,Ie),Ie.programs=RA.programs,d.capabilities=JA,d.extensions=VA,d.properties=MA,d.renderLists=cA,d.shadowMap=dA,d.state=wA,d.info=Ie}iA();const q=new Zu(d,U);this.xr=q,this.getContext=function(){return U},this.getContextAttributes=function(){return U.getContextAttributes()},this.forceContextLoss=function(){const y=VA.get("WEBGL_lose_context");y&&y.loseContext()},this.forceContextRestore=function(){const y=VA.get("WEBGL_lose_context");y&&y.restoreContext()},this.getPixelRatio=function(){return O},this.setPixelRatio=function(y){y!==void 0&&(O=y,this.setSize(b,z,!1))},this.getSize=function(y){return y.set(b,z)},this.setSize=function(y,k,W=!0){if(q.isPresenting){console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");return}b=y,z=k,e.width=Math.floor(y*O),e.height=Math.floor(k*O),W===!0&&(e.style.width=y+"px",e.style.height=k+"px"),this.setViewport(0,0,y,k)},this.getDrawingBufferSize=function(y){return y.set(b*O,z*O).floor()},this.setDrawingBufferSize=function(y,k,W){b=y,z=k,O=W,e.width=Math.floor(y*W),e.height=Math.floor(k*W),this.setViewport(0,0,y,k)},this.getCurrentViewport=function(y){return y.copy(m)},this.getViewport=function(y){return y.copy(gA)},this.setViewport=function(y,k,W,V){y.isVector4?gA.set(y.x,y.y,y.z,y.w):gA.set(y,k,W,V),wA.viewport(m.copy(gA).multiplyScalar(O).round())},this.getScissor=function(y){return y.copy(pA)},this.setScissor=function(y,k,W,V){y.isVector4?pA.set(y.x,y.y,y.z,y.w):pA.set(y,k,W,V),wA.scissor(T.copy(pA).multiplyScalar(O).round())},this.getScissorTest=function(){return qA},this.setScissorTest=function(y){wA.setScissorTest(qA=y)},this.setOpaqueSort=function(y){eA=y},this.setTransparentSort=function(y){oA=y},this.getClearColor=function(y){return y.copy(NA.getClearColor())},this.setClearColor=function(){NA.setClearColor.apply(NA,arguments)},this.getClearAlpha=function(){return NA.getClearAlpha()},this.setClearAlpha=function(){NA.setClearAlpha.apply(NA,arguments)},this.clear=function(y=!0,k=!0,W=!0){let V=0;if(y){let H=!1;if(N!==null){const sA=N.texture.format;H=sA===mt||sA===Ia||sA===ga}if(H){const sA=N.texture.type,QA=sA===qt||sA===Oe||sA===Hn||sA===an||sA===oa||sA===ra,fA=NA.getClearColor(),DA=NA.getClearAlpha(),vA=fA.r,TA=fA.g,FA=fA.b;QA?(h[0]=vA,h[1]=TA,h[2]=FA,h[3]=DA,U.clearBufferuiv(U.COLOR,0,h)):(l[0]=vA,l[1]=TA,l[2]=FA,l[3]=DA,U.clearBufferiv(U.COLOR,0,l))}else V|=U.COLOR_BUFFER_BIT}k&&(V|=U.DEPTH_BUFFER_BIT),W&&(V|=U.STENCIL_BUFFER_BIT,this.state.buffers.stencil.setMask(4294967295)),U.clear(V)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){e.removeEventListener("webglcontextlost",Z,!1),e.removeEventListener("webglcontextrestored",IA,!1),e.removeEventListener("webglcontextcreationerror",BA,!1),NA.dispose(),cA.dispose(),ZA.dispose(),MA.dispose(),D.dispose(),Y.dispose(),j.dispose(),kA.dispose(),v.dispose(),RA.dispose(),q.dispose(),q.removeEventListener("sessionstart",Ua),q.removeEventListener("sessionend",Ga),Ci.stop()};function Z(y){y.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),w=!0}function IA(){console.log("THREE.WebGLRenderer: Context Restored."),w=!1;const y=Ie.autoReset,k=dA.enabled,W=dA.autoUpdate,V=dA.needsUpdate,H=dA.type;iA(),Ie.autoReset=y,dA.enabled=k,dA.autoUpdate=W,dA.needsUpdate=V,dA.type=H}function BA(y){console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",y.statusMessage)}function HA(y){const k=y.target;k.removeEventListener("dispose",HA),he(k)}function he(y){Me(y),MA.remove(y)}function Me(y){const k=MA.get(y).programs;k!==void 0&&(k.forEach(function(W){RA.releaseProgram(W)}),y.isShaderMaterial&&RA.releaseShaderCache(y))}this.renderBufferDirect=function(y,k,W,V,H,sA){k===null&&(k=xA);const QA=H.isMesh&&H.matrixWorld.determinant()<0,fA=JC(y,k,W,V,H);wA.setMaterial(V,QA);let DA=W.index,vA=1;if(V.wireframe===!0){if(DA=tA.getWireframeAttribute(W),DA===void 0)return;vA=2}const TA=W.drawRange,FA=W.attributes.position;let Ae=TA.start*vA,ie=(TA.start+TA.count)*vA;sA!==null&&(Ae=Math.max(Ae,sA.start*vA),ie=Math.min(ie,(sA.start+sA.count)*vA)),DA!==null?(Ae=Math.max(Ae,0),ie=Math.min(ie,DA.count)):FA!=null&&(Ae=Math.max(Ae,0),ie=Math.min(ie,FA.count));const ue=ie-Ae;if(ue<0||ue===1/0)return;kA.setup(H,V,fA,W,DA);let le,ee=J;if(DA!==null&&(le=$.get(DA),ee=lA,ee.setIndex(le)),H.isMesh)V.wireframe===!0?(wA.setLineWidth(V.wireframeLinewidth*WA()),ee.setMode(U.LINES)):ee.setMode(U.TRIANGLES);else if(H.isLine){let _A=V.linewidth;_A===void 0&&(_A=1),wA.setLineWidth(_A*WA()),H.isLineSegments?ee.setMode(U.LINES):H.isLineLoop?ee.setMode(U.LINE_LOOP):ee.setMode(U.LINE_STRIP)}else H.isPoints?ee.setMode(U.POINTS):H.isSprite&&ee.setMode(U.TRIANGLES);if(H.isBatchedMesh)if(H._multiDrawInstances!==null)ee.renderMultiDrawInstances(H._multiDrawStarts,H._multiDrawCounts,H._multiDrawCount,H._multiDrawInstances);else if(VA.get("WEBGL_multi_draw"))ee.renderMultiDraw(H._multiDrawStarts,H._multiDrawCounts,H._multiDrawCount);else{const _A=H._multiDrawStarts,Se=H._multiDrawCounts,ne=H._multiDrawCount,gt=DA?$.get(DA).bytesPerElement:1,xi=MA.get(V).currentProgram.getUniforms();for(let Ke=0;Ke<ne;Ke++)xi.setValue(U,"_gl_DrawID",Ke),ee.render(_A[Ke]/gt,Se[Ke])}else if(H.isInstancedMesh)ee.renderInstances(Ae,ue,H.count);else if(W.isInstancedBufferGeometry){const _A=W._maxInstanceCount!==void 0?W._maxInstanceCount:1/0,Se=Math.min(W.instanceCount,_A);ee.renderInstances(Ae,ue,Se)}else ee.render(Ae,ue)};function oe(y,k,W){y.transparent===!0&&y.side===Bt&&y.forceSinglePass===!1?(y.side=Je,y.needsUpdate=!0,Zn(y,k,W),y.side=ft,y.needsUpdate=!0,Zn(y,k,W),y.side=Bt):Zn(y,k,W)}this.compile=function(y,k,W=null){W===null&&(W=y),c=ZA.get(W),c.init(k),p.push(c),W.traverseVisible(function(H){H.isLight&&H.layers.test(k.layers)&&(c.pushLight(H),H.castShadow&&c.pushShadow(H))}),y!==W&&y.traverseVisible(function(H){H.isLight&&H.layers.test(k.layers)&&(c.pushLight(H),H.castShadow&&c.pushShadow(H))}),c.setupLights();const V=new Set;return y.traverse(function(H){if(!(H.isMesh||H.isPoints||H.isLine||H.isSprite))return;const sA=H.material;if(sA)if(Array.isArray(sA))for(let QA=0;QA<sA.length;QA++){const fA=sA[QA];oe(fA,W,H),V.add(fA)}else oe(sA,W,H),V.add(sA)}),p.pop(),c=null,V},this.compileAsync=function(y,k,W=null){const V=this.compile(y,k,W);return new Promise(H=>{function sA(){if(V.forEach(function(QA){MA.get(QA).currentProgram.isReady()&&V.delete(QA)}),V.size===0){H(y);return}setTimeout(sA,10)}VA.get("KHR_parallel_shader_compile")!==null?sA():setTimeout(sA,10)})};let at=null;function xt(y){at&&at(y)}function Ua(){Ci.stop()}function Ga(){Ci.start()}const Ci=new kE;Ci.setAnimationLoop(xt),typeof self<"u"&&Ci.setContext(self),this.setAnimationLoop=function(y){at=y,q.setAnimationLoop(y),y===null?Ci.stop():Ci.start()},q.addEventListener("sessionstart",Ua),q.addEventListener("sessionend",Ga),this.render=function(y,k){if(k!==void 0&&k.isCamera!==!0){console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");return}if(w===!0)return;if(y.matrixWorldAutoUpdate===!0&&y.updateMatrixWorld(),k.parent===null&&k.matrixWorldAutoUpdate===!0&&k.updateMatrixWorld(),q.enabled===!0&&q.isPresenting===!0&&(q.cameraAutoUpdate===!0&&q.updateCamera(k),k=q.getCamera()),y.isScene===!0&&y.onBeforeRender(d,y,k,N),c=ZA.get(y,p.length),c.init(k),p.push(c),mA.multiplyMatrices(k.projectionMatrix,k.matrixWorldInverse),X.setFromProjectionMatrix(mA),hA=this.localClippingEnabled,AA=nA.init(this.clippingPlanes,hA),B=cA.get(y,R.length),B.init(),R.push(B),q.enabled===!0&&q.isPresenting===!0){const sA=d.xr.getDepthSensingMesh();sA!==null&&ao(sA,k,-1/0,d.sortObjects)}ao(y,k,0,d.sortObjects),B.finish(),d.sortObjects===!0&&B.sort(eA,oA),yA=q.enabled===!1||q.isPresenting===!1||q.hasDepthSensing()===!1,yA&&NA.addToRenderList(B,y),this.info.render.frame++,AA===!0&&nA.beginShadows();const W=c.state.shadowsArray;dA.render(W,y,k),AA===!0&&nA.endShadows(),this.info.autoReset===!0&&this.info.reset();const V=B.opaque,H=B.transmissive;if(c.setupLights(),k.isArrayCamera){const sA=k.cameras;if(H.length>0)for(let QA=0,fA=sA.length;QA<fA;QA++){const DA=sA[QA];Ta(V,H,y,DA)}yA&&NA.render(y);for(let QA=0,fA=sA.length;QA<fA;QA++){const DA=sA[QA];va(B,y,DA,DA.viewport)}}else H.length>0&&Ta(V,H,y,k),yA&&NA.render(y),va(B,y,k);N!==null&&(x.updateMultisampleRenderTarget(N),x.updateRenderTargetMipmap(N)),y.isScene===!0&&y.onAfterRender(d,y,k),kA.resetDefaultState(),u=-1,f=null,p.pop(),p.length>0?(c=p[p.length-1],AA===!0&&nA.setGlobalState(d.clippingPlanes,c.state.camera)):c=null,R.pop(),R.length>0?B=R[R.length-1]:B=null};function ao(y,k,W,V){if(y.visible===!1)return;if(y.layers.test(k.layers)){if(y.isGroup)W=y.renderOrder;else if(y.isLOD)y.autoUpdate===!0&&y.update(k);else if(y.isLight)c.pushLight(y),y.castShadow&&c.pushShadow(y);else if(y.isSprite){if(!y.frustumCulled||X.intersectsSprite(y)){V&&EA.setFromMatrixPosition(y.matrixWorld).applyMatrix4(mA);const QA=j.update(y),fA=y.material;fA.visible&&B.push(y,QA,fA,W,EA.z,null)}}else if((y.isMesh||y.isLine||y.isPoints)&&(!y.frustumCulled||X.intersectsObject(y))){const QA=j.update(y),fA=y.material;if(V&&(y.boundingSphere!==void 0?(y.boundingSphere===null&&y.computeBoundingSphere(),EA.copy(y.boundingSphere.center)):(QA.boundingSphere===null&&QA.computeBoundingSphere(),EA.copy(QA.boundingSphere.center)),EA.applyMatrix4(y.matrixWorld).applyMatrix4(mA)),Array.isArray(fA)){const DA=QA.groups;for(let vA=0,TA=DA.length;vA<TA;vA++){const FA=DA[vA],Ae=fA[FA.materialIndex];Ae&&Ae.visible&&B.push(y,QA,Ae,W,EA.z,FA)}}else fA.visible&&B.push(y,QA,fA,W,EA.z,null)}}const sA=y.children;for(let QA=0,fA=sA.length;QA<fA;QA++)ao(sA[QA],k,W,V)}function va(y,k,W,V){const H=y.opaque,sA=y.transmissive,QA=y.transparent;c.setupLightsView(W),AA===!0&&nA.setGlobalState(d.clippingPlanes,W),V&&wA.viewport(m.copy(V)),H.length>0&&Xn(H,k,W),sA.length>0&&Xn(sA,k,W),QA.length>0&&Xn(QA,k,W),wA.buffers.depth.setTest(!0),wA.buffers.depth.setMask(!0),wA.buffers.color.setMask(!0),wA.setPolygonOffset(!1)}function Ta(y,k,W,V){if((W.isScene===!0?W.overrideMaterial:null)!==null)return;c.state.transmissionRenderTarget[V.id]===void 0&&(c.state.transmissionRenderTarget[V.id]=new wi(1,1,{generateMipmaps:!0,type:VA.has("EXT_color_buffer_half_float")||VA.has("EXT_color_buffer_float")?qn:qt,minFilter:Ot,samples:4,stencilBuffer:s,resolveDepthBuffer:!1,resolveStencilBuffer:!1,colorSpace:$A.workingColorSpace}));const sA=c.state.transmissionRenderTarget[V.id],QA=V.viewport||m;sA.setSize(QA.z,QA.w);const fA=d.getRenderTarget();d.setRenderTarget(sA),d.getClearColor(_),P=d.getClearAlpha(),P<1&&d.setClearColor(16777215,.5),d.clear(),yA&&NA.render(W);const DA=d.toneMapping;d.toneMapping=ai;const vA=V.viewport;if(V.viewport!==void 0&&(V.viewport=void 0),c.setupLightsView(V),AA===!0&&nA.setGlobalState(d.clippingPlanes,V),Xn(y,W,V),x.updateMultisampleRenderTarget(sA),x.updateRenderTargetMipmap(sA),VA.has("WEBGL_multisampled_render_to_texture")===!1){let TA=!1;for(let FA=0,Ae=k.length;FA<Ae;FA++){const ie=k[FA],ue=ie.object,le=ie.geometry,ee=ie.material,_A=ie.group;if(ee.side===Bt&&ue.layers.test(V.layers)){const Se=ee.side;ee.side=Je,ee.needsUpdate=!0,ba(ue,W,V,le,ee,_A),ee.side=Se,ee.needsUpdate=!0,TA=!0}}TA===!0&&(x.updateMultisampleRenderTarget(sA),x.updateRenderTargetMipmap(sA))}d.setRenderTarget(fA),d.setClearColor(_,P),vA!==void 0&&(V.viewport=vA),d.toneMapping=DA}function Xn(y,k,W){const V=k.isScene===!0?k.overrideMaterial:null;for(let H=0,sA=y.length;H<sA;H++){const QA=y[H],fA=QA.object,DA=QA.geometry,vA=V===null?QA.material:V,TA=QA.group;fA.layers.test(W.layers)&&ba(fA,k,W,DA,vA,TA)}}function ba(y,k,W,V,H,sA){y.onBeforeRender(d,k,W,V,H,sA),y.modelViewMatrix.multiplyMatrices(W.matrixWorldInverse,y.matrixWorld),y.normalMatrix.getNormalMatrix(y.modelViewMatrix),H.onBeforeRender(d,k,W,V,y,sA),H.transparent===!0&&H.side===Bt&&H.forceSinglePass===!1?(H.side=Je,H.needsUpdate=!0,d.renderBufferDirect(W,k,V,H,y,sA),H.side=ft,H.needsUpdate=!0,d.renderBufferDirect(W,k,V,H,y,sA),H.side=Bt):d.renderBufferDirect(W,k,V,H,y,sA),y.onAfterRender(d,k,W,V,H,sA)}function Zn(y,k,W){k.isScene!==!0&&(k=xA);const V=MA.get(y),H=c.state.lights,sA=c.state.shadowsArray,QA=H.state.version,fA=RA.getParameters(y,H.state,sA,k,W),DA=RA.getProgramCacheKey(fA);let vA=V.programs;V.environment=y.isMeshStandardMaterial?k.environment:null,V.fog=k.fog,V.envMap=(y.isMeshStandardMaterial?Y:D).get(y.envMap||V.environment),V.envMapRotation=V.environment!==null&&y.envMap===null?k.environmentRotation:y.envMapRotation,vA===void 0&&(y.addEventListener("dispose",HA),vA=new Map,V.programs=vA);let TA=vA.get(DA);if(TA!==void 0){if(V.currentProgram===TA&&V.lightsStateVersion===QA)return Ha(y,fA),TA}else fA.uniforms=RA.getUniforms(y),y.onBeforeCompile(fA,d),TA=RA.acquireProgram(fA,DA),vA.set(DA,TA),V.uniforms=fA.uniforms;const FA=V.uniforms;return(!y.isShaderMaterial&&!y.isRawShaderMaterial||y.clipping===!0)&&(FA.clippingPlanes=nA.uniform),Ha(y,fA),V.needsLights=YC(y),V.lightsStateVersion=QA,V.needsLights&&(FA.ambientLightColor.value=H.state.ambient,FA.lightProbe.value=H.state.probe,FA.directionalLights.value=H.state.directional,FA.directionalLightShadows.value=H.state.directionalShadow,FA.spotLights.value=H.state.spot,FA.spotLightShadows.value=H.state.spotShadow,FA.rectAreaLights.value=H.state.rectArea,FA.ltc_1.value=H.state.rectAreaLTC1,FA.ltc_2.value=H.state.rectAreaLTC2,FA.pointLights.value=H.state.point,FA.pointLightShadows.value=H.state.pointShadow,FA.hemisphereLights.value=H.state.hemi,FA.directionalShadowMap.value=H.state.directionalShadowMap,FA.directionalShadowMatrix.value=H.state.directionalShadowMatrix,FA.spotShadowMap.value=H.state.spotShadowMap,FA.spotLightMatrix.value=H.state.spotLightMatrix,FA.spotLightMap.value=H.state.spotLightMap,FA.pointShadowMap.value=H.state.pointShadowMap,FA.pointShadowMatrix.value=H.state.pointShadowMatrix),V.currentProgram=TA,V.uniformsList=null,TA}function ka(y){if(y.uniformsList===null){const k=y.currentProgram.getUniforms();y.uniformsList=bs.seqWithValue(k.seq,y.uniforms)}return y.uniformsList}function Ha(y,k){const W=MA.get(y);W.outputColorSpace=k.outputColorSpace,W.batching=k.batching,W.batchingColor=k.batchingColor,W.instancing=k.instancing,W.instancingColor=k.instancingColor,W.instancingMorph=k.instancingMorph,W.skinning=k.skinning,W.morphTargets=k.morphTargets,W.morphNormals=k.morphNormals,W.morphColors=k.morphColors,W.morphTargetsCount=k.morphTargetsCount,W.numClippingPlanes=k.numClippingPlanes,W.numIntersection=k.numClipIntersection,W.vertexAlphas=k.vertexAlphas,W.vertexTangents=k.vertexTangents,W.toneMapping=k.toneMapping}function JC(y,k,W,V,H){k.isScene!==!0&&(k=xA),x.resetTextureUnits();const sA=k.fog,QA=V.isMeshStandardMaterial?k.environment:null,fA=N===null?d.outputColorSpace:N.isXRRenderTarget===!0?N.texture.colorSpace:be,DA=(V.isMeshStandardMaterial?Y:D).get(V.envMap||QA),vA=V.vertexColors===!0&&!!W.attributes.color&&W.attributes.color.itemSize===4,TA=!!W.attributes.tangent&&(!!V.normalMap||V.anisotropy>0),FA=!!W.morphAttributes.position,Ae=!!W.morphAttributes.normal,ie=!!W.morphAttributes.color;let ue=ai;V.toneMapped&&(N===null||N.isXRRenderTarget===!0)&&(ue=d.toneMapping);const le=W.morphAttributes.position||W.morphAttributes.normal||W.morphAttributes.color,ee=le!==void 0?le.length:0,_A=MA.get(V),Se=c.state.lights;if(AA===!0&&(hA===!0||y!==f)){const _e=y===f&&V.id===u;nA.setState(V,y,_e)}let ne=!1;V.version===_A.__version?(_A.needsLights&&_A.lightsStateVersion!==Se.state.version||_A.outputColorSpace!==fA||H.isBatchedMesh&&_A.batching===!1||!H.isBatchedMesh&&_A.batching===!0||H.isBatchedMesh&&_A.batchingColor===!0&&H.colorTexture===null||H.isBatchedMesh&&_A.batchingColor===!1&&H.colorTexture!==null||H.isInstancedMesh&&_A.instancing===!1||!H.isInstancedMesh&&_A.instancing===!0||H.isSkinnedMesh&&_A.skinning===!1||!H.isSkinnedMesh&&_A.skinning===!0||H.isInstancedMesh&&_A.instancingColor===!0&&H.instanceColor===null||H.isInstancedMesh&&_A.instancingColor===!1&&H.instanceColor!==null||H.isInstancedMesh&&_A.instancingMorph===!0&&H.morphTexture===null||H.isInstancedMesh&&_A.instancingMorph===!1&&H.morphTexture!==null||_A.envMap!==DA||V.fog===!0&&_A.fog!==sA||_A.numClippingPlanes!==void 0&&(_A.numClippingPlanes!==nA.numPlanes||_A.numIntersection!==nA.numIntersection)||_A.vertexAlphas!==vA||_A.vertexTangents!==TA||_A.morphTargets!==FA||_A.morphNormals!==Ae||_A.morphColors!==ie||_A.toneMapping!==ue||_A.morphTargetsCount!==ee)&&(ne=!0):(ne=!0,_A.__version=V.version);let gt=_A.currentProgram;ne===!0&&(gt=Zn(V,k,H));let xi=!1,Ke=!1,un=!1;const Ce=gt.getUniforms(),Ze=_A.uniforms;if(wA.useProgram(gt.program)&&(xi=!0,Ke=!0,un=!0),V.id!==u&&(u=V.id,Ke=!0),xi||f!==y){wA.buffers.depth.getReversed()?(rA.copy(y.projectionMatrix),tB(rA),iB(rA),Ce.setValue(U,"projectionMatrix",rA)):Ce.setValue(U,"projectionMatrix",y.projectionMatrix),Ce.setValue(U,"viewMatrix",y.matrixWorldInverse);const He=Ce.map.cameraPosition;He!==void 0&&He.setValue(U,LA.setFromMatrixPosition(y.matrixWorld)),JA.logarithmicDepthBuffer&&Ce.setValue(U,"logDepthBufFC",2/(Math.log(y.far+1)/Math.LN2)),(V.isMeshPhongMaterial||V.isMeshToonMaterial||V.isMeshLambertMaterial||V.isMeshBasicMaterial||V.isMeshStandardMaterial||V.isShaderMaterial)&&Ce.setValue(U,"isOrthographic",y.isOrthographicCamera===!0),f!==y&&(f=y,Ke=!0,un=!0)}if(H.isSkinnedMesh){Ce.setOptional(U,H,"bindMatrix"),Ce.setOptional(U,H,"bindMatrixInverse");const _e=H.skeleton;_e&&(_e.boneTexture===null&&_e.computeBoneTexture(),Ce.setValue(U,"boneTexture",_e.boneTexture,x))}H.isBatchedMesh&&(Ce.setOptional(U,H,"batchingTexture"),Ce.setValue(U,"batchingTexture",H._matricesTexture,x),Ce.setOptional(U,H,"batchingIdTexture"),Ce.setValue(U,"batchingIdTexture",H._indirectTexture,x),Ce.setOptional(U,H,"batchingColorTexture"),H._colorsTexture!==null&&Ce.setValue(U,"batchingColorTexture",H._colorsTexture,x));const je=W.morphAttributes;if((je.position!==void 0||je.normal!==void 0||je.color!==void 0)&&K.update(H,W,gt),(Ke||_A.receiveShadow!==H.receiveShadow)&&(_A.receiveShadow=H.receiveShadow,Ce.setValue(U,"receiveShadow",H.receiveShadow)),V.isMeshGouraudMaterial&&V.envMap!==null&&(Ze.envMap.value=DA,Ze.flipEnvMap.value=DA.isCubeTexture&&DA.isRenderTargetTexture===!1?-1:1),V.isMeshStandardMaterial&&V.envMap===null&&k.environment!==null&&(Ze.envMapIntensity.value=k.environmentIntensity),Ke&&(Ce.setValue(U,"toneMappingExposure",d.toneMappingExposure),_A.needsLights&&KC(Ze,un),sA&&V.fog===!0&&CA.refreshFogUniforms(Ze,sA),CA.refreshMaterialUniforms(Ze,V,O,z,c.state.transmissionRenderTarget[y.id]),bs.upload(U,ka(_A),Ze,x)),V.isShaderMaterial&&V.uniformsNeedUpdate===!0&&(bs.upload(U,ka(_A),Ze,x),V.uniformsNeedUpdate=!1),V.isSpriteMaterial&&Ce.setValue(U,"center",H.center),Ce.setValue(U,"modelViewMatrix",H.modelViewMatrix),Ce.setValue(U,"normalMatrix",H.normalMatrix),Ce.setValue(U,"modelMatrix",H.matrixWorld),V.isShaderMaterial||V.isRawShaderMaterial){const _e=V.uniformsGroups;for(let He=0,go=_e.length;He<go;He++){const Qi=_e[He];v.update(Qi,gt),v.bind(Qi,gt)}}return gt}function KC(y,k){y.ambientLightColor.needsUpdate=k,y.lightProbe.needsUpdate=k,y.directionalLights.needsUpdate=k,y.directionalLightShadows.needsUpdate=k,y.pointLights.needsUpdate=k,y.pointLightShadows.needsUpdate=k,y.spotLights.needsUpdate=k,y.spotLightShadows.needsUpdate=k,y.rectAreaLights.needsUpdate=k,y.hemisphereLights.needsUpdate=k}function YC(y){return y.isMeshLambertMaterial||y.isMeshToonMaterial||y.isMeshPhongMaterial||y.isMeshStandardMaterial||y.isShadowMaterial||y.isShaderMaterial&&y.lights===!0}this.getActiveCubeFace=function(){return S},this.getActiveMipmapLevel=function(){return F},this.getRenderTarget=function(){return N},this.setRenderTargetTextures=function(y,k,W){MA.get(y.texture).__webglTexture=k,MA.get(y.depthTexture).__webglTexture=W;const V=MA.get(y);V.__hasExternalTextures=!0,V.__autoAllocateDepthBuffer=W===void 0,V.__autoAllocateDepthBuffer||VA.has("WEBGL_multisampled_render_to_texture")===!0&&(console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),V.__useRenderToTexture=!1)},this.setRenderTargetFramebuffer=function(y,k){const W=MA.get(y);W.__webglFramebuffer=k,W.__useDefaultFramebuffer=k===void 0},this.setRenderTarget=function(y,k=0,W=0){N=y,S=k,F=W;let V=!0,H=null,sA=!1,QA=!1;if(y){const DA=MA.get(y);if(DA.__useDefaultFramebuffer!==void 0)wA.bindFramebuffer(U.FRAMEBUFFER,null),V=!1;else if(DA.__webglFramebuffer===void 0)x.setupRenderTarget(y);else if(DA.__hasExternalTextures)x.rebindTextures(y,MA.get(y.texture).__webglTexture,MA.get(y.depthTexture).__webglTexture);else if(y.depthBuffer){const FA=y.depthTexture;if(DA.__boundDepthTexture!==FA){if(FA!==null&&MA.has(FA)&&(y.width!==FA.image.width||y.height!==FA.image.height))throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");x.setupDepthRenderbuffer(y)}}const vA=y.texture;(vA.isData3DTexture||vA.isDataArrayTexture||vA.isCompressedArrayTexture)&&(QA=!0);const TA=MA.get(y).__webglFramebuffer;y.isWebGLCubeRenderTarget?(Array.isArray(TA[k])?H=TA[k][W]:H=TA[k],sA=!0):y.samples>0&&x.useMultisampledRTT(y)===!1?H=MA.get(y).__webglMultisampledFramebuffer:Array.isArray(TA)?H=TA[W]:H=TA,m.copy(y.viewport),T.copy(y.scissor),M=y.scissorTest}else m.copy(gA).multiplyScalar(O).floor(),T.copy(pA).multiplyScalar(O).floor(),M=qA;if(wA.bindFramebuffer(U.FRAMEBUFFER,H)&&V&&wA.drawBuffers(y,H),wA.viewport(m),wA.scissor(T),wA.setScissorTest(M),sA){const DA=MA.get(y.texture);U.framebufferTexture2D(U.FRAMEBUFFER,U.COLOR_ATTACHMENT0,U.TEXTURE_CUBE_MAP_POSITIVE_X+k,DA.__webglTexture,W)}else if(QA){const DA=MA.get(y.texture),vA=k||0;U.framebufferTextureLayer(U.FRAMEBUFFER,U.COLOR_ATTACHMENT0,DA.__webglTexture,W||0,vA)}u=-1},this.readRenderTargetPixels=function(y,k,W,V,H,sA,QA){if(!(y&&y.isWebGLRenderTarget)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");return}let fA=MA.get(y).__webglFramebuffer;if(y.isWebGLCubeRenderTarget&&QA!==void 0&&(fA=fA[QA]),fA){wA.bindFramebuffer(U.FRAMEBUFFER,fA);try{const DA=y.texture,vA=DA.format,TA=DA.type;if(!JA.textureFormatReadable(vA)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");return}if(!JA.textureTypeReadable(TA)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");return}k>=0&&k<=y.width-V&&W>=0&&W<=y.height-H&&U.readPixels(k,W,V,H,uA.convert(vA),uA.convert(TA),sA)}finally{const DA=N!==null?MA.get(N).__webglFramebuffer:null;wA.bindFramebuffer(U.FRAMEBUFFER,DA)}}},this.readRenderTargetPixelsAsync=async function(y,k,W,V,H,sA,QA){if(!(y&&y.isWebGLRenderTarget))throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");let fA=MA.get(y).__webglFramebuffer;if(y.isWebGLCubeRenderTarget&&QA!==void 0&&(fA=fA[QA]),fA){const DA=y.texture,vA=DA.format,TA=DA.type;if(!JA.textureFormatReadable(vA))throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");if(!JA.textureTypeReadable(TA))throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");if(k>=0&&k<=y.width-V&&W>=0&&W<=y.height-H){wA.bindFramebuffer(U.FRAMEBUFFER,fA);const FA=U.createBuffer();U.bindBuffer(U.PIXEL_PACK_BUFFER,FA),U.bufferData(U.PIXEL_PACK_BUFFER,sA.byteLength,U.STREAM_READ),U.readPixels(k,W,V,H,uA.convert(vA),uA.convert(TA),0);const Ae=N!==null?MA.get(N).__webglFramebuffer:null;wA.bindFramebuffer(U.FRAMEBUFFER,Ae);const ie=U.fenceSync(U.SYNC_GPU_COMMANDS_COMPLETE,0);return U.flush(),await eB(U,ie,4),U.bindBuffer(U.PIXEL_PACK_BUFFER,FA),U.getBufferSubData(U.PIXEL_PACK_BUFFER,0,sA),U.deleteBuffer(FA),U.deleteSync(ie),sA}else throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.")}},this.copyFramebufferToTexture=function(y,k=null,W=0){y.isTexture!==!0&&(Xi("WebGLRenderer: copyFramebufferToTexture function signature has changed."),k=arguments[0]||null,y=arguments[1]);const V=Math.pow(2,-W),H=Math.floor(y.image.width*V),sA=Math.floor(y.image.height*V),QA=k!==null?k.x:0,fA=k!==null?k.y:0;x.setTexture2D(y,0),U.copyTexSubImage2D(U.TEXTURE_2D,W,0,0,QA,fA,H,sA),wA.unbindTexture()};const qC=U.createFramebuffer(),WC=U.createFramebuffer();this.copyTextureToTexture=function(y,k,W=null,V=null,H=0,sA=null){y.isTexture!==!0&&(Xi("WebGLRenderer: copyTextureToTexture function signature has changed."),V=arguments[0]||null,y=arguments[1],k=arguments[2],sA=arguments[3]||0,W=null),sA===null&&(H!==0?(Xi("WebGLRenderer: copyTextureToTexture function signature has changed to support src and dst mipmap levels."),sA=H,H=0):sA=0);let QA,fA,DA,vA,TA,FA,Ae,ie,ue;const le=y.isCompressedTexture?y.mipmaps[sA]:y.image;if(W!==null)QA=W.max.x-W.min.x,fA=W.max.y-W.min.y,DA=W.isBox3?W.max.z-W.min.z:1,vA=W.min.x,TA=W.min.y,FA=W.isBox3?W.min.z:0;else{const je=Math.pow(2,-H);QA=Math.floor(le.width*je),fA=Math.floor(le.height*je),y.isDataArrayTexture?DA=le.depth:y.isData3DTexture?DA=Math.floor(le.depth*je):DA=1,vA=0,TA=0,FA=0}V!==null?(Ae=V.x,ie=V.y,ue=V.z):(Ae=0,ie=0,ue=0);const ee=uA.convert(k.format),_A=uA.convert(k.type);let Se;k.isData3DTexture?(x.setTexture3D(k,0),Se=U.TEXTURE_3D):k.isDataArrayTexture||k.isCompressedArrayTexture?(x.setTexture2DArray(k,0),Se=U.TEXTURE_2D_ARRAY):(x.setTexture2D(k,0),Se=U.TEXTURE_2D),U.pixelStorei(U.UNPACK_FLIP_Y_WEBGL,k.flipY),U.pixelStorei(U.UNPACK_PREMULTIPLY_ALPHA_WEBGL,k.premultiplyAlpha),U.pixelStorei(U.UNPACK_ALIGNMENT,k.unpackAlignment);const ne=U.getParameter(U.UNPACK_ROW_LENGTH),gt=U.getParameter(U.UNPACK_IMAGE_HEIGHT),xi=U.getParameter(U.UNPACK_SKIP_PIXELS),Ke=U.getParameter(U.UNPACK_SKIP_ROWS),un=U.getParameter(U.UNPACK_SKIP_IMAGES);U.pixelStorei(U.UNPACK_ROW_LENGTH,le.width),U.pixelStorei(U.UNPACK_IMAGE_HEIGHT,le.height),U.pixelStorei(U.UNPACK_SKIP_PIXELS,vA),U.pixelStorei(U.UNPACK_SKIP_ROWS,TA),U.pixelStorei(U.UNPACK_SKIP_IMAGES,FA);const Ce=y.isDataArrayTexture||y.isData3DTexture,Ze=k.isDataArrayTexture||k.isData3DTexture;if(y.isDepthTexture){const je=MA.get(y),_e=MA.get(k),He=MA.get(je.__renderTarget),go=MA.get(_e.__renderTarget);wA.bindFramebuffer(U.READ_FRAMEBUFFER,He.__webglFramebuffer),wA.bindFramebuffer(U.DRAW_FRAMEBUFFER,go.__webglFramebuffer);for(let Qi=0;Qi<DA;Qi++)Ce&&(U.framebufferTextureLayer(U.READ_FRAMEBUFFER,U.COLOR_ATTACHMENT0,MA.get(y).__webglTexture,H,FA+Qi),U.framebufferTextureLayer(U.DRAW_FRAMEBUFFER,U.COLOR_ATTACHMENT0,MA.get(k).__webglTexture,sA,ue+Qi)),U.blitFramebuffer(vA,TA,QA,fA,Ae,ie,QA,fA,U.DEPTH_BUFFER_BIT,U.NEAREST);wA.bindFramebuffer(U.READ_FRAMEBUFFER,null),wA.bindFramebuffer(U.DRAW_FRAMEBUFFER,null)}else if(H!==0||y.isRenderTargetTexture||MA.has(y)){const je=MA.get(y),_e=MA.get(k);wA.bindFramebuffer(U.READ_FRAMEBUFFER,qC),wA.bindFramebuffer(U.DRAW_FRAMEBUFFER,WC);for(let He=0;He<DA;He++)Ce?U.framebufferTextureLayer(U.READ_FRAMEBUFFER,U.COLOR_ATTACHMENT0,je.__webglTexture,H,FA+He):U.framebufferTexture2D(U.READ_FRAMEBUFFER,U.COLOR_ATTACHMENT0,U.TEXTURE_2D,je.__webglTexture,H),Ze?U.framebufferTextureLayer(U.DRAW_FRAMEBUFFER,U.COLOR_ATTACHMENT0,_e.__webglTexture,sA,ue+He):U.framebufferTexture2D(U.DRAW_FRAMEBUFFER,U.COLOR_ATTACHMENT0,U.TEXTURE_2D,_e.__webglTexture,sA),H!==0?U.blitFramebuffer(vA,TA,QA,fA,Ae,ie,QA,fA,U.COLOR_BUFFER_BIT,U.NEAREST):Ze?U.copyTexSubImage3D(Se,sA,Ae,ie,ue+He,vA,TA,QA,fA):U.copyTexSubImage2D(Se,sA,Ae,ie,vA,TA,QA,fA);wA.bindFramebuffer(U.READ_FRAMEBUFFER,null),wA.bindFramebuffer(U.DRAW_FRAMEBUFFER,null)}else Ze?y.isDataTexture||y.isData3DTexture?U.texSubImage3D(Se,sA,Ae,ie,ue,QA,fA,DA,ee,_A,le.data):k.isCompressedArrayTexture?U.compressedTexSubImage3D(Se,sA,Ae,ie,ue,QA,fA,DA,ee,le.data):U.texSubImage3D(Se,sA,Ae,ie,ue,QA,fA,DA,ee,_A,le):y.isDataTexture?U.texSubImage2D(U.TEXTURE_2D,sA,Ae,ie,QA,fA,ee,_A,le.data):y.isCompressedTexture?U.compressedTexSubImage2D(U.TEXTURE_2D,sA,Ae,ie,le.width,le.height,ee,le.data):U.texSubImage2D(U.TEXTURE_2D,sA,Ae,ie,QA,fA,ee,_A,le);U.pixelStorei(U.UNPACK_ROW_LENGTH,ne),U.pixelStorei(U.UNPACK_IMAGE_HEIGHT,gt),U.pixelStorei(U.UNPACK_SKIP_PIXELS,xi),U.pixelStorei(U.UNPACK_SKIP_ROWS,Ke),U.pixelStorei(U.UNPACK_SKIP_IMAGES,un),sA===0&&k.generateMipmaps&&U.generateMipmap(Se),wA.unbindTexture()},this.copyTextureToTexture3D=function(y,k,W=null,V=null,H=0){return y.isTexture!==!0&&(Xi("WebGLRenderer: copyTextureToTexture3D function signature has changed."),W=arguments[0]||null,V=arguments[1]||null,y=arguments[2],k=arguments[3],H=arguments[4]||0),Xi('WebGLRenderer: copyTextureToTexture3D function has been deprecated. Use "copyTextureToTexture" instead.'),this.copyTextureToTexture(y,k,W,V,H)},this.initRenderTarget=function(y){MA.get(y).__webglFramebuffer===void 0&&x.setupRenderTarget(y)},this.initTexture=function(y){y.isCubeTexture?x.setTextureCube(y,0):y.isData3DTexture?x.setTexture3D(y,0):y.isDataArrayTexture||y.isCompressedArrayTexture?x.setTexture2DArray(y,0):x.setTexture2D(y,0),wA.unbindTexture()},this.resetState=function(){S=0,F=0,N=null,wA.reset(),kA.reset()},typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}get coordinateSystem(){return Jt}get outputColorSpace(){return this._outputColorSpace}set outputColorSpace(A){this._outputColorSpace=A;const e=this.getContext();e.drawingBufferColorspace=$A._getDrawingBufferColorSpace(A),e.unpackColorSpace=$A._getUnpackColorSpace()}}const tf="0.8.6",gI={name:"GuoJF"};new Yr;new L;new UA;new rt(new L(-.5,-.5,0),new L(.5,.5,9));new to;class Ra extends io{constructor(A={}){super({transparent:!0,side:ft,...A})}setTexture(A){this.map=A,this.needsUpdate=!0}dispose(){const A=this.map;A&&(A.image instanceof ImageBitmap&&A.image.close(),A.dispose())}}function ws(...i){const A=i,e=A&&A.length>1&&A[0].constructor||null;if(!e)throw new Error('"concatenateTypedArrays" - incorrect quantity of arguments or arguments have incompatible data types');const t=A.reduce((o,r)=>o+r.length,0),n=new e(t);let s=0;for(const o of A)n.set(o,s),s+=o.length;return n}function so(i,A,e,t){const n=t?sf(t,i.position.value):nf(A),s=n.length,o=new Float32Array(s*6),r=new Float32Array(s*4),a=new A.constructor(s*6),g=new Float32Array(s*6);for(let E=0;E<s;E++)of({edge:n[E],edgeIndex:E,attributes:i,skirtHeight:e,newPosition:o,newTexcoord0:r,newTriangles:a,newNormals:g});i.position.value=ws(i.position.value,o),i.texcoord.value=ws(i.texcoord.value,r),i.normal.value=ws(i.normal.value,g);const I=ws(A,a);return{attributes:i,indices:I}}function nf(i){const A=[],e=Array.isArray(i)?i:Array.from(i);for(let n=0;n<e.length;n+=3){const s=e[n],o=e[n+1],r=e[n+2];A.push([s,o],[o,r],[r,s])}A.sort(([n,s],[o,r])=>{const a=Math.min(n,s),g=Math.min(o,r);return a!==g?a-g:Math.max(n,s)-Math.max(o,r)});const t=[];for(let n=0;n<A.length;n++)n+1<A.length&&A[n][0]===A[n+1][1]&&A[n][1]===A[n+1][0]?n++:t.push(A[n]);return t}function sf(i,A){const e=(n,s)=>{n.sort(s)};e(i.westIndices,(n,s)=>A[3*n+1]-A[3*s+1]),e(i.eastIndices,(n,s)=>A[3*s+1]-A[3*n+1]),e(i.southIndices,(n,s)=>A[3*s]-A[3*n]),e(i.northIndices,(n,s)=>A[3*n]-A[3*s]);const t=[];return Object.values(i).forEach(n=>{if(n.length>1)for(let s=0;s<n.length-1;s++)t.push([n[s],n[s+1]])}),t}function of({edge:i,edgeIndex:A,attributes:e,skirtHeight:t,newPosition:n,newTexcoord0:s,newTriangles:o,newNormals:r}){const a=e.position.value.length,g=A*2,I=g+1;n.set(e.position.value.subarray(i[0]*3,i[0]*3+3),g*3),n[g*3+2]=n[g*3+2]-t,n.set(e.position.value.subarray(i[1]*3,i[1]*3+3),I*3),n[I*3+2]=n[I*3+2]-t,s.set(e.texcoord.value.subarray(i[0]*2,i[0]*2+2),g*2),s.set(e.texcoord.value.subarray(i[1]*2,i[1]*2+2),I*2);const E=A*2*3;o[E]=i[0],o[E+1]=a/3+I,o[E+2]=i[1],o[E+3]=a/3+I,o[E+4]=i[0],o[E+5]=a/3+g,r[E]=0,r[E+1]=0,r[E+2]=1,r[E+3]=0,r[E+4]=0,r[E+5]=1}function rf(i,A=!0){if(i.length<4)throw new Error(`DEM array must > 4, got ${i.length}!`);const e=Math.floor(Math.sqrt(i.length)),t=e,n=e,s=KE(n,t),o=af(i,n,t);return A?so(o,s,1):{attributes:o,indices:s}}function af(i,A,e){const t=e*A,n=new Float32Array(t*3),s=new Float32Array(t*2);let o=0;for(let r=0;r<A;r++)for(let a=0;a<e;a++){const g=a/(e-1),I=r/(A-1);s[o*2]=g,s[o*2+1]=I,n[o*3]=g-.5,n[o*3+1]=I-.5,n[o*3+2]=i[(A-r-1)*e+a],o++}return{position:{value:n,size:3},texcoord:{value:s,size:2},normal:{value:YE(n,KE(A,e)),size:3}}}function KE(i,A){const e=6*(A-1)*(i-1),t=new Uint16Array(e);let n=0;for(let s=0;s<i-1;s++)for(let o=0;o<A-1;o++){const r=s*A+o,a=r+1,g=r+A,I=g+1,E=n*6;t[E]=r,t[E+1]=a,t[E+2]=g,t[E+3]=g,t[E+4]=a,t[E+5]=I,n++}return t}function YE(i,A){const e=new Float32Array(i.length);for(let t=0;t<A.length;t+=3){const n=A[t]*3,s=A[t+1]*3,o=A[t+2]*3,r=i[n],a=i[n+1],g=i[n+2],I=i[s],E=i[s+1],C=i[s+2],Q=i[o],h=i[o+1],l=i[o+2],B=I-r,c=E-a,R=C-g,p=Q-r,d=h-a,w=l-g,S=c*w-R*d,F=R*p-B*w,N=B*d-c*p,u=Math.sqrt(S*S+F*F+N*N),f=[0,0,1];if(u>0){const m=1/u;f[0]=S*m,f[1]=F*m,f[2]=N*m}for(let m=0;m<3;m++)e[n+m]=e[s+m]=e[o+m]=f[m]}return e}class qE extends Xe{type="TileGeometry";setData(A){this.setIndex(new Qe(A.indices,1));const{attributes:e}=A;return this.setAttribute("position",new Qe(e.position.value,e.position.size)),this.setAttribute("uv",new Qe(e.texcoord.value,e.texcoord.size)),this.setAttribute("normal",new Qe(e.normal.value,e.normal.size)),this.computeBoundingBox(),this.computeBoundingSphere(),this}setDEM(A){const e=rf(A,!0);return this.setData(e)}}class II{static enabled=!0;static size=200;static files=new Map;static add(A,e){if(!this.enabled||this.files.has(A))return;this.files.set(A,e);const t=Array.from(this.files.keys()),n=this.files.size-this.size;for(let s=0;s<n;s++)this.remove(t[s]);console.assert(this.files.size<=this.size)}static get(A){if(this.enabled)return this.files.get(A)}static remove(A){this.files.delete(A)}static clear(){this.files.clear()}}class gf extends Error{response;constructor(A,e){super(A),this.response=e}}class wa extends Ei{mimeType;responseType;constructor(A){super(A)}load(A,e,t,n,s){this.path!==void 0&&(A=this.path+A),A=this.manager.resolveURL(A);const o=II.get(A);if(o)return this.manager.itemStart(A),setTimeout(()=>{e&&e(o),this.manager.itemEnd(A)}),o;if(s?.aborted){console.log("aborted befor load");return}const r=new Request(A,{headers:new Headers(this.requestHeader),credentials:this.withCredentials?"include":"same-origin",signal:s}),a=this.mimeType,g=this.responseType;fetch(r).then(I=>{if(I.status===200||I.status===0)return I.status===0&&console.warn("THREE.FileLoader: HTTP Status 0 received."),I;throw new gf(`fetch for "${I.url}" responded with ${I.status}: ${I.statusText}`,I)}).then(I=>{switch(g){case"arraybuffer":return I.arrayBuffer();case"blob":return I.blob();case"document":return I.text().then(E=>new DOMParser().parseFromString(E,a));case"json":return I.json();default:if(a===void 0)return I.text();{const E=/charset="?([^;"\s]*)"?/i.exec(a),C=E&&E[1]?E[1].toLowerCase():void 0,Q=new TextDecoder(C);return I.arrayBuffer().then(h=>Q.decode(h))}}}).then(I=>{II.add(A,I),e&&e(I)}).catch(I=>{n&&n(I),I.name!="AbortError"&&this.manager.itemError(A)}).finally(()=>{this.manager.itemEnd(A)}),this.manager.itemStart(A)}setResponseType(A){return this.responseType=A,this}setMimeType(A){return this.mimeType=A,this}}console.log(`====================three-tile V${tf}==============================`);class If extends vE{onParseStart=void 0;onParseEnd=void 0;parseStart(A){this.onParseStart&&this.onParseStart(A)}parseEnd(A){setTimeout(()=>this.onParseEnd&&this.onParseEnd(A))}}const Ee={manager:new If,demLoaderMap:new Map,imgLoaderMap:new Map,registerMaterialLoader(i){i.author=i.author??gI.name,Ee.imgLoaderMap.set(i.dataType,i),console.log(`* Register imageLoader: '${i.dataType}', Author: '${i.author}'`)},registerGeometryLoader(i){i.author=i.author??gI.name,Ee.demLoaderMap.set(i.dataType,i),console.log(`* Register terrainLoader: '${i.dataType}', Author: '${i.author}'`)},getMaterialLoader(i){const A=Ee.imgLoaderMap.get(i.dataType);if(A)return A;throw`Source dataType "${i.dataType}" is not support!`},getGeometryLoader(i){const A=Ee.demLoaderMap.get(i.dataType);if(A)return A;throw`Source dataType "${i.dataType}" is not support!`},getLoadersInfo(){const i=Array.from(this.imgLoaderMap.values()).map(e=>({category:"image",dataType:e.dataType,author:e.author,discription:e.discription??"-"})),A=Array.from(this.demLoaderMap.values()).map(e=>({category:"terrain",dataType:e.dataType,author:e.author,discription:e.discription??"-"}));return[...i,...A]}},Ef="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7";class Sa extends Ei{loader=new wa(Ee.manager);constructor(A){super(A),this.loader.setResponseType("blob")}load(A,e,t,n,s){const o=new Image,r=I=>{g(),e&&e(o)},a=I=>{g(),n&&n(I),o.src=Ef},g=()=>{o.removeEventListener("load",r,!1),o.removeEventListener("error",a,!1)};return o.addEventListener("load",r,!1),o.addEventListener("error",a,!1),this.crossOrigin,this.requestHeader,this.loader.load(A,I=>{e&&(o.src=URL.createObjectURL(I))},t,n,s),o}}function WE(i,A){const e=Math.floor(i[0]*A),t=Math.floor(i[1]*A),n=Math.floor((i[2]-i[0])*A),s=Math.floor((i[3]-i[1])*A);return{sx:e,sy:t,sw:n,sh:s}}function Ma(i,A,e,t){if(t<i.minLevel)return{url:void 0};if(t<=i.maxLevel)return{url:i._getTileUrl(A,e,t),bounds:[0,0,1,1]};const n=Cf(A,e,t,i.maxLevel);return{url:i._getTileUrl(n.parentNO.x,n.parentNO.y,n.parentNO.z),bounds:n.bounds}}function Cf(i,A,e,t){const n=e-t,s={x:i>>n,y:A>>n,z:e-n},o=Math.pow(2,n),r=Math.pow(.5,n),a=i%o/o-.5+r/2,g=A%o/o-.5+r/2,I=new bA(a,g),E=new hc().setFromCenterAndSize(I,new bA(r,r)),C=[E.min.x+.5,E.min.y+.5,E.max.x+.5,E.max.y+.5];return{parentNO:s,bounds:C}}class VE{dataType="";useWorker=!0;load(A,e,t,n,s,o){const r=new qE,{url:a,bounds:g}=Ma(A,e,t,n);return a?this.doLoad(a,I=>{I&&(Ee.manager.parseStart(a),this.doPrase(I,e,t,n,g,E=>{E instanceof Float32Array?r.setDEM(E):r.setData(E),Ee.manager.parseEnd(a),s()}))},s,o):s(),r}}class Qf{dataType="";useWorker=!0;load(A,e,t,n,s,o){const r=new Ra,{url:a,bounds:g}=Ma(A,e,t,n);return a?this.doLoad(a,I=>{I&&(Ee.manager.parseStart(a),this.doPrase(I,e,t,n,g,E=>{r.setTexture(E),Ee.manager.parseEnd(a),s()}))},s,o):s(),r}}class Bf extends Qf{dataType="image";discription="Tile image loader. It can load xyz tile image.";loader=new Sa(Ee.manager);doLoad(A,e,t,n){this.loader.load(A,e,void 0,t,n)}doPrase(A,e,t,n,s,o){const r=new de;r.colorSpace=De,s[2]-s[0]<1?r.image=cf(A,s):r.image=A,r.needsUpdate=!0,o(r)}}function cf(i,A){const e=i.width,t=new OffscreenCanvas(e,e),n=t.getContext("2d"),{sx:s,sy:o,sw:r,sh:a}=WE(A,i.width);return n.drawImage(i,s,o,r,a,0,0,e,e),t}Ee.registerMaterialLoader(new Bf);function hf(i){return lf(i.data)}function lf(i){function A(n,s){const o=s*4,[r,a,g,I]=n.slice(o,o+4);return I===0?0:(r<<16|a<<8|g)/1e4-10}const e=i.length>>>2,t=new Float32Array(e);for(let n=0;n<e;n++)t[n]=A(i,n);return t}const zE="KGZ1bmN0aW9uKCl7InVzZSBzdHJpY3QiO2Z1bmN0aW9uIGModCl7cmV0dXJuIGEodC5kYXRhKX1mdW5jdGlvbiBhKHQpe2Z1bmN0aW9uIG4oZSx1KXtjb25zdCByPXUqNCxbZixpLGcsbF09ZS5zbGljZShyLHIrNCk7cmV0dXJuIGw9PT0wPzA6KGY8PDE2fGk8PDh8ZykvMWU0LTEwfWNvbnN0IHM9dC5sZW5ndGg+Pj4yLG89bmV3IEZsb2F0MzJBcnJheShzKTtmb3IobGV0IGU9MDtlPHM7ZSsrKW9bZV09bih0LGUpO3JldHVybiBvfXNlbGYub25tZXNzYWdlPXQ9Pntjb25zdCBuPWModC5kYXRhLmltZ0RhdGEpO3NlbGYucG9zdE1lc3NhZ2Uobiksc2VsZi5jbG9zZSgpfX0pKCk7Cg==",df=i=>Uint8Array.from(atob(i),A=>A.charCodeAt(0)),EI=typeof self<"u"&&self.Blob&&new Blob([df(zE)],{type:"text/javascript;charset=utf-8"});function uf(i){let A;try{if(A=EI&&(self.URL||self.webkitURL).createObjectURL(EI),!A)throw"";const e=new Worker(A,{name:i?.name});return e.addEventListener("error",()=>{(self.URL||self.webkitURL).revokeObjectURL(A)}),e}catch{return new Worker("data:text/javascript;base64,"+zE,{name:i?.name})}finally{A&&(self.URL||self.webkitURL).revokeObjectURL(A)}}class ff extends VE{dataType="terrain-rgb";discription="Mapbox-RGB terrain loader, It can load Mapbox-RGB terrain data.";imageLoader=new Sa(Ee.manager);doLoad(A,e,t,n){this.imageLoader.load(A,s=>e(s),void 0,t,n)}doPrase(A,e,t,n,s,o){const r=Qa.clamp((n+2)*3,2,64),a=pf(A,s,r);if(this.useWorker){const g=new uf;g.onmessage=I=>{o(I.data)},g.postMessage({imgData:a},a)}else o(hf(a))}}function pf(i,A,e){const t=WE(A,i.width);e=Math.min(e,t.sw);const n=new OffscreenCanvas(e,e).getContext("2d");return n.imageSmoothingEnabled=!1,n.drawImage(i,t.sx,t.sy,t.sw,t.sh,0,0,e,e),n.getImageData(0,0,e,e)}Ee.registerGeometryLoader(new ff);class Df{dataType="debug";useWorker=!1;discription="Tile debug image loader. It will draw a rectangle and coordinate on the tile.";load(A,e,t,n,s){const o=new LE(this.drawTile(e,t,n));o.needsUpdate=!0;const r=new Ra({transparent:!0,map:o,opacity:A.opacity});return s(),r}drawTile(A,e,t){const n=new OffscreenCanvas(256,256),s=n.getContext("2d");return s.scale(1,-1),s.translate(0,-256),s&&(s.strokeStyle="#ccc",s.lineWidth=4,s.strokeRect(5,5,246,246),s.fillStyle="white",s.shadowColor="black",s.shadowBlur=5,s.shadowOffsetX=1,s.shadowOffsetY=1,s.font="bold 20px arial",s.textAlign="center",s.fillText(`Tile Test - level: ${t}`,256/2,50),s.fillText(`[${A}, ${e}]`,256/2,80)),n.transferToImageBitmap()}}Ee.registerMaterialLoader(new Df);class mf{dataType="logo";discription="Logo Material loader. It will draw logo on the tile.";_texture=null;load(A,e,t,n,s){if(n<4)return s(),new tt;this._texture||(this._texture=new LE(this.drawLogo(A.attribution)),this._texture.needsUpdate=!0);const o=new tt({transparent:!0,map:this._texture,opacity:A.opacity});return s(),o}drawLogo(A){const e=new OffscreenCanvas(256,256),t=e.getContext("2d");return t&&(t.scale(1,-1),t.translate(0,-256),t.fillStyle="white",t.shadowColor="black",t.shadowBlur=5,t.shadowOffsetX=1,t.shadowOffsetY=1,t.font="bold 14px arial",t.textAlign="center",t.translate(256/2,256/2),t.rotate(30*Math.PI/180),t.fillText(`${A}`,0,0)),e.transferToImageBitmap()}}Ee.registerMaterialLoader(new mf);class yf{dataType="normal";discription="Tile normal material loader.";load(A,e,t,n,s){const o=new vB({opacity:A.opacity,flatShading:!0});return s(),o}}Ee.registerMaterialLoader(new yf);class Rf{dataType="wireframe";discription="Tile wireframe material loader.";load(A,e,t,n,s){const o=new GA(`hsl(${n*14}, 100%, 50%)`),r=new tt({transparent:!0,wireframe:!0,color:o,opacity:A.opacity,depthTest:!1});return s(),r}}Ee.registerMaterialLoader(new Rf);/*! Lerc 4.0
Copyright 2015 - 2023 Esri
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
A local copy of the license and additional notices are located with the
source distribution at:
http://github.com/Esri/lerc/
Contributors:  Thomas Maurer, Wenxue Ju
*/var wf=(()=>{var i=import.meta.url;return function(e){e=e||{};var e=typeof e<"u"?e:{},t,n;e.ready=new Promise(function(K,J){t=K,n=J});var s=Object.assign({},e),o=typeof window=="object",r=typeof importScripts=="function",a=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",g="";function I(K){return e.locateFile?e.locateFile(K,g):g+K}var E,C,Q,h,l,B;a?(r?g=require("path").dirname(g)+"/":g=__dirname+"/",B=()=>{l||(h=require("fs"),l=require("path"))},E=function(K,J){return B(),K=l.normalize(K),h.readFileSync(K,J?void 0:"utf8")},Q=K=>{var J=E(K,!0);return J.buffer||(J=new Uint8Array(J)),J},C=(K,J,lA)=>{B(),K=l.normalize(K),h.readFile(K,function(uA,kA){uA?lA(uA):J(kA.buffer)})},process.argv.length>1&&process.argv[1].replace(/\\/g,"/"),process.argv.slice(2),process.on("uncaughtException",function(K){if(!(K instanceof dA))throw K}),process.on("unhandledRejection",function(K){throw K}),e.inspect=function(){return"[Emscripten Module object]"}):(o||r)&&(r?g=self.location.href:typeof document<"u"&&document.currentScript&&(g=document.currentScript.src),i&&(g=i),g.indexOf("blob:")!==0?g=g.substr(0,g.replace(/[?#].*/,"").lastIndexOf("/")+1):g="",E=K=>{var J=new XMLHttpRequest;return J.open("GET",K,!1),J.send(null),J.responseText},r&&(Q=K=>{var J=new XMLHttpRequest;return J.open("GET",K,!1),J.responseType="arraybuffer",J.send(null),new Uint8Array(J.response)}),C=(K,J,lA)=>{var uA=new XMLHttpRequest;uA.open("GET",K,!0),uA.responseType="arraybuffer",uA.onload=()=>{if(uA.status==200||uA.status==0&&uA.response){J(uA.response);return}lA()},uA.onerror=lA,uA.send(null)}),e.print||console.log.bind(console);var c=e.printErr||console.warn.bind(console);Object.assign(e,s),s=null,e.arguments,e.thisProgram,e.quit;var R;e.wasmBinary&&(R=e.wasmBinary),e.noExitRuntime,typeof WebAssembly!="object"&&mA("no native wasm support detected");var p,d=!1,w=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0;function S(K,J,lA){for(var uA=J+lA,kA=J;K[kA]&&!(kA>=uA);)++kA;if(kA-J>16&&K.buffer&&w)return w.decode(K.subarray(J,kA));for(var v="";J<kA;){var iA=K[J++];if(!(iA&128)){v+=String.fromCharCode(iA);continue}var q=K[J++]&63;if((iA&224)==192){v+=String.fromCharCode((iA&31)<<6|q);continue}var Z=K[J++]&63;if((iA&240)==224?iA=(iA&15)<<12|q<<6|Z:iA=(iA&7)<<18|q<<12|Z<<6|K[J++]&63,iA<65536)v+=String.fromCharCode(iA);else{var IA=iA-65536;v+=String.fromCharCode(55296|IA>>10,56320|IA&1023)}}return v}function F(K,J){return K?S(f,K,J):""}var N,u,f,m,T;function M(K){N=K,e.HEAP8=u=new Int8Array(K),e.HEAP16=new Int16Array(K),e.HEAP32=m=new Int32Array(K),e.HEAPU8=f=new Uint8Array(K),e.HEAPU16=new Uint16Array(K),e.HEAPU32=T=new Uint32Array(K),e.HEAPF32=new Float32Array(K),e.HEAPF64=new Float64Array(K)}e.INITIAL_MEMORY;var _,P=[],b=[],z=[];function O(){if(e.preRun)for(typeof e.preRun=="function"&&(e.preRun=[e.preRun]);e.preRun.length;)gA(e.preRun.shift());VA(P)}function eA(){VA(b)}function oA(){if(e.postRun)for(typeof e.postRun=="function"&&(e.postRun=[e.postRun]);e.postRun.length;)qA(e.postRun.shift());VA(z)}function gA(K){P.unshift(K)}function pA(K){b.unshift(K)}function qA(K){z.unshift(K)}var X=0,AA=null;function hA(K){X++,e.monitorRunDependencies&&e.monitorRunDependencies(X)}function rA(K){if(X--,e.monitorRunDependencies&&e.monitorRunDependencies(X),X==0&&AA){var J=AA;AA=null,J()}}function mA(K){e.onAbort&&e.onAbort(K),K="Aborted("+K+")",c(K),d=!0,K+=". Build with -sASSERTIONS for more info.";var J=new WebAssembly.RuntimeError(K);throw n(J),J}var LA="data:application/octet-stream;base64,";function EA(K){return K.startsWith(LA)}function xA(K){return K.startsWith("file://")}var yA;e.locateFile?(yA="lerc-wasm.wasm",EA(yA)||(yA=I(yA))):yA=new URL("data:application/wasm;base64,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Tg0AA0AgCiACQQN0ai8BAEUNASACQQFqIgIgA0cNAAsgAyECDAELIAIhBSACIANODQEDQCAKIAVBA3RqLwEADQIgBUEBaiIFIANHDQALCyADIAJrIgUgCSAFIAlKIgUbIQkgAiAIIAUbIQgMAgsgBSACayILIAkgCSALSCILGyEJIAIgCCALGyEIIAMgBSICSg0ACwsgAyAJayAAIARrSARAIAYgCCAJajYCFCAGIAMgCGoiADYCECAGKAIUIQQLQQAhAiAAIARMDQAgACAEayIFQQFxIQkCQCAEQQFqIABGBEBBACEADAELIAVBfnEhBUEAIQADQCAAIAogBEEAIAMgAyAEShtrQQN0ai8BACIIIAAgCEobIgAgCiAEQQFqIghBACADIAMgCEoba0EDdGovAQAiCCAAIAhKGyEAIARBAmohBCACQQJqIgIgBUcNAAsLIAkEQCAAIAogBEEAIAMgAyAEShtrQQN0ai8BACICIAAgAkobIQALIABBIWsiAkFgTwRAIAYgADYCDAsgAkFfSyECCwJAIAIiCkUNACAHKAIIIQwgBygCBCENIAEgBigCDCILIAcoAhwiDiALIA5IGyIANgIAIAcgBygCEDYCFCAGQX82AhhBACEFQQAhCAJAQQEgAHQiAyAHKAIYIgAgBygCECICa0ECdU0EQAJAIAcoAhQiBSACa0ECdSIJIAMgAyAJSxsiBEUNACAEQQFrIQ8CQCAEQQNxIhBFBEAgAiEADAELIAIhAANAIAAgBi8BGDsBACAAIAYvARo7AQIgBEEBayEEIABBBGohACAIQQFqIgggEEcNAAsLIA9BA0kNAANAIAAgBi8BGDsBACAAIAYvARo7AQIgACAGLwEYOwEEIAAgBi8BGjsBBiAAIAYvARg7AQggACAGLwEaOwEKIAAgBi8BGDsBDCAAIAYvARo7AQ4gAEEQaiEAIARBBGsiBA0ACwsgAyAJSwRAIAUgAyAJa0ECdGohAANAIAUgBigBGDYBACAFQQRqIgUgAEcNAAsgByAANgIUDAILIAcgAiADQQJ0ajYCFAwBCyACBEAgByACNgIUIAIQBiAHQQA2AhggB0IANwIQQQAhAAsCQCADQYCAgIAETw0AIABBAXUiAiADIAIgA0sbQf////8DIABB/P///wdJGyIAQYCAgIAETw0AIAcgAEECdCIAEAki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QYCAgHxxakGAgIB8cXIiCDYCACADIAQgB2oiB0ECdGoiASAJIAEoAgAiAWpB////A3EgCCABQYCAgHxxakGAgIB8cXIiATYCACAEIAdqIQcgD0ECaiIPIBZHDQALCyAQRQ0AIAMgB0ECdGoiByABIAcoAgAiB2pB////A3EgASAHQYCAgHxxakGAgIB8cXI2AgALIANBBGohAyARQQFqIhEgBEcNAAsLIAVFDQIgBEEBayIBQX5xIRIgAUEBcSEJQQAhESAEQQJJIQgDQAJAIAgNACAAKAIAIQNBACEPQQEhASAEQQJHBEADQCAAIAFBAnRqIgogCigCACIHQYCAgHxxIANqQYCAgHxxIAMgB2oiB0H///8DcXIiAzYCACAKIAMgCigCBCIDQYCAgHxxakGAgIB8cSADIAdqQf///wNxciIDNgIEIAFBAmohASAPQQJqIg8gEkcNAAsLIAlFDQAgACABQQJ0aiIBIAEoAgAiAUGAgIB8cSADakGAgIB8cSABIANqQf///wNxcjYCAAsgACAEQQJ0aiEAIBFBAWoiESAFRw0ACwwCC0GTDEH/CEGaB0GUCBAAAAsgBARAIAVBAmshECAFQQFrIgFBfnEhCiABQQFxIRIgBUECSSEJIAAhAwNAAkAgCQ0AIARBAUcEQEEAIQcgBCEBIBAEQANAIAMgAUEDdGoiCCADIAEgBGtBA3RqKQMAIiMgCCkDACIkfCIlQv////////8HgyAjICRCgICAgICAgHiDfEKAgICAgICAeIOEIiM3AwAgAyABIARqIghBA3RqIgEgJSABKQMAIiR8Qv////////8HgyAjICRCgICAgICAgHiDfEKAgICAgICAeIOENwMAIAQgCGohASAHQQJqIgcgCkcNAAsLIBJFDQEgAyABQQN0aiIHIAMgASAEa0EDdGopAwAiIyAHKQMAIiR8Qv////////8HgyAjICRCgICAgICAgHiDfEKAgICAgICAeIOENwMADAELIAMpAwAhI0EAIQcgBCEBIBAEQANAIAMgAUEDdGoiCCAjIAgpAwAiJHwiJUL/////////B4MgIyAkQoCAgICAgIB4g3xCgICAgICAgHiDhCIjNwMAIAMgASAEaiIIQQN0aiIBICUgASkDACIkfEL/////////B4MgIyAkQoCAgICAgIB4g3xCgICAgICAgHiDhCIjNwMAIAQgCGohASAHQQJqIgcgCkcNAAsLIBJFDQAgAyABQQN0aiIBICMgASkDACIkfEL/////////B4MgIyAkQoCAgICAgIB4g3xCgICAgICAgHiDhDcDAAsgA0EIaiEDIA9BAWoiDyAERw0ACwsgBUUNACAEQQFrIgFBfnEhEiABQQFxIQlBACEPIARBAkkhCANAAkAgCA0AIAApAwAhI0EAIQdBASEDIARBAkcEQANAIAAgA0EDdGoiASABKQMAIiRCgICAgICAgHiDICN8QoCAgICAgIB4gyAjICR8IiVC/////////weDhCIjNwMAIAEgIyABKQMIIiRCgICAgICAgHiDfEKAgICAgICAeIMgJCAlfEL/////////B4OEIiM3AwggA0ECaiEDIAdBAmoiByASRw0ACwsgCUUNACAAIANBA3RqIgEgASkDACIkQoCAgICAgIB4gyAjfEKAgICAgICAeIMgIyAkfEL/////////B4OENwMACyAAIARBA3RqIQAgD0EBaiIPIAVHDQALCyAfQQVGBEAgBiAaEFALIBgEQCAYIAY2AgAMAQsgBhAGCyAGQQBHDAILQY4LQbwIQfIEQZQIEAAACwwECyEeDAELAn8gDEEMaiEVQQAhDiAAQQJJBEAgDCgCFCIKIAwoAhAiEmsiA0EDdSIPIB8QLEYEQEEBIABBAkZBAXQgAEEBRhshHgJAIA8gBCAFbCIYbBASIgFFDQAgGARAIA9BASAPQQFLGyIAQX5xIQkgAEEBcSEIIAwoAhAhFkEAIREgA0EQSSEHA0ACQCAKIBJGDQBBACEAQQAhECAHRQRAA0AgASAWIABBA3QiBmoiAygCACAOamogAygCBCARai0AADoAACABIBYgBkEIcmoiAygCACAOamogAygCBCARai0AADoAACAAQQJqIQAgEEECaiIQIAlHDQALCyAIRQ0AIAEgFiAAQQN0aiIAKAIAIA5qaiAAKAIEIBFqLQAAOgAACyAOIA9qIQ4gEUEBaiIRIBhHDQALCyABIQBBACERAkAgHkUNAAJAAkACQCAfQQVrDgIAAgELAkAgHkECRw0AIAVFDQAgBEEBcSEWIARBAmtBfnEhECAEQQNJIQogACEDA0ACQCAKDQAgAygCBCEOQQAhD0ECIQYgBEEDRwRAA0AgAyAGQQJ0IhJqIgcgBygCACIHQYCAgHxxIA5qQYCAgHxxIAcgDmoiCUH///8DcXIiCDYCACADIBJBBHJqIgcgBygCACIHQYCAgHxxIAhqQYCAgHxxIAcgCWpB////A3FyIg42AgAgBkECaiEGIA9BAmoiDyAQRw0ACwsgFkUNACADIAZBAnRqIgYgBigCACIGQYCAgHxxIA5qQYCAgHxxIAYgDmpB////A3FyNgIACyADIARBAnRqIQMgEUEBaiIRIAVHDQALCyAeQQBMDQIgBUUNAiAEQQFrIgNBfnEhCiADQQFxIRJBACERIARBAkkhCQNAAkAgCQ0AIAAoAgAhDkEAIQ9BASEGIARBAkcEQANAIAAgBkECdGoiECAQKAIAIgNBgICAfHEgDmpBgICAfHEgAyAOaiIIQf///wNxciIHNgIAIBAgByAQKAIEIgNBgICAfHFqQYCAgHxxIAMgCGpB////A3FyIg42AgQgBkECaiEGIA9BAmoiDyAKRw0ACwsgEkUNACAAIAZBAnRqIgMgAygCACIDQYCAgHxxIA5qQYCAgHxxIAMgDmpB////A3FyNgIACyAAIARBAnRqIQAgEUEBaiIRIAVHDQALDAILQZMMQf8IQYEGQasLEAAACwJAIB5BAkcNACAFRQ0AIARBAXEhCiAEQQJrQX5xIRIgBEEDSSEJIAAhBgNAAkAgCQ0AIAYpAwghI0EAIQNBAiEOIARBA0cEQANAIAYgDkEDdCIIaiIHIAcpAwAiJEKAgICAgICAeIMgI3xCgICAgICAgHiDICMgJHwiJUL/////////B4OEIiM3AwAgBiAIQQhyaiIHICMgBykDACIkQoCAgICAgIB4g3xCgICAgICAgHiDICQgJXxC/////////weDhCIjNwMAIA5BAmohDiADQQJqIgMgEkcNAAsLIApFDQAgBiAOQQN0aiIDIAMpAwAiJEKAgICAgICAeIMgI3xCgICAgICAgHiDICMgJHxC/////////weDhDcDAAsgBiAEQQN0aiEGIBFBAWoiESAFRw0ACwsgHkEATA0AIAVFDQAgBEEBayIDQX5xIQkgA0EBcSEIQQAhBiAEQQJJIQcDQAJAIAcNACAAKQMAISNBACEDQQEhDiAEQQJHBEADQCAAIA5BA3RqIhIgEikDACIkQoCAgICAgIB4gyAjfEKAgICAgICAeIMgIyAkfCIlQv////////8Hg4QiIzcDACASICMgEikDCCIkQoCAgICAgIB4g3xCgICAgICAgHiDICQgJXxC/////////weDhCIjNwMIIA5BAmohDiADQQJqIgMgCUcNAAsLIAhFDQAgACAOQQN0aiIDIAMpAwAiJEKAgICAgICAeIMgI3xCgICAgICAgHiDICMgJHxC/////////weDhDcDAAsgACAEQQN0aiEAIAZBAWoiBiAFRw0ACwsgH0EFRgRAIAEgGBBQCyAVBEAgFSABNgIADAELIAEQBgsgAUEARwwCCwsMAwshHgsgDCgCECIAIAtHBEBBACEDIAAhCwNAIAsgA0EDdGooAgQQBiADQQFqIgMgDCgCFCAMKAIQIgtrQQN1SQ0ACwsgDCALNgIUIAwoAgwiAARAIAIgACAaICBsEAgaIAAQBgsgHgshASAMKAIQIgAEQCAAEAYLIAxBIGokACABDwtBBBACIgBB0As2AgAgAEG8EkEAEAEAC9cBAQV/AkAgAUUNACABQQFHBEAgAUF+cSEFA0AgACADQQJ0IgZqIgIgAigCACICQQF2QYCAgPwHcSACQf///wNxciACQQh0QYCAgIB4cXI2AgAgACAGQQRyaiICIAIoAgAiAkEBdkGAgID8B3EgAkH///8DcXIgAkEIdEGAgICAeHFyNgIAIANBAmohAyAEQQJqIgQgBUcNAAsLIAFBAXFFDQAgACADQQJ0aiIAIAAoAgAiAEEBdkGAgID8B3EgAEH///8DcXIgAEEIdEGAgICAeHFyNgIACwsLACAAEFIaIAAQBgsxAQJ/IABB7BU2AgAgACgCBEEMayIBIAEoAghBAWsiAjYCCCACQQBIBEAgARAGCyAAC90BAQR/IABBADYCCCAAQgA3AgACQCABBEAgAUGAgICABE8NASAAIAFBAnQiBBAJIgM2AgAgACADIARqIgQ2AgggAUEBa0H/////A3EhBSACKAIAIQIgAUEHcSIGBEBBACEBA0AgAyACNgIAIANBBGohAyABQQFqIgEgBkcNAAsLIAVBB08EQANAIAMgAjYCHCADIAI2AhggAyACNgIUIAMgAjYCECADIAI2AgwgAyACNgIIIAMgAjYCBCADIAI2AgAgA0EgaiIDIARHDQALCyAAIAQ2AgQLIAAPCxAKAAuaAQAgAEEBOgA1AkAgACgCBCACRw0AIABB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QmxvY2tTZXF1ZW5jZQByZXN0b3JlU2VxdWVuY2UAQXNzZXJ0aW9uIGZhaWxlZABzdGQ6OmJhZF9hbGxvYwBwcEJ5dGVbMF0gPT0gSFVGRk1BTl9OT1JNQUwAc2l6ZSA+IDAAUHVyZSB2aXJ0dWFsIGZ1bmN0aW9uIGNhbGxlZCEAQ250WkltYWdlIABMZXJjMiAAAAAAAAAAAHAGAAABAAAAAgAAAE42TGVyY05TMTBCaXRTdHVmZmVyRQAAALQJAABYBgAAAAAAAOgGAAAFAAAABgAAAAcAAAAIAAAACQAAAE42TGVyY05TOUNudFpJbWFnZUUATjZMZXJjTlM2VEltYWdlSU5TXzRDbnRaRUVFAE42TGVyY05TNUltYWdlRQC0CQAAxAYAANwJAACoBgAA1AYAANwJAACUBgAA3AYAAAAAAADcBgAACgAAAAsAAAAMAAAACAAAAAkAAAAAAAAAMAcAAA0AAAAOAAAATjZMZXJjTlM1TGVyYzJFALQJAAAgBwAAAAAAAGAHAAAPAAAAEAAAAE42TGVyY05TMTFCaXRTdHVmZmVyMkUAALQJAABIBwAAAAAAAIwHAAARAAAAEgAAAE42TGVyY05TN0JpdE1hc2tFAAAAtAkAAHgHAABOMTBfX2N4eGFiaXYxMTZfX3NoaW1fdHlwZV9pbmZvRQAAAADcCQAAlAcAAFgLAABOMTBfX2N4eGFiaXYxMTdfX2NsYXNzX3R5cGVfaW5mb0UAAADcCQAAxAcAALgHAABOMTBfX2N4eGFiaXYxMTdfX3BiYXNlX3R5cGVfaW5mb0UAAADcCQAA9AcAALgHAABOMTBfX2N4eGFiaXYxMTlfX3BvaW50ZXJfdHlwZV9pbmZvRQDcCQAAJAgAABgIAABOMTBfX2N4eGFiaXYxMjBfX2Z1bmN0aW9uX3R5cGVfaW5mb0UAAAAA3AkAAFQIAAC4BwAATjEwX19jeHhhYml2MTI5X19wb2ludGVyX3RvX21lbWJlcl90eXBlX2luZm9FAAAA3AkAAIgIAAAYCAAAAAAAAAgJAAATAAAAFAAAABUAAAAWAAAAFwAAAE4xMF9fY3h4YWJpdjEyM19fZnVuZGFtZW50YWxfdHlwZV9pbmZvRQDcCQAA4AgAALgHAAB2AAAAzAgAABQJAABEbgAAzAgAACAJAABjAAAAzAgAACwJAABQS2MAOAoAADgJAAABAAAAMAkAAGgAAADMCAAATAkAAGEAAADMCAAAWAkAAHMAAADMCAAAZAkAAHQAAADMCAAAcAkAAGkAAADMCAAAfAkAAGoAAADMCAAAiAkAAGYAAADMCAAAlAkAAGQAAADMCAAAoAkAAAAAAADoBwAAEwAAABgAAAAVAAAAFgAAABkAAAAaAAAAGwAAABwAAAAAAAAAJAoAABMAAAAdAAAAFQAAABYAAAAZAAAAHgAAAB8AAAAgAAAATjEwX19jeHhhYml2MTIwX19zaV9jbGFzc190eXBlX2luZm9FAAAAANwJAAD8CQAA6AcAAAAAAABICAAAEwAAACEAAAAVAAAAFgAAACIAAAAAAAAAsAoAAAQAAAAjAAAAJAAAAAAAAADYCgAABAAAACUAAAAmAAAAAAAAAJgKAAAEAAAAJwAAACgAAABTdDlleGNlcHRpb24AAAAAtAkAAIgKAABTdDliYWRfYWxsb2MAAAAA3AkAAKAKAACYCgAAU3QyMGJhZF9hcnJheV9uZXdfbGVuZ3RoAAAAANwJAAC8CgAAsAoAAAAAAAAICwAAAwAAACkAAAAqAAAAU3QxMWxvZ2ljX2Vycm9yANwJAAD4CgAAmAoAAAAAAAA8CwAAAwAAACsAAAAqAAAAU3QxMmxlbmd0aF9lcnJvcgAAAADcCQAAKAsAAAgLAABTdDl0eXBlX2luZm8AAAAAtAkAAEgLAEHgFgsDYA1Q",import.meta.url).toString();function WA(K){try{if(K==yA&&R)return new Uint8Array(R);if(Q)return Q(K);throw"both async and sync fetching of the wasm failed"}catch(J){mA(J)}}function U(){if(!R&&(o||r)){if(typeof fetch=="function"&&!xA(yA))return fetch(yA,{credentials:"same-origin"}).then(function(K){if(!K.ok)throw"failed to load wasm binary file at '"+yA+"'";return K.arrayBuffer()}).catch(function(){return WA(yA)});if(C)return new Promise(function(K,J){C(yA,function(lA){K(new Uint8Array(lA))},J)})}return Promise.resolve().then(function(){return WA(yA)})}function ke(){var K={a:CA};function J(iA,q){var Z=iA.exports;e.asm=Z,p=e.asm.g,M(p.buffer),_=e.asm.m,pA(e.asm.h),rA()}hA();function lA(iA){J(iA.instance)}function uA(iA){return U().then(function(q){return WebAssembly.instantiate(q,K)}).then(function(q){return q}).then(iA,function(q){c("failed to asynchronously prepare wasm: "+q),mA(q)})}function kA(){return!R&&typeof WebAssembly.instantiateStreaming=="function"&&!EA(yA)&&!xA(yA)&&!a&&typeof fetch=="function"?fetch(yA,{credentials:"same-origin"}).then(function(iA){var q=WebAssembly.instantiateStreaming(iA,K);return q.then(lA,function(Z){return c("wasm streaming compile failed: "+Z),c("falling back to ArrayBuffer instantiation"),uA(lA)})}):uA(lA)}if(e.instantiateWasm)try{var v=e.instantiateWasm(K,J);return v}catch(iA){return c("Module.instantiateWasm callback failed with error: "+iA),!1}return kA().catch(n),{}}function VA(K){for(;K.length>0;){var J=K.shift();if(typeof J=="function"){J(e);continue}var lA=J.func;typeof lA=="number"?J.arg===void 0?wA(lA)():wA(lA)(J.arg):lA(J.arg===void 0?null:J.arg)}}var JA=[];function wA(K){var J=JA[K];return J||(K>=JA.length&&(JA.length=K+1),JA[K]=J=_.get(K)),J}function Ie(K,J,lA,uA){mA("Assertion failed: "+F(K)+", at: "+[J?F(J):"unknown filename",lA,uA?F(uA):"unknown function"])}function MA(K){return cA(K+24)+24}function x(K){this.excPtr=K,this.ptr=K-24,this.set_type=function(J){T[this.ptr+4>>2]=J},this.get_type=function(){return T[this.ptr+4>>2]},this.set_destructor=function(J){T[this.ptr+8>>2]=J},this.get_destructor=function(){return T[this.ptr+8>>2]},this.set_refcount=function(J){m[this.ptr>>2]=J},this.set_caught=function(J){J=J?1:0,u[this.ptr+12>>0]=J},this.get_caught=function(){return u[this.ptr+12>>0]!=0},this.set_rethrown=function(J){J=J?1:0,u[this.ptr+13>>0]=J},this.get_rethrown=function(){return u[this.ptr+13>>0]!=0},this.init=function(J,lA){this.set_adjusted_ptr(0),this.set_type(J),this.set_destructor(lA),this.set_refcount(0),this.set_caught(!1),this.set_rethrown(!1)},this.add_ref=function(){var J=m[this.ptr>>2];m[this.ptr>>2]=J+1},this.release_ref=function(){var J=m[this.ptr>>2];return m[this.ptr>>2]=J-1,J===1},this.set_adjusted_ptr=function(J){T[this.ptr+16>>2]=J},this.get_adjusted_ptr=function(){return T[this.ptr+16>>2]},this.get_exception_ptr=function(){var J=ZA(this.get_type());if(J)return T[this.excPtr>>2];var lA=this.get_adjusted_ptr();return lA!==0?lA:this.excPtr}}function D(K,J,lA){var uA=new x(K);throw uA.init(J,lA),K}function Y(){mA("")}function $(K,J,lA){f.copyWithin(K,J,J+lA)}function tA(){return 2147483648}function j(K){try{return p.grow(K-N.byteLength+65535>>>16),M(p.buffer),1}catch{}}function RA(K){var J=f.length;K=K>>>0;var lA=tA();if(K>lA)return!1;let uA=(Z,IA)=>Z+(IA-Z%IA)%IA;for(var kA=1;kA<=4;kA*=2){var v=J*(1+.2/kA);v=Math.min(v,K+100663296);var iA=Math.min(lA,uA(Math.max(K,v),65536)),q=j(iA);if(q)return!0}return!1}var CA={a:Ie,c:MA,b:D,d:Y,f:$,e:RA};ke(),e.___wasm_call_ctors=function(){return(e.___wasm_call_ctors=e.asm.h).apply(null,arguments)},e._lerc_getBlobInfo=function(){return(e._lerc_getBlobInfo=e.asm.i).apply(null,arguments)},e._lerc_getDataRanges=function(){return(e._lerc_getDataRanges=e.asm.j).apply(null,arguments)},e._lerc_decode=function(){return(e._lerc_decode=e.asm.k).apply(null,arguments)},e._lerc_decode_4D=function(){return(e._lerc_decode_4D=e.asm.l).apply(null,arguments)};var cA=e._malloc=function(){return(cA=e._malloc=e.asm.n).apply(null,arguments)};e._free=function(){return(e._free=e.asm.o).apply(null,arguments)};var ZA=e.___cxa_is_pointer_type=function(){return(ZA=e.___cxa_is_pointer_type=e.asm.p).apply(null,arguments)},nA;function dA(K){this.name="ExitStatus",this.message="Program terminated with exit("+K+")",this.status=K}AA=function K(){nA||NA(),nA||(AA=K)};function NA(K){if(X>0||(O(),X>0))return;function J(){nA||(nA=!0,e.calledRun=!0,!d&&(eA(),t(e),e.onRuntimeInitialized&&e.onRuntimeInitialized(),oA()))}e.setStatus?(e.setStatus("Running..."),setTimeout(function(){setTimeout(function(){e.setStatus("")},1),J()},1)):J()}if(e.run=NA,e.preInit)for(typeof e.preInit=="function"&&(e.preInit=[e.preInit]);e.preInit.length>0;)e.preInit.pop()();return NA(),e.ready}})();const XE=[{pixelType:"S8",size:1,ctor:Int8Array,range:[-128,128]},{pixelType:"U8",size:1,ctor:Uint8Array,range:[0,255]},{pixelType:"S16",size:2,ctor:Int16Array,range:[-32768,32767]},{pixelType:"U16",size:2,ctor:Uint16Array,range:[0,65536]},{pixelType:"S32",size:4,ctor:Int32Array,range:[-2147483648,2147483647]},{pixelType:"U32",size:4,ctor:Uint32Array,range:[0,4294967296]},{pixelType:"F32",size:4,ctor:Float32Array,range:[-34027999387901484e22,34027999387901484e22]},{pixelType:"F64",size:8,ctor:Float64Array,range:[-17976931348623157e292,17976931348623157e292]}];let Ss=null,ZE=!1;function Sf(i={}){if(Ss)return Ss;const A=i.locateFile||((e,t)=>`${t}${e}`);return Ss=wf({locateFile:A}).then(e=>e.ready.then(()=>{xf(e),ZE=!0})),Ss}function Mf(){return ZE}const zs={getBlobInfo:null,decode:null};function Nf(i){return(i>>3<<3)+16}function Ai(i,A,e){e.set(i.slice(A,A+e.length))}function xf(i){const{_malloc:A,_free:e,_lerc_getBlobInfo:t,_lerc_getDataRanges:n,_lerc_decode_4D:s,asm:o}=i;let r;const a=Object.values(o).find(I=>I&&"buffer"in I&&I.buffer===i.HEAPU8.buffer),g=I=>{const E=I.map(l=>Nf(l)),C=E.reduce((l,B)=>l+B),Q=A(C);r=new Uint8Array(a.buffer);let h=E[0];E[0]=Q;for(let l=1;l<E.length;l++){const B=E[l];E[l]=E[l-1]+h,h=B}return E};zs.getBlobInfo=I=>{const E=new Uint8Array(48),C=new Uint8Array(24),[Q,h,l]=g([I.length,E.length,C.length]);r.set(I,Q),r.set(E,h),r.set(C,l);let B=t(Q,I.length,h,l,12,3);if(B)throw e(Q),`lerc-getBlobInfo: error code is ${B}`;r=new Uint8Array(a.buffer),Ai(r,h,E),Ai(r,l,C);const c=new Uint32Array(E.buffer),R=new Float64Array(C.buffer),[p,d,w,S,F,N,u,f,m,T,M]=c,_={version:p,dimCount:w,width:S,height:F,validPixelCount:u,bandCount:N,blobSize:f,maskCount:m,depthCount:T,dataType:d,minValue:R[0],maxValue:R[1],maxZerror:R[2],statistics:[],bandCountWithNoData:M};if(M)return e(Q),_;if(T===1&&N===1)return e(Q),_.statistics.push({minValue:R[0],maxValue:R[1]}),_;const P=T*N*8,b=new Uint8Array(P),z=new Uint8Array(P);let O=Q,eA=0,oA=0,gA=!1;if(r.byteLength<Q+P*2?(e(Q),gA=!0,[O,eA,oA]=g([I.length,P,P]),r.set(I,O)):[eA,oA]=g([P,P]),r.set(b,eA),r.set(z,oA),B=n(O,I.length,T,N,eA,oA),B)throw e(O),gA||e(eA),`lerc-getDataRanges: error code is ${B}`;r=new Uint8Array(a.buffer),Ai(r,eA,b),Ai(r,oA,z);const pA=new Float64Array(b.buffer),qA=new Float64Array(z.buffer),X=_.statistics;for(let AA=0;AA<N;AA++)if(T>1){const hA=pA.slice(AA*T,(AA+1)*T),rA=qA.slice(AA*T,(AA+1)*T),mA=Math.min.apply(null,hA),LA=Math.max.apply(null,rA);X.push({minValue:mA,maxValue:LA,dimStats:{minValues:hA,maxValues:rA},depthStats:{minValues:hA,maxValues:rA}})}else X.push({minValue:pA[AA],maxValue:qA[AA]});return e(O),gA||e(eA),_},zs.decode=(I,E)=>{const{maskCount:C,depthCount:Q,bandCount:h,width:l,height:B,dataType:c,bandCountWithNoData:R}=E,p=XE[c],d=l*B,w=new Uint8Array(d*h),S=d*Q*h*p.size,F=new Uint8Array(S),N=new Uint8Array(h),u=new Uint8Array(h*8),[f,m,T,M,_]=g([I.length,w.length,F.length,N.length,u.length]);r.set(I,f),r.set(w,m),r.set(F,T),r.set(N,M),r.set(u,_);const P=s(f,I.length,C,m,Q,l,B,h,c,T,M,_);if(P)throw e(f),`lerc-decode: error code is ${P}`;r=new Uint8Array(a.buffer),Ai(r,T,F),Ai(r,m,w);let b=null;if(R){Ai(r,M,N),Ai(r,_,u),b=[];const z=new Float64Array(u.buffer);for(let O=0;O<N.length;O++)b.push(N[O]?z[O]:null)}return e(f),{data:F,maskData:w,noDataValues:b}}}function Ff(i,A,e,t,n){if(e<2)return i;const s=new t(A*e);for(let o=0,r=0;o<A;o++)for(let a=0,g=o;a<e;a++,g+=A)s[g]=i[r++];return s}function Lf(i,A={}){var e,t;const n=(e=A.inputOffset)!==null&&e!==void 0?e:0,s=i instanceof Uint8Array?i.subarray(n):new Uint8Array(i,n),o=zs.getBlobInfo(s),{data:r,maskData:a}=zs.decode(s,o),{width:g,height:I,bandCount:E,dimCount:C,depthCount:Q,dataType:h,maskCount:l,statistics:B}=o,c=XE[h],R=new c.ctor(r.buffer),p=[],d=[],w=g*I,S=w*Q,F=(t=A.returnInterleaved)!==null&&t!==void 0?t:A.returnPixelInterleavedDims;for(let M=0;M<E;M++){const _=R.subarray(M*S,(M+1)*S);if(F)p.push(_);else{const P=Ff(_,w,Q,c.ctor);p.push(P)}d.push(a.subarray(M*S,(M+1)*S))}const N=l===0?null:l===1?d[0]:new Uint8Array(w);if(l>1){N.set(d[0]);for(let M=1;M<d.length;M++){const _=d[M];for(let P=0;P<w;P++)N[P]=N[P]&_[P]}}const{noDataValue:u}=A,f=u!=null&&c.range[0]<=u&&c.range[1]>=u;if(l>0&&f)for(let M=0;M<E;M++){const _=p[M],P=d[M]||N;for(let b=0;b<w;b++)P[b]===0&&(_[b]=u)}const m=l===E&&E>1?d:null,{pixelType:T}=c;return{width:g,height:I,pixelType:T,statistics:B,pixels:p,mask:N,dimCount:C,depthCount:Q,bandMasks:m}}class jE{gridSize;numTriangles;numParentTriangles;indices;coords;constructor(A=257){this.gridSize=A;const e=A-1;if(e&e-1)throw new Error(`Expected grid size to be 2^n+1, got ${A}.`);this.numTriangles=e*e*2-2,this.numParentTriangles=this.numTriangles-e*e,this.indices=new Uint32Array(this.gridSize*this.gridSize),this.coords=new Uint16Array(this.numTriangles*4);for(let t=0;t<this.numTriangles;t++){let n=t+2,s=0,o=0,r=0,a=0,g=0,I=0;for(n&1?r=a=g=e:s=o=I=e;(n>>=1)>1;){const C=s+r>>1,Q=o+a>>1;n&1?(r=s,a=o,s=g,o=I):(s=r,o=a,r=g,a=I),g=C,I=Q}const E=t*4;this.coords[E+0]=s,this.coords[E+1]=o,this.coords[E+2]=r,this.coords[E+3]=a}}createTile(A){return new _f(A,this)}}class _f{martini;terrain;errors;constructor(A,e){const t=e.gridSize;if(A.length!==t*t)throw new Error(`Expected terrain data of length ${t*t} (${t} x ${t}), got ${A.length}.`);this.terrain=A,this.martini=e,this.errors=new Float32Array(A.length),this.update()}update(){const{numTriangles:A,numParentTriangles:e,coords:t,gridSize:n}=this.martini,{terrain:s,errors:o}=this;for(let r=A-1;r>=0;r--){const a=r*4,g=t[a+0],I=t[a+1],E=t[a+2],C=t[a+3],Q=g+E>>1,h=I+C>>1,l=Q+h-I,B=h+g-Q,c=(s[I*n+g]+s[C*n+E])/2,R=h*n+Q,p=Math.abs(c-s[R]);if(o[R]=Math.max(o[R],p),r<e){const d=(I+B>>1)*n+(g+l>>1),w=(C+B>>1)*n+(E+l>>1);o[R]=Math.max(o[R],o[d],o[w])}}}getGeometryData(A=0){const{gridSize:e,indices:t}=this.martini,{errors:n}=this;let s=0,o=0;const r=e-1;let a,g,I=0;t.fill(0);function E(R,p,d,w,S,F){const N=R+d>>1,u=p+w>>1;Math.abs(R-S)+Math.abs(p-F)>1&&n[u*e+N]>A?(E(S,F,R,p,N,u),E(d,w,S,F,N,u)):(a=p*e+R,g=w*e+d,I=F*e+S,t[a]===0&&(t[a]=++s),t[g]===0&&(t[g]=++s),t[I]===0&&(t[I]=++s),o++)}E(0,0,r,r,r,0),E(r,r,0,0,0,r);let C=s*2,Q=o*3;const h=new Uint16Array(C),l=new Uint32Array(Q);let B=0;function c(R,p,d,w,S,F){const N=R+d>>1,u=p+w>>1;if(Math.abs(R-S)+Math.abs(p-F)>1&&n[u*e+N]>A)c(S,F,R,p,N,u),c(d,w,S,F,N,u);else{const f=t[p*e+R]-1,m=t[w*e+d]-1,T=t[F*e+S]-1;h[2*f]=R,h[2*f+1]=p,h[2*m]=d,h[2*m+1]=w,h[2*T]=S,h[2*T+1]=F,l[B++]=f,l[B++]=m,l[B++]=T}}return c(0,0,r,r,r,0),c(r,r,0,0,0,r),{attributes:this._getMeshAttributes(this.terrain,h,l),indices:l}}_getMeshAttributes(A,e,t){const n=Math.floor(Math.sqrt(A.length)),s=n-1,o=e.length/2,r=new Float32Array(o*3),a=new Float32Array(o*2);for(let I=0;I<o;I++){const E=e[I*2],C=e[I*2+1],Q=C*n+E;r[3*I+0]=E/s-.5,r[3*I+1]=.5-C/s,r[3*I+2]=A[Q],a[2*I+0]=E/s,a[2*I+1]=1-C/s}const g=YE(r,t);return{position:{value:r,size:3},texcoord:{value:a,size:2},normal:{value:g,size:3}}}}const Uf={0:7e3,1:6e3,2:5e3,3:4e3,4:3e3,5:2500,6:2e3,7:1500,8:800,9:500,10:200,11:100,12:40,13:12,14:5,15:2,16:1,17:.5,18:.2,19:.1,20:.05};function Gf(i,A,e){let t=i;e[2]-e[0]<1&&(t=vf(i,e));const{demArray:n,width:s}=t,o=new jE(s).createTile(n),r=Uf[A]/1e3||0,a=o.getGeometryData(r);return so(a.attributes,a.indices,1)}function vf(i,A){function e(o,r,a,g,I,E,C,Q){const h=new Float32Array(I*E);for(let B=0;B<E;B++)for(let c=0;c<I;c++){const R=(B+g)*r+(c+a),p=B*I+c;h[p]=o[R]}const l=new Float32Array(Q*C);for(let B=0;B<Q;B++)for(let c=0;c<C;c++){const R=B*Q+c,p=Math.round(c*E/Q),d=Math.round(B*I/C)*I+p;l[R]=h[d]}return l}const t=Tf(A,i.width),n=t.sw+1,s=t.sh+1;return{demArray:e(i.demArray,i.width,t.sx,t.sy,t.sw,t.sh,n,s),width:n,height:s}}function Tf(i,A){const e=Math.floor(i[0]*A),t=Math.floor(i[1]*A),n=Math.floor((i[2]-i[0])*A),s=Math.floor((i[3]-i[1])*A);return{sx:e,sy:t,sw:n,sh:s}}const $E="KGZ1bmN0aW9uKCl7InVzZSBzdHJpY3QiO2Z1bmN0aW9uIFMoLi4uZSl7Y29uc3QgdD1lLG89dCYmdC5sZW5ndGg+MSYmdFswXS5jb25zdHJ1Y3Rvcnx8bnVsbDtpZighbyl0aHJvdyBuZXcgRXJyb3IoJyJjb25jYXRlbmF0ZVR5cGVkQXJyYXlzIiAtIGluY29ycmVjdCBxdWFudGl0eSBvZiBhcmd1bWVudHMgb3IgYXJndW1lbnRzIGhhdmUgaW5jb21wYXRpYmxlIGRhdGEgdHlwZXMnKTtjb25zdCBzPXQucmVkdWNlKChpLHIpPT5pK3IubGVuZ3RoLDApLG49bmV3IG8ocyk7bGV0IGM9MDtmb3IoY29uc3QgaSBvZiB0KW4uc2V0KGksYyksYys9aS5sZW5ndGg7cmV0dXJuIG59ZnVuY3Rpb24gRChlLHQsbyxzKXtjb25zdCBuPU8odCksYz1uLmxlbmd0aCxpPW5ldyBGbG9hdDMyQXJyYXkoYyo2KSxyPW5ldyBGbG9hdDMyQXJyYXkoYyo0KSxoPW5ldyB0LmNvbnN0cnVjdG9yKGMqNiksdT1uZXcgRmxvYXQzMkFycmF5KGMqNik7Zm9yKGxldCBhPTA7YTxjO2ErKykkKHtlZGdlOm5bYV0sZWRnZUluZGV4OmEsYXR0cmlidXRlczplLHNraXJ0SGVpZ2h0Om8sbmV3UG9zaXRpb246aSxuZXdUZXhjb29yZDA6cixuZXdUcmlhbmdsZXM6aCxuZXdOb3JtYWxzOnV9KTtlLnBvc2l0aW9uLnZhbHVlPVMoZS5wb3NpdGlvbi52YWx1ZSxpKSxlLnRleGNvb3JkLnZhbHVlPVMoZS50ZXhjb29yZC52YWx1ZSxyKSxlLm5vcm1hbC52YWx1ZT1TKGUubm9ybWFsLnZhbHVlLHUpO2NvbnN0IGw9Uyh0LGgpO3JldHVybnthdHRyaWJ1dGVzOmUsaW5kaWNlczpsfX1mdW5jdGlvbiBPKGUpe2NvbnN0IHQ9W10sbz1BcnJheS5pc0FycmF5KGUpP2U6QXJyYXkuZnJvbShlKTtmb3IobGV0IG49MDtuPG8ubGVuZ3RoO24rPTMpe2NvbnN0IGM9b1tuXSxpPW9bbisxXSxyPW9bbisyXTt0LnB1c2goW2MsaV0sW2kscl0sW3IsY10pfXQuc29ydCgoW24sY10sW2kscl0pPT57Y29uc3QgaD1NYXRoLm1pbihuLGMpLHU9TWF0aC5taW4oaSxyKTtyZXR1cm4gaCE9PXU/aC11Ok1hdGgubWF4KG4sYyktTWF0aC5tYXgoaSxyKX0pO2NvbnN0IHM9W107Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aDtuKyspbisxPHQubGVuZ3RoJiZ0W25dWzBdPT09dFtuKzFdWzFdJiZ0W25dWzFdPT09dFtuKzFdWzBdP24rKzpzLnB1c2godFtuXSk7cmV0dXJuIHN9ZnVuY3Rpb24gJCh7ZWRnZTplLGVkZ2VJbmRleDp0LGF0dHJpYnV0ZXM6byxza2lydEhlaWdodDpzLG5ld1Bvc2l0aW9uOm4sbmV3VGV4Y29vcmQwOmMsbmV3VHJpYW5nbGVzOmksbmV3Tm9ybWFsczpyfSl7Y29uc3QgaD1vLnBvc2l0aW9uLnZhbHVlLmxlbmd0aCx1PXQqMixsPXUrMTtuLnNldChvLnBvc2l0aW9uLnZhbHVlLnN1YmFycmF5KGVbMF0qMyxlWzBdKjMrMyksdSozKSxuW3UqMysyXT1uW3UqMysyXS1zLG4uc2V0KG8ucG9zaXRpb24udmFsdWUuc3ViYXJyYXkoZVsxXSozLGVbMV0qMyszKSxsKjMpLG5bbCozKzJdPW5bbCozKzJdLXMsYy5zZXQoby50ZXhjb29yZC52YWx1ZS5zdWJhcnJheShlWzBdKjIsZVswXSoyKzIpLHUqMiksYy5zZXQoby50ZXhjb29yZC52YWx1ZS5zdWJhcnJheShlWzFdKjIsZVsxXSoyKzIpLGwqMik7Y29uc3QgYT10KjIqMztpW2FdPWVbMF0saVthKzFdPWgvMytsLGlbYSsyXT1lWzFdLGlbYSszXT1oLzMrbCxpW2ErNF09ZVswXSxpW2ErNV09aC8zK3UsclthXT0wLHJbYSsxXT0wLHJbYSsyXT0xLHJbYSszXT0wLHJbYSs0XT0wLHJbYSs1XT0xfWZ1bmN0aW9uIFUoZSx0KXtjb25zdCBvPW5ldyBGbG9hdDMyQXJyYXkoZS5sZW5ndGgpO2ZvcihsZXQgcz0wO3M8dC5sZW5ndGg7cys9Myl7Y29uc3Qgbj10W3NdKjMsYz10W3MrMV0qMyxpPXRbcysyXSozLHI9ZVtuXSxoPWVbbisxXSx1PWVbbisyXSxsPWVbY10sYT1lW2MrMV0seT1lW2MrMl0sTT1lW2ldLGc9ZVtpKzFdLHY9ZVtpKzJdLHc9bC1yLGY9YS1oLGQ9eS11LG09TS1yLHg9Zy1oLHA9di11LEE9ZipwLWQqeCx6PWQqbS13KnAsRT13KngtZiptLEk9TWF0aC5zcXJ0KEEqQSt6KnorRSpFKSxGPVswLDAsMV07aWYoST4wKXtjb25zdCBUPTEvSTtGWzBdPUEqVCxGWzFdPXoqVCxGWzJdPUUqVH1mb3IobGV0IFQ9MDtUPDM7VCsrKW9bbitUXT1vW2MrVF09b1tpK1RdPUZbVF19cmV0dXJuIG99Y2xhc3MgcXtncmlkU2l6ZTtudW1UcmlhbmdsZXM7bnVtUGFyZW50VHJpYW5nbGVzO2luZGljZXM7Y29vcmRzO2NvbnN0cnVjdG9yKHQ9MjU3KXt0aGlzLmdyaWRTaXplPXQ7Y29uc3Qgbz10LTE7aWYobyZvLTEpdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBncmlkIHNpemUgdG8gYmUgMl5uKzEsIGdvdCAke3R9LmApO3RoaXMubnVtVHJpYW5nbGVzPW8qbyoyLTIsdGhpcy5udW1QYXJlbnRUcmlhbmdsZXM9dGhpcy5udW1UcmlhbmdsZXMtbypvLHRoaXMuaW5kaWNlcz1uZXcgVWludDMyQXJyYXkodGhpcy5ncmlkU2l6ZSp0aGlzLmdyaWRTaXplKSx0aGlzLmNvb3Jkcz1uZXcgVWludDE2QXJyYXkodGhpcy5udW1UcmlhbmdsZXMqNCk7Zm9yKGxldCBzPTA7czx0aGlzLm51bVRyaWFuZ2xlcztzKyspe2xldCBuPXMrMixjPTAsaT0wLHI9MCxoPTAsdT0wLGw9MDtmb3IobiYxP3I9aD11PW86Yz1pPWw9bzsobj4+PTEpPjE7KXtjb25zdCB5PWMrcj4+MSxNPWkraD4+MTtuJjE/KHI9YyxoPWksYz11LGk9bCk6KGM9cixpPWgscj11LGg9bCksdT15LGw9TX1jb25zdCBhPXMqNDt0aGlzLmNvb3Jkc1thKzBdPWMsdGhpcy5jb29yZHNbYSsxXT1pLHRoaXMuY29vcmRzW2ErMl09cix0aGlzLmNvb3Jkc1thKzNdPWh9fWNyZWF0ZVRpbGUodCl7cmV0dXJuIG5ldyBMKHQsdGhpcyl9fWNsYXNzIEx7bWFydGluaTt0ZXJyYWluO2Vycm9ycztjb25zdHJ1Y3Rvcih0LG8pe2NvbnN0IHM9by5ncmlkU2l6ZTtpZih0Lmxlbmd0aCE9PXMqcyl0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIHRlcnJhaW4gZGF0YSBvZiBsZW5ndGggJHtzKnN9ICgke3N9IHggJHtzfSksIGdvdCAke3QubGVuZ3RofS5gKTt0aGlzLnRlcnJhaW49dCx0aGlzLm1hcnRpbmk9byx0aGlzLmVycm9ycz1uZXcgRmxvYXQzMkFycmF5KHQubGVuZ3RoKSx0aGlzLnVwZGF0ZSgpfXVwZGF0ZSgpe2NvbnN0e251bVRyaWFuZ2xlczp0LG51bVBhcmVudFRyaWFuZ2xlczpvLGNvb3JkczpzLGdyaWRTaXplOm59PXRoaXMubWFydGluaSx7dGVycmFpbjpjLGVycm9yczppfT10aGlzO2ZvcihsZXQgcj10LTE7cj49MDtyLS0pe2NvbnN0IGg9cio0LHU9c1toKzBdLGw9c1toKzFdLGE9c1toKzJdLHk9c1toKzNdLE09dSthPj4xLGc9bCt5Pj4xLHY9TStnLWwsdz1nK3UtTSxmPShjW2wqbit1XStjW3kqbithXSkvMixkPWcqbitNLG09TWF0aC5hYnMoZi1jW2RdKTtpZihpW2RdPU1hdGgubWF4KGlbZF0sbSkscjxvKXtjb25zdCB4PShsK3c+PjEpKm4rKHUrdj4+MSkscD0oeSt3Pj4xKSpuKyhhK3Y+PjEpO2lbZF09TWF0aC5tYXgoaVtkXSxpW3hdLGlbcF0pfX19Z2V0R2VvbWV0cnlEYXRhKHQ9MCl7Y29uc3R7Z3JpZFNpemU6byxpbmRpY2VzOnN9PXRoaXMubWFydGluaSx7ZXJyb3JzOm59PXRoaXM7bGV0IGM9MCxpPTA7Y29uc3Qgcj1vLTE7bGV0IGgsdSxsPTA7cy5maWxsKDApO2Z1bmN0aW9uIGEoZCxtLHgscCxBLHope2NvbnN0IEU9ZCt4Pj4xLEk9bStwPj4xO01hdGguYWJzKGQtQSkrTWF0aC5hYnMobS16KT4xJiZuW0kqbytFXT50PyhhKEEseixkLG0sRSxJKSxhKHgscCxBLHosRSxJKSk6KGg9bSpvK2QsdT1wKm8reCxsPXoqbytBLHNbaF09PT0wJiYoc1toXT0rK2MpLHNbdV09PT0wJiYoc1t1XT0rK2MpLHNbbF09PT0wJiYoc1tsXT0rK2MpLGkrKyl9YSgwLDAscixyLHIsMCksYShyLHIsMCwwLDAscik7bGV0IHk9YyoyLE09aSozO2NvbnN0IGc9bmV3IFVpbnQxNkFycmF5KHkpLHY9bmV3IFVpbnQzMkFycmF5KE0pO2xldCB3PTA7ZnVuY3Rpb24gZihkLG0seCxwLEEseil7Y29uc3QgRT1kK3g+PjEsST1tK3A+PjE7aWYoTWF0aC5hYnMoZC1BKStNYXRoLmFicyhtLXopPjEmJm5bSSpvK0VdPnQpZihBLHosZCxtLEUsSSksZih4LHAsQSx6LEUsSSk7ZWxzZXtjb25zdCBGPXNbbSpvK2RdLTEsVD1zW3Aqbyt4XS0xLEM9c1t6Km8rQV0tMTtnWzIqRl09ZCxnWzIqRisxXT1tLGdbMipUXT14LGdbMipUKzFdPXAsZ1syKkNdPUEsZ1syKkMrMV09eix2W3crK109Rix2W3crK109VCx2W3crK109Q319cmV0dXJuIGYoMCwwLHIscixyLDApLGYocixyLDAsMCwwLHIpLHthdHRyaWJ1dGVzOnRoaXMuX2dldE1lc2hBdHRyaWJ1dGVzKHRoaXMudGVycmFpbixnLHYpLGluZGljZXM6dn19X2dldE1lc2hBdHRyaWJ1dGVzKHQsbyxzKXtjb25zdCBuPU1hdGguZmxvb3IoTWF0aC5zcXJ0KHQubGVuZ3RoKSksYz1uLTEsaT1vLmxlbmd0aC8yLHI9bmV3IEZsb2F0MzJBcnJheShpKjMpLGg9bmV3IEZsb2F0MzJBcnJheShpKjIpO2ZvcihsZXQgbD0wO2w8aTtsKyspe2NvbnN0IGE9b1tsKjJdLHk9b1tsKjIrMV0sTT15Km4rYTtyWzMqbCswXT1hL2MtLjUsclszKmwrMV09LjUteS9jLHJbMypsKzJdPXRbTV0saFsyKmwrMF09YS9jLGhbMipsKzFdPTEteS9jfWNvbnN0IHU9VShyLHMpO3JldHVybntwb3NpdGlvbjp7dmFsdWU6cixzaXplOjN9LHRleGNvb3JkOnt2YWx1ZTpoLHNpemU6Mn0sbm9ybWFsOnt2YWx1ZTp1LHNpemU6M319fX1jb25zdCBWPXswOjdlMywxOjZlMywyOjVlMywzOjRlMyw0OjNlMyw1OjI1MDAsNjoyZTMsNzoxNTAwLDg6ODAwLDk6NTAwLDEwOjIwMCwxMToxMDAsMTI6NDAsMTM6MTIsMTQ6NSwxNToyLDE2OjEsMTc6LjUsMTg6LjIsMTk6LjEsMjA6LjA1fTtmdW5jdGlvbiBZKGUsdCxvKXtsZXQgcz1lO29bMl0tb1swXTwxJiYocz1rKGUsbykpO2NvbnN0e2RlbUFycmF5Om4sd2lkdGg6Y309cyxyPW5ldyBxKGMpLmNyZWF0ZVRpbGUobiksaD1WW3RdLzFlM3x8MCx1PXIuZ2V0R2VvbWV0cnlEYXRhKGgpO3JldHVybiBEKHUuYXR0cmlidXRlcyx1LmluZGljZXMsMSl9ZnVuY3Rpb24gayhlLHQpe2Z1bmN0aW9uIG8ocixoLHUsbCxhLHksTSxnKXtjb25zdCB2PW5ldyBGbG9hdDMyQXJyYXkoYSp5KTtmb3IobGV0IGY9MDtmPHk7ZisrKWZvcihsZXQgZD0wO2Q8YTtkKyspe2NvbnN0IG09KGYrbCkqaCsoZCt1KSx4PWYqYStkO3ZbeF09clttXX1jb25zdCB3PW5ldyBGbG9hdDMyQXJyYXkoZypNKTtmb3IobGV0IGY9MDtmPGc7ZisrKWZvcihsZXQgZD0wO2Q8TTtkKyspe2NvbnN0IG09ZipnK2QseD1NYXRoLnJvdW5kKGQqeS9nKSxBPU1hdGgucm91bmQoZiphL00pKmEreDt3W21dPXZbQV19cmV0dXJuIHd9Y29uc3Qgcz1HKHQsZS53aWR0aCksbj1zLnN3KzEsYz1zLnNoKzE7cmV0dXJue2RlbUFycmF5Om8oZS5kZW1BcnJheSxlLndpZHRoLHMuc3gscy5zeSxzLnN3LHMuc2gsbixjKSx3aWR0aDpuLGhlaWdodDpjfX1mdW5jdGlvbiBHKGUsdCl7Y29uc3Qgbz1NYXRoLmZsb29yKGVbMF0qdCkscz1NYXRoLmZsb29yKGVbMV0qdCksbj1NYXRoLmZsb29yKChlWzJdLWVbMF0pKnQpLGM9TWF0aC5mbG9vcigoZVszXS1lWzFdKSp0KTtyZXR1cm57c3g6byxzeTpzLHN3Om4sc2g6Y319c2VsZi5vbm1lc3NhZ2U9ZT0+e2NvbnN0IHQ9ZS5kYXRhLG89WSh0LmRlbURhdGEsdC56LHQuY2xpcEJvdW5kcyk7c2VsZi5wb3N0TWVzc2FnZShvKSxzZWxmLmNsb3NlKCl9fSkoKTsK",bf=i=>Uint8Array.from(atob(i),A=>A.charCodeAt(0)),CI=typeof self<"u"&&self.Blob&&new Blob([bf($E)],{type:"text/javascript;charset=utf-8"});function kf(i){let A;try{if(A=CI&&(self.URL||self.webkitURL).createObjectURL(CI),!A)throw"";const e=new Worker(A,{name:i?.name});return e.addEventListener("error",()=>{(self.URL||self.webkitURL).revokeObjectURL(A)}),e}catch{return new Worker("data:text/javascript;base64,"+$E,{name:i?.name})}finally{A&&(self.URL||self.webkitURL).revokeObjectURL(A)}}const Hf="data:application/wasm;base64,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Tg0AA0AgCiACQQN0ai8BAEUNASACQQFqIgIgA0cNAAsgAyECDAELIAIhBSACIANODQEDQCAKIAVBA3RqLwEADQIgBUEBaiIFIANHDQALCyADIAJrIgUgCSAFIAlKIgUbIQkgAiAIIAUbIQgMAgsgBSACayILIAkgCSALSCILGyEJIAIgCCALGyEIIAMgBSICSg0ACwsgAyAJayAAIARrSARAIAYgCCAJajYCFCAGIAMgCGoiADYCECAGKAIUIQQLQQAhAiAAIARMDQAgACAEayIFQQFxIQkCQCAEQQFqIABGBEBBACEADAELIAVBfnEhBUEAIQADQCAAIAogBEEAIAMgAyAEShtrQQN0ai8BACIIIAAgCEobIgAgCiAEQQFqIghBACADIAMgCEoba0EDdGovAQAiCCAAIAhKGyEAIARBAmohBCACQQJqIgIgBUcNAAsLIAkEQCAAIAogBEEAIAMgAyAEShtrQQN0ai8BACICIAAgAkobIQALIABBIWsiAkFgTwRAIAYgADYCDAsgAkFfSyECCwJAIAIiCkUNACAHKAIIIQwgBygCBCENIAEgBigCDCILIAcoAhwiDiALIA5IGyIANgIAIAcgBygCEDYCFCAGQX82AhhBACEFQQAhCAJAQQEgAHQiAyAHKAIYIgAgBygCECICa0ECdU0EQAJAIAcoAhQiBSACa0ECdSIJIAMgAyAJSxsiBEUNACAEQQFrIQ8CQCAEQQNxIhBFBEAgAiEADAELIAIhAANAIAAgBi8BGDsBACAAIAYvARo7AQIgBEEBayEEIABBBGohACAIQQFqIgggEEcNAAsLIA9BA0kNAANAIAAgBi8BGDsBACAAIAYvARo7AQIgACAGLwEYOwEEIAAgBi8BGjsBBiAAIAYvARg7AQggACAGLwEaOwEKIAAgBi8BGDsBDCAAIAYvARo7AQ4gAEEQaiEAIARBBGsiBA0ACwsgAyAJSwRAIAUgAyAJa0ECdGohAANAIAUgBigBGDYBACAFQQRqIgUgAEcNAAsgByAANgIUDAILIAcgAiADQQJ0ajYCFAwBCyACBEAgByACNgIUIAIQBiAHQQA2AhggB0IANwIQQQAhAAsCQCADQYCAgIAETw0AIABBAXUiAiADIAIgA0sbQf////8DIABB/P///wdJGyIAQYCAgIAETw0AIAcgAEECdCIAEAki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QYCAgHxxakGAgIB8cXIiCDYCACADIAQgB2oiB0ECdGoiASAJIAEoAgAiAWpB////A3EgCCABQYCAgHxxakGAgIB8cXIiATYCACAEIAdqIQcgD0ECaiIPIBZHDQALCyAQRQ0AIAMgB0ECdGoiByABIAcoAgAiB2pB////A3EgASAHQYCAgHxxakGAgIB8cXI2AgALIANBBGohAyARQQFqIhEgBEcNAAsLIAVFDQIgBEEBayIBQX5xIRIgAUEBcSEJQQAhESAEQQJJIQgDQAJAIAgNACAAKAIAIQNBACEPQQEhASAEQQJHBEADQCAAIAFBAnRqIgogCigCACIHQYCAgHxxIANqQYCAgHxxIAMgB2oiB0H///8DcXIiAzYCACAKIAMgCigCBCIDQYCAgHxxakGAgIB8cSADIAdqQf///wNxciIDNgIEIAFBAmohASAPQQJqIg8gEkcNAAsLIAlFDQAgACABQQJ0aiIBIAEoAgAiAUGAgIB8cSADakGAgIB8cSABIANqQf///wNxcjYCAAsgACAEQQJ0aiEAIBFBAWoiESAFRw0ACwwCC0GTDEH/CEGaB0GUCBAAAAsgBARAIAVBAmshECAFQQFrIgFBfnEhCiABQQFxIRIgBUECSSEJIAAhAwNAAkAgCQ0AIARBAUcEQEEAIQcgBCEBIBAEQANAIAMgAUEDdGoiCCADIAEgBGtBA3RqKQMAIiMgCCkDACIkfCIlQv////////8HgyAjICRCgICAgICAgHiDfEKAgICAgICAeIOEIiM3AwAgAyABIARqIghBA3RqIgEgJSABKQMAIiR8Qv////////8HgyAjICRCgICAgICAgHiDfEKAgICAgICAeIOENwMAIAQgCGohASAHQQJqIgcgCkcNAAsLIBJFDQEgAyABQQN0aiIHIAMgASAEa0EDdGopAwAiIyAHKQMAIiR8Qv////////8HgyAjICRCgICAgICAgHiDfEKAgICAgICAeIOENwMADAELIAMpAwAhI0EAIQcgBCEBIBAEQANAIAMgAUEDdGoiCCAjIAgpAwAiJHwiJUL/////////B4MgIyAkQoCAgICAgIB4g3xCgICAgICAgHiDhCIjNwMAIAMgASAEaiIIQQN0aiIBICUgASkDACIkfEL/////////B4MgIyAkQoCAgICAgIB4g3xCgICAgICAgHiDhCIjNwMAIAQgCGohASAHQQJqIgcgCkcNAAsLIBJFDQAgAyABQQN0aiIBICMgASkDACIkfEL/////////B4MgIyAkQoCAgICAgIB4g3xCgICAgICAgHiDhDcDAAsgA0EIaiEDIA9BAWoiDyAERw0ACwsgBUUNACAEQQFrIgFBfnEhEiABQQFxIQlBACEPIARBAkkhCANAAkAgCA0AIAApAwAhI0EAIQdBASEDIARBAkcEQANAIAAgA0EDdGoiASABKQMAIiRCgICAgICAgHiDICN8QoCAgICAgIB4gyAjICR8IiVC/////////weDhCIjNwMAIAEgIyABKQMIIiRCgICAgICAgHiDfEKAgICAgICAeIMgJCAlfEL/////////B4OEIiM3AwggA0ECaiEDIAdBAmoiByASRw0ACwsgCUUNACAAIANBA3RqIgEgASkDACIkQoCAgICAgIB4gyAjfEKAgICAgICAeIMgIyAkfEL/////////B4OENwMACyAAIARBA3RqIQAgD0EBaiIPIAVHDQALCyAfQQVGBEAgBiAaEFALIBgEQCAYIAY2AgAMAQsgBhAGCyAGQQBHDAILQY4LQbwIQfIEQZQIEAAACwwECyEeDAELAn8gDEEMaiEVQQAhDiAAQQJJBEAgDCgCFCIKIAwoAhAiEmsiA0EDdSIPIB8QLEYEQEEBIABBAkZBAXQgAEEBRhshHgJAIA8gBCAFbCIYbBASIgFFDQAgGARAIA9BASAPQQFLGyIAQX5xIQkgAEEBcSEIIAwoAhAhFkEAIREgA0EQSSEHA0ACQCAKIBJGDQBBACEAQQAhECAHRQRAA0AgASAWIABBA3QiBmoiAygCACAOamogAygCBCARai0AADoAACABIBYgBkEIcmoiAygCACAOamogAygCBCARai0AADoAACAAQQJqIQAgEEECaiIQIAlHDQALCyAIRQ0AIAEgFiAAQQN0aiIAKAIAIA5qaiAAKAIEIBFqLQAAOgAACyAOIA9qIQ4gEUEBaiIRIBhHDQALCyABIQBBACERAkAgHkUNAAJAAkACQCAfQQVrDgIAAgELAkAgHkECRw0AIAVFDQAgBEEBcSEWIARBAmtBfnEhECAEQQNJIQogACEDA0ACQCAKDQAgAygCBCEOQQAhD0ECIQYgBEEDRwRAA0AgAyAGQQJ0IhJqIgcgBygCACIHQYCAgHxxIA5qQYCAgHxxIAcgDmoiCUH///8DcXIiCDYCACADIBJBBHJqIgcgBygCACIHQYCAgHxxIAhqQYCAgHxxIAcgCWpB////A3FyIg42AgAgBkECaiEGIA9BAmoiDyAQRw0ACwsgFkUNACADIAZBAnRqIgYgBigCACIGQYCAgHxxIA5qQYCAgHxxIAYgDmpB////A3FyNgIACyADIARBAnRqIQMgEUEBaiIRIAVHDQALCyAeQQBMDQIgBUUNAiAEQQFrIgNBfnEhCiADQQFxIRJBACERIARBAkkhCQNAAkAgCQ0AIAAoAgAhDkEAIQ9BASEGIARBAkcEQANAIAAgBkECdGoiECAQKAIAIgNBgICAfHEgDmpBgICAfHEgAyAOaiIIQf///wNxciIHNgIAIBAgByAQKAIEIgNBgICAfHFqQYCAgHxxIAMgCGpB////A3FyIg42AgQgBkECaiEGIA9BAmoiDyAKRw0ACwsgEkUNACAAIAZBAnRqIgMgAygCACIDQYCAgHxxIA5qQYCAgHxxIAMgDmpB////A3FyNgIACyAAIARBAnRqIQAgEUEBaiIRIAVHDQALDAILQZMMQf8IQYEGQasLEAAACwJAIB5BAkcNACAFRQ0AIARBAXEhCiAEQQJrQX5xIRIgBEEDSSEJIAAhBgNAAkAgCQ0AIAYpAwghI0EAIQNBAiEOIARBA0cEQANAIAYgDkEDdCIIaiIHIAcpAwAiJEKAgICAgICAeIMgI3xCgICAgICAgHiDICMgJHwiJUL/////////B4OEIiM3AwAgBiAIQQhyaiIHICMgBykDACIkQoCAgICAgIB4g3xCgICAgICAgHiDICQgJXxC/////////weDhCIjNwMAIA5BAmohDiADQQJqIgMgEkcNAAsLIApFDQAgBiAOQQN0aiIDIAMpAwAiJEKAgICAgICAeIMgI3xCgICAgICAgHiDICMgJHxC/////////weDhDcDAAsgBiAEQQN0aiEGIBFBAWoiESAFRw0ACwsgHkEATA0AIAVFDQAgBEEBayIDQX5xIQkgA0EBcSEIQQAhBiAEQQJJIQcDQAJAIAcNACAAKQMAISNBACEDQQEhDiAEQQJHBEADQCAAIA5BA3RqIhIgEikDACIkQoCAgICAgIB4gyAjfEKAgICAgICAeIMgIyAkfCIlQv////////8Hg4QiIzcDACASICMgEikDCCIkQoCAgICAgIB4g3xCgICAgICAgHiDICQgJXxC/////////weDhCIjNwMIIA5BAmohDiADQQJqIgMgCUcNAAsLIAhFDQAgACAOQQN0aiIDIAMpAwAiJEKAgICAgICAeIMgI3xCgICAgICAgHiDICMgJHxC/////////weDhDcDAAsgACAEQQN0aiEAIAZBAWoiBiAFRw0ACwsgH0EFRgRAIAEgGBBQCyAVBEAgFSABNgIADAELIAEQBgsgAUEARwwCCwsMAwshHgsgDCgCECIAIAtHBEBBACEDIAAhCwNAIAsgA0EDdGooAgQQBiADQQFqIgMgDCgCFCAMKAIQIgtrQQN1SQ0ACwsgDCALNgIUIAwoAgwiAARAIAIgACAaICBsEAgaIAAQBgsgHgshASAMKAIQIgAEQCAAEAYLIAxBIGokACABDwtBBBACIgBB0As2AgAgAEG8EkEAEAEAC9cBAQV/AkAgAUUNACABQQFHBEAgAUF+cSEFA0AgACADQQJ0IgZqIgIgAigCACICQQF2QYCAgPwHcSACQf///wNxciACQQh0QYCAgIB4cXI2AgAgACAGQQRyaiICIAIoAgAiAkEBdkGAgID8B3EgAkH///8DcXIgAkEIdEGAgICAeHFyNgIAIANBAmohAyAEQQJqIgQgBUcNAAsLIAFBAXFFDQAgACADQQJ0aiIAIAAoAgAiAEEBdkGAgID8B3EgAEH///8DcXIgAEEIdEGAgICAeHFyNgIACwsLACAAEFIaIAAQBgsxAQJ/IABB7BU2AgAgACgCBEEMayIBIAEoAghBAWsiAjYCCCACQQBIBEAgARAGCyAAC90BAQR/IABBADYCCCAAQgA3AgACQCABBEAgAUGAgICABE8NASAAIAFBAnQiBBAJIgM2AgAgACADIARqIgQ2AgggAUEBa0H/////A3EhBSACKAIAIQIgAUEHcSIGBEBBACEBA0AgAyACNgIAIANBBGohAyABQQFqIgEgBkcNAAsLIAVBB08EQANAIAMgAjYCHCADIAI2AhggAyACNgIUIAMgAjYCECADIAI2AgwgAyACNgIIIAMgAjYCBCADIAI2AgAgA0EgaiIDIARHDQALCyAAIAQ2AgQLIAAPCxAKAAuaAQAgAEEBOgA1AkAgACgCBCACRw0AIABB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QmxvY2tTZXF1ZW5jZQByZXN0b3JlU2VxdWVuY2UAQXNzZXJ0aW9uIGZhaWxlZABzdGQ6OmJhZF9hbGxvYwBwcEJ5dGVbMF0gPT0gSFVGRk1BTl9OT1JNQUwAc2l6ZSA+IDAAUHVyZSB2aXJ0dWFsIGZ1bmN0aW9uIGNhbGxlZCEAQ250WkltYWdlIABMZXJjMiAAAAAAAAAAAHAGAAABAAAAAgAAAE42TGVyY05TMTBCaXRTdHVmZmVyRQAAALQJAABYBgAAAAAAAOgGAAAFAAAABgAAAAcAAAAIAAAACQAAAE42TGVyY05TOUNudFpJbWFnZUUATjZMZXJjTlM2VEltYWdlSU5TXzRDbnRaRUVFAE42TGVyY05TNUltYWdlRQC0CQAAxAYAANwJAACoBgAA1AYAANwJAACUBgAA3AYAAAAAAADcBgAACgAAAAsAAAAMAAAACAAAAAkAAAAAAAAAMAcAAA0AAAAOAAAATjZMZXJjTlM1TGVyYzJFALQJAAAgBwAAAAAAAGAHAAAPAAAAEAAAAE42TGVyY05TMTFCaXRTdHVmZmVyMkUAALQJAABIBwAAAAAAAIwHAAARAAAAEgAAAE42TGVyY05TN0JpdE1hc2tFAAAAtAkAAHgHAABOMTBfX2N4eGFiaXYxMTZfX3NoaW1fdHlwZV9pbmZvRQAAAADcCQAAlAcAAFgLAABOMTBfX2N4eGFiaXYxMTdfX2NsYXNzX3R5cGVfaW5mb0UAAADcCQAAxAcAALgHAABOMTBfX2N4eGFiaXYxMTdfX3BiYXNlX3R5cGVfaW5mb0UAAADcCQAA9AcAALgHAABOMTBfX2N4eGFiaXYxMTlfX3BvaW50ZXJfdHlwZV9pbmZvRQDcCQAAJAgAABgIAABOMTBfX2N4eGFiaXYxMjBfX2Z1bmN0aW9uX3R5cGVfaW5mb0UAAAAA3AkAAFQIAAC4BwAATjEwX19jeHhhYml2MTI5X19wb2ludGVyX3RvX21lbWJlcl90eXBlX2luZm9FAAAA3AkAAIgIAAAYCAAAAAAAAAgJAAATAAAAFAAAABUAAAAWAAAAFwAAAE4xMF9fY3h4YWJpdjEyM19fZnVuZGFtZW50YWxfdHlwZV9pbmZvRQDcCQAA4AgAALgHAAB2AAAAzAgAABQJAABEbgAAzAgAACAJAABjAAAAzAgAACwJAABQS2MAOAoAADgJAAABAAAAMAkAAGgAAADMCAAATAkAAGEAAADMCAAAWAkAAHMAAADMCAAAZAkAAHQAAADMCAAAcAkAAGkAAADMCAAAfAkAAGoAAADMCAAAiAkAAGYAAADMCAAAlAkAAGQAAADMCAAAoAkAAAAAAADoBwAAEwAAABgAAAAVAAAAFgAAABkAAAAaAAAAGwAAABwAAAAAAAAAJAoAABMAAAAdAAAAFQAAABYAAAAZAAAAHgAAAB8AAAAgAAAATjEwX19jeHhhYml2MTIwX19zaV9jbGFzc190eXBlX2luZm9FAAAAANwJAAD8CQAA6AcAAAAAAABICAAAEwAAACEAAAAVAAAAFgAAACIAAAAAAAAAsAoAAAQAAAAjAAAAJAAAAAAAAADYCgAABAAAACUAAAAmAAAAAAAAAJgKAAAEAAAAJwAAACgAAABTdDlleGNlcHRpb24AAAAAtAkAAIgKAABTdDliYWRfYWxsb2MAAAAA3AkAAKAKAACYCgAAU3QyMGJhZF9hcnJheV9uZXdfbGVuZ3RoAAAAANwJAAC8CgAAsAoAAAAAAAAICwAAAwAAACkAAAAqAAAAU3QxMWxvZ2ljX2Vycm9yANwJAAD4CgAAmAoAAAAAAAA8CwAAAwAAACsAAAAqAAAAU3QxMmxlbmd0aF9lcnJvcgAAAADcCQAAKAsAAAgLAABTdDl0eXBlX2luZm8AAAAAtAkAAEgLAEHgFgsDYA1Q";class Pf extends VE{dataType="lerc";discription="Tile LERC terrain loader. It can load ArcGis-lerc format terrain data.";fileLoader=new wa(Ee.manager);constructor(){super(),this.fileLoader.setResponseType("arraybuffer")}async decode(A){Mf()||await Sf({locateFile:()=>Hf});const{height:e,width:t,pixels:n}=Lf(A),s=new Float32Array(e*t);for(let o=0;o<s.length;o++)s[o]=n[0][o]/1e3;return{demArray:s,width:t,height:e}}doLoad(A,e,t,n){this.fileLoader.load(A,async s=>{const o=await this.decode(s);e(o)},void 0,t,n)}doPrase(A,e,t,n,s,o){if(this.useWorker){const r=new kf;r.onmessage=a=>{o(a.data)},r.postMessage({demData:A,z:n,clipBounds:s},[A.demArray.buffer])}else{const r=Gf(A,n,s);o(r)}}}Ee.registerGeometryLoader(new Pf);const Of=new Map([["centerX",Float64Array.BYTES_PER_ELEMENT],["centerY",Float64Array.BYTES_PER_ELEMENT],["centerZ",Float64Array.BYTES_PER_ELEMENT],["minHeight",Float32Array.BYTES_PER_ELEMENT],["maxHeight",Float32Array.BYTES_PER_ELEMENT],["boundingSphereCenterX",Float64Array.BYTES_PER_ELEMENT],["boundingSphereCenterY",Float64Array.BYTES_PER_ELEMENT],["boundingSphereCenterZ",Float64Array.BYTES_PER_ELEMENT],["boundingSphereRadius",Float64Array.BYTES_PER_ELEMENT],["horizonOcclusionPointX",Float64Array.BYTES_PER_ELEMENT],["horizonOcclusionPointY",Float64Array.BYTES_PER_ELEMENT],["horizonOcclusionPointZ",Float64Array.BYTES_PER_ELEMENT]]);function Ko(i){return i>>1^-(i&1)}function Jf(i){let A=0;const e={};for(const[t,n]of Of){const s=n===8?i.getFloat64:i.getFloat32;e[t]=s.call(i,A,!0),A+=n}return{header:e,headerEndPosition:A}}function Kf(i,A){let e=A;const t=3,n=i.getUint32(e,!0),s=new Uint16Array(n*t);e+=Uint32Array.BYTES_PER_ELEMENT;const o=Uint16Array.BYTES_PER_ELEMENT,r=n*o,a=e,g=a+r,I=g+r;let E=0,C=0,Q=0;for(let h=0;h<n;h++)E+=Ko(i.getUint16(a+o*h,!0)),C+=Ko(i.getUint16(g+o*h,!0)),Q+=Ko(i.getUint16(I+o*h,!0)),s[h]=E,s[h+n]=C,s[h+n*2]=Q;return e+=r*3,{vertexData:s,vertexDataEndPosition:e}}function Ln(i,A,e,t,n=!0){let s;const o=structuredClone(i);if(t===2?s=new Uint16Array(o,A,e):s=new Uint32Array(o,A,e),!n)return s;let r=0;for(let a=0;a<s.length;++a){const g=s[a];s[a]=r-g,Math.round(g)===0&&++r}return s}function Yf(i,A,e){let t=e;const n=A.length/3>65536?Uint32Array.BYTES_PER_ELEMENT:Uint16Array.BYTES_PER_ELEMENT;t%n!==0&&(t+=n-t%n);const s=i.getUint32(t,!0);t+=Uint32Array.BYTES_PER_ELEMENT;const o=s*3,r=Ln(i.buffer,t,o,n);return t+=o*n,{triangleIndicesEndPosition:t,triangleIndices:r}}function qf(i,A,e){let t=e;const n=A.length/3>65536?Uint32Array.BYTES_PER_ELEMENT:Uint16Array.BYTES_PER_ELEMENT,s=i.getUint32(t,!0);t+=Uint32Array.BYTES_PER_ELEMENT;const o=Ln(i.buffer,t,s,n,!1);t+=s*n;const r=i.getUint32(t,!0);t+=Uint32Array.BYTES_PER_ELEMENT;const a=Ln(i.buffer,t,r,n,!1);t+=r*n;const g=i.getUint32(t,!0);t+=Uint32Array.BYTES_PER_ELEMENT;const I=Ln(i.buffer,t,g,n,!1);t+=g*n;const E=i.getUint32(t,!0);t+=Uint32Array.BYTES_PER_ELEMENT;const C=Ln(i.buffer,t,E,n,!1);return t+=E*n,{edgeIndicesEndPosition:t,westIndices:o,southIndices:a,eastIndices:I,northIndices:C}}function Wf(i){return new Uint8Array(i.buffer,i.byteOffset,i.byteLength)}function Vf(i){return i.buffer.slice(i.byteOffset,i.byteOffset+i.byteLength)}function zf(i,A){const e={};if(i.byteLength<=A)return{extensions:e,extensionsEndPosition:A};let t=A;for(;t<i.byteLength;){const n=i.getUint8(t);t+=Uint8Array.BYTES_PER_ELEMENT;const s=i.getUint32(t,!0);t+=Uint32Array.BYTES_PER_ELEMENT;const o=new DataView(i.buffer,t,s);switch(n){case 1:{e.vertexNormals=Wf(o);break}case 2:{e.waterMask=Vf(o);break}}t+=s}return{extensions:e,extensionsEndPosition:t}}const _n={vertices:1,triangleIndices:2,edgeIndices:3,extensions:4},QI={maxDecodingStep:_n.extensions};function Xf(i,A=QI){const e={...QI,...A},t=new DataView(i),{header:n,headerEndPosition:s}=Jf(t);if(e.maxDecodingStep<_n.vertices)return{header:n};const{vertexData:o,vertexDataEndPosition:r}=Kf(t,s);if(e.maxDecodingStep<_n.triangleIndices)return{header:n,vertexData:o};const{triangleIndices:a,triangleIndicesEndPosition:g}=Yf(t,o,r);if(e.maxDecodingStep<_n.edgeIndices)return{header:n,vertexData:o,triangleIndices:a};const{westIndices:I,southIndices:E,eastIndices:C,northIndices:Q,edgeIndicesEndPosition:h}=qf(t,o,g);if(e.maxDecodingStep<_n.extensions)return{header:n,vertexData:o,triangleIndices:a,westIndices:I,northIndices:Q,eastIndices:C,southIndices:E};const{extensions:l}=zf(t,h);return{header:n,vertexData:o,triangleIndices:a,westIndices:I,northIndices:Q,eastIndices:C,southIndices:E,extensions:l}}class Zf extends Vn{build(A){if(this.dispose(),A.vertexData&&A.triangleIndices){const e=jf(A),{westIndices:t,northIndices:n,eastIndices:s,southIndices:o}=A,r=t&&n&&s&&o?{westIndices:t,northIndices:n,eastIndices:s,southIndices:o}:void 0;if(e){let a=A.triangleIndices;const{attributes:g,indices:I}=so(e,a,1,r);this.setIndex(new Qe(I,1)),this.setAttribute("position",new Qe(g.position.value,3)),this.setAttribute("uv",new Qe(g.texcoord.value,2)),this.setAttribute("normal",new Qe(new Float32Array(e.position.value.length),3))}}}setData(A){const e=Xf(A);return e.vertexData&&e.triangleIndices&&(this.build(e),this.computeBoundingBox(),this.computeBoundingSphere(),this.computeVertexNormals()),this}}function jf(i){if(!i.vertexData||!i.triangleIndices)return;const{minHeight:A,maxHeight:e}=i.header,[t,n,s,o]=[0,0,1,1],r=s-t,a=o-n,g=e-A,I=i.vertexData.length/3,E=new Float32Array(I*3),C=new Float32Array(I*2);for(let Q=0;Q<I;Q++){const h=i.vertexData[Q]/32767,l=i.vertexData[Q+I]/32767,B=i.vertexData[Q+I*2]/32767;E[3*Q+0]=h*r+t-.5,E[3*Q+1]=l*a+n-.5,E[3*Q+2]=(B*g+A)/1e3,C[2*Q+0]=h,C[2*Q+1]=l}return{position:{value:E,size:3},texcoord:{value:C,size:2},normal:{value:new Float32Array(E.length*2),size:3}}}class $f{dataType="quantized-mesh";discription="Cesium quantized-mesh tile loader. Unfinished!";_useWorker=!0;get useWorker(){return this._useWorker}set useWorker(A){this._useWorker=A}fileLoader=new wa(Ee.manager);constructor(){this.fileLoader.setResponseType("arraybuffer")}load(A,e,t,n,s,o){const r=A._getTileUrl(e,t,n),a=new Zf;return r?(this.fileLoader.load(r,g=>{a.setData(g),s()},void 0,g=>{s()},o),a):(s(),a)}}Ee.registerGeometryLoader(new $f);class Ap{dataType="single-image";discription="Single image loader. It can load an picture and Stick to the ground.";_image;_imageLoader=new bE(Ee.manager);load(A,e,t,n,s){const o=new Ra({transparent:!0,opacity:A.opacity}),r=A._getTileUrl(0,0,0);return n<A.minLevel||n>A.maxLevel||!r?(s(),o):this._image?.complete?(this._setTexture(o,A,e,t,n),s(),o):(this._loadImage(r,()=>{this._setTexture(o,A,e,t,n),s()}),o)}_loadImage(A,e){this._image=this._imageLoader.load(A,e,void 0,e)}_setTexture(A,e,t,n,s){const o=this._getTileTexture(e,t,n,s);A.setTexture(o),o.needsUpdate=!0}_getTileTexture(A,e,t,n){const s=A,o=256,r=new OffscreenCanvas(o,o);if(this._image){const g=r.getContext("2d"),I=s._projectionBounds,E=s._getTileBounds(e,t,n),C=this._image?.width||256,Q=this._image?.height||256,h=(I[2]-I[0])/C,l=(I[3]-I[1])/Q,B=(E[0]-I[0])/h,c=(I[3]-E[3])/l,R=(E[2]-E[0])/h,p=(E[3]-E[1])/l;g.drawImage(this._image,B,c,R,p,0,0,o,o)}const a=new de(r);return a.colorSpace=De,a}}Ee.registerMaterialLoader(new Ap);const ep={0:7e3,1:6e3,2:5e3,3:4e3,4:3e3,5:2500,6:2e3,7:1500,8:800,9:500,10:200,11:100,12:40,13:12,14:5,15:2,16:1,17:.5,18:.2,19:.1,20:.05};function tp(i,A){const e=ip(i),t=Math.floor(Math.sqrt(e.length)),n=new jE(t).createTile(e),s=ep[A]/1e3||0,o=n.getGeometryData(s);return so(o.attributes,o.indices,1)}function ip(i){const A=i.data,e=i.width,t=e+1,n=new Float32Array(t*t);for(let s=0,o=0;o<e;o++)for(let r=0;r<e;r++,s++){A[s*4+3]===0&&(n[s+o]=0);const a=s*4,g=A[a+0],I=A[a+1],E=A[a+2],C=g<<16|I<<8|E;n[s+o]=C/1e4-10}for(let s=t*(t-1),o=0;o<t-1;o++,s++)n[s]=n[s-t];for(let s=t-1,o=0;o<t;o++,s+=t)n[s]=n[s-1];return n}const AC="KGZ1bmN0aW9uKCl7InVzZSBzdHJpY3QiO2Z1bmN0aW9uIEkoLi4uYyl7Y29uc3QgaT1jLGU9aSYmaS5sZW5ndGg+MSYmaVswXS5jb25zdHJ1Y3Rvcnx8bnVsbDtpZighZSl0aHJvdyBuZXcgRXJyb3IoJyJjb25jYXRlbmF0ZVR5cGVkQXJyYXlzIiAtIGluY29ycmVjdCBxdWFudGl0eSBvZiBhcmd1bWVudHMgb3IgYXJndW1lbnRzIGhhdmUgaW5jb21wYXRpYmxlIGRhdGEgdHlwZXMnKTtjb25zdCBzPWkucmVkdWNlKChvLHIpPT5vK3IubGVuZ3RoLDApLHQ9bmV3IGUocyk7bGV0IG49MDtmb3IoY29uc3QgbyBvZiBpKXQuc2V0KG8sbiksbis9by5sZW5ndGg7cmV0dXJuIHR9ZnVuY3Rpb24gTyhjLGksZSxzKXtjb25zdCB0PSQoaSksbj10Lmxlbmd0aCxvPW5ldyBGbG9hdDMyQXJyYXkobio2KSxyPW5ldyBGbG9hdDMyQXJyYXkobio0KSxsPW5ldyBpLmNvbnN0cnVjdG9yKG4qNiksdT1uZXcgRmxvYXQzMkFycmF5KG4qNik7Zm9yKGxldCBhPTA7YTxuO2ErKylxKHtlZGdlOnRbYV0sZWRnZUluZGV4OmEsYXR0cmlidXRlczpjLHNraXJ0SGVpZ2h0OmUsbmV3UG9zaXRpb246byxuZXdUZXhjb29yZDA6cixuZXdUcmlhbmdsZXM6bCxuZXdOb3JtYWxzOnV9KTtjLnBvc2l0aW9uLnZhbHVlPUkoYy5wb3NpdGlvbi52YWx1ZSxvKSxjLnRleGNvb3JkLnZhbHVlPUkoYy50ZXhjb29yZC52YWx1ZSxyKSxjLm5vcm1hbC52YWx1ZT1JKGMubm9ybWFsLnZhbHVlLHUpO2NvbnN0IGg9SShpLGwpO3JldHVybnthdHRyaWJ1dGVzOmMsaW5kaWNlczpofX1mdW5jdGlvbiAkKGMpe2NvbnN0IGk9W10sZT1BcnJheS5pc0FycmF5KGMpP2M6QXJyYXkuZnJvbShjKTtmb3IobGV0IHQ9MDt0PGUubGVuZ3RoO3QrPTMpe2NvbnN0IG49ZVt0XSxvPWVbdCsxXSxyPWVbdCsyXTtpLnB1c2goW24sb10sW28scl0sW3Isbl0pfWkuc29ydCgoW3Qsbl0sW28scl0pPT57Y29uc3QgbD1NYXRoLm1pbih0LG4pLHU9TWF0aC5taW4obyxyKTtyZXR1cm4gbCE9PXU/bC11Ok1hdGgubWF4KHQsbiktTWF0aC5tYXgobyxyKX0pO2NvbnN0IHM9W107Zm9yKGxldCB0PTA7dDxpLmxlbmd0aDt0KyspdCsxPGkubGVuZ3RoJiZpW3RdWzBdPT09aVt0KzFdWzFdJiZpW3RdWzFdPT09aVt0KzFdWzBdP3QrKzpzLnB1c2goaVt0XSk7cmV0dXJuIHN9ZnVuY3Rpb24gcSh7ZWRnZTpjLGVkZ2VJbmRleDppLGF0dHJpYnV0ZXM6ZSxza2lydEhlaWdodDpzLG5ld1Bvc2l0aW9uOnQsbmV3VGV4Y29vcmQwOm4sbmV3VHJpYW5nbGVzOm8sbmV3Tm9ybWFsczpyfSl7Y29uc3QgbD1lLnBvc2l0aW9uLnZhbHVlLmxlbmd0aCx1PWkqMixoPXUrMTt0LnNldChlLnBvc2l0aW9uLnZhbHVlLnN1YmFycmF5KGNbMF0qMyxjWzBdKjMrMyksdSozKSx0W3UqMysyXT10W3UqMysyXS1zLHQuc2V0KGUucG9zaXRpb24udmFsdWUuc3ViYXJyYXkoY1sxXSozLGNbMV0qMyszKSxoKjMpLHRbaCozKzJdPXRbaCozKzJdLXMsbi5zZXQoZS50ZXhjb29yZC52YWx1ZS5zdWJhcnJheShjWzBdKjIsY1swXSoyKzIpLHUqMiksbi5zZXQoZS50ZXhjb29yZC52YWx1ZS5zdWJhcnJheShjWzFdKjIsY1sxXSoyKzIpLGgqMik7Y29uc3QgYT1pKjIqMztvW2FdPWNbMF0sb1thKzFdPWwvMytoLG9bYSsyXT1jWzFdLG9bYSszXT1sLzMraCxvW2ErNF09Y1swXSxvW2ErNV09bC8zK3UsclthXT0wLHJbYSsxXT0wLHJbYSsyXT0xLHJbYSszXT0wLHJbYSs0XT0wLHJbYSs1XT0xfWZ1bmN0aW9uIFUoYyxpKXtjb25zdCBlPW5ldyBGbG9hdDMyQXJyYXkoYy5sZW5ndGgpO2ZvcihsZXQgcz0wO3M8aS5sZW5ndGg7cys9Myl7Y29uc3QgdD1pW3NdKjMsbj1pW3MrMV0qMyxvPWlbcysyXSozLHI9Y1t0XSxsPWNbdCsxXSx1PWNbdCsyXSxoPWNbbl0sYT1jW24rMV0sZz1jW24rMl0sTT1jW29dLHg9Y1tvKzFdLHY9Y1tvKzJdLEU9aC1yLFM9YS1sLGQ9Zy11LG09TS1yLHo9eC1sLEE9di11LGY9UypBLWQqeix5PWQqbS1FKkEsVD1FKnotUyptLHc9TWF0aC5zcXJ0KGYqZit5KnkrVCpUKSxGPVswLDAsMV07aWYodz4wKXtjb25zdCBwPTEvdztGWzBdPWYqcCxGWzFdPXkqcCxGWzJdPVQqcH1mb3IobGV0IHA9MDtwPDM7cCsrKWVbdCtwXT1lW24rcF09ZVtvK3BdPUZbcF19cmV0dXJuIGV9Y2xhc3Mga3tncmlkU2l6ZTtudW1UcmlhbmdsZXM7bnVtUGFyZW50VHJpYW5nbGVzO2luZGljZXM7Y29vcmRzO2NvbnN0cnVjdG9yKGk9MjU3KXt0aGlzLmdyaWRTaXplPWk7Y29uc3QgZT1pLTE7aWYoZSZlLTEpdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBncmlkIHNpemUgdG8gYmUgMl5uKzEsIGdvdCAke2l9LmApO3RoaXMubnVtVHJpYW5nbGVzPWUqZSoyLTIsdGhpcy5udW1QYXJlbnRUcmlhbmdsZXM9dGhpcy5udW1UcmlhbmdsZXMtZSplLHRoaXMuaW5kaWNlcz1uZXcgVWludDMyQXJyYXkodGhpcy5ncmlkU2l6ZSp0aGlzLmdyaWRTaXplKSx0aGlzLmNvb3Jkcz1uZXcgVWludDE2QXJyYXkodGhpcy5udW1UcmlhbmdsZXMqNCk7Zm9yKGxldCBzPTA7czx0aGlzLm51bVRyaWFuZ2xlcztzKyspe2xldCB0PXMrMixuPTAsbz0wLHI9MCxsPTAsdT0wLGg9MDtmb3IodCYxP3I9bD11PWU6bj1vPWg9ZTsodD4+PTEpPjE7KXtjb25zdCBnPW4rcj4+MSxNPW8rbD4+MTt0JjE/KHI9bixsPW8sbj11LG89aCk6KG49cixvPWwscj11LGw9aCksdT1nLGg9TX1jb25zdCBhPXMqNDt0aGlzLmNvb3Jkc1thKzBdPW4sdGhpcy5jb29yZHNbYSsxXT1vLHRoaXMuY29vcmRzW2ErMl09cix0aGlzLmNvb3Jkc1thKzNdPWx9fWNyZWF0ZVRpbGUoaSl7cmV0dXJuIG5ldyBEKGksdGhpcyl9fWNsYXNzIER7bWFydGluaTt0ZXJyYWluO2Vycm9ycztjb25zdHJ1Y3RvcihpLGUpe2NvbnN0IHM9ZS5ncmlkU2l6ZTtpZihpLmxlbmd0aCE9PXMqcyl0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIHRlcnJhaW4gZGF0YSBvZiBsZW5ndGggJHtzKnN9ICgke3N9IHggJHtzfSksIGdvdCAke2kubGVuZ3RofS5gKTt0aGlzLnRlcnJhaW49aSx0aGlzLm1hcnRpbmk9ZSx0aGlzLmVycm9ycz1uZXcgRmxvYXQzMkFycmF5KGkubGVuZ3RoKSx0aGlzLnVwZGF0ZSgpfXVwZGF0ZSgpe2NvbnN0e251bVRyaWFuZ2xlczppLG51bVBhcmVudFRyaWFuZ2xlczplLGNvb3JkczpzLGdyaWRTaXplOnR9PXRoaXMubWFydGluaSx7dGVycmFpbjpuLGVycm9yczpvfT10aGlzO2ZvcihsZXQgcj1pLTE7cj49MDtyLS0pe2NvbnN0IGw9cio0LHU9c1tsKzBdLGg9c1tsKzFdLGE9c1tsKzJdLGc9c1tsKzNdLE09dSthPj4xLHg9aCtnPj4xLHY9TSt4LWgsRT14K3UtTSxTPShuW2gqdCt1XStuW2cqdCthXSkvMixkPXgqdCtNLG09TWF0aC5hYnMoUy1uW2RdKTtpZihvW2RdPU1hdGgubWF4KG9bZF0sbSkscjxlKXtjb25zdCB6PShoK0U+PjEpKnQrKHUrdj4+MSksQT0oZytFPj4xKSp0KyhhK3Y+PjEpO29bZF09TWF0aC5tYXgob1tkXSxvW3pdLG9bQV0pfX19Z2V0R2VvbWV0cnlEYXRhKGk9MCl7Y29uc3R7Z3JpZFNpemU6ZSxpbmRpY2VzOnN9PXRoaXMubWFydGluaSx7ZXJyb3JzOnR9PXRoaXM7bGV0IG49MCxvPTA7Y29uc3Qgcj1lLTE7bGV0IGwsdSxoPTA7cy5maWxsKDApO2Z1bmN0aW9uIGEoZCxtLHosQSxmLHkpe2NvbnN0IFQ9ZCt6Pj4xLHc9bStBPj4xO01hdGguYWJzKGQtZikrTWF0aC5hYnMobS15KT4xJiZ0W3cqZStUXT5pPyhhKGYseSxkLG0sVCx3KSxhKHosQSxmLHksVCx3KSk6KGw9bSplK2QsdT1BKmUreixoPXkqZStmLHNbbF09PT0wJiYoc1tsXT0rK24pLHNbdV09PT0wJiYoc1t1XT0rK24pLHNbaF09PT0wJiYoc1toXT0rK24pLG8rKyl9YSgwLDAscixyLHIsMCksYShyLHIsMCwwLDAscik7bGV0IGc9bioyLE09byozO2NvbnN0IHg9bmV3IFVpbnQxNkFycmF5KGcpLHY9bmV3IFVpbnQzMkFycmF5KE0pO2xldCBFPTA7ZnVuY3Rpb24gUyhkLG0seixBLGYseSl7Y29uc3QgVD1kK3o+PjEsdz1tK0E+PjE7aWYoTWF0aC5hYnMoZC1mKStNYXRoLmFicyhtLXkpPjEmJnRbdyplK1RdPmkpUyhmLHksZCxtLFQsdyksUyh6LEEsZix5LFQsdyk7ZWxzZXtjb25zdCBGPXNbbSplK2RdLTEscD1zW0EqZSt6XS0xLEM9c1t5KmUrZl0tMTt4WzIqRl09ZCx4WzIqRisxXT1tLHhbMipwXT16LHhbMipwKzFdPUEseFsyKkNdPWYseFsyKkMrMV09eSx2W0UrK109Rix2W0UrK109cCx2W0UrK109Q319cmV0dXJuIFMoMCwwLHIscixyLDApLFMocixyLDAsMCwwLHIpLHthdHRyaWJ1dGVzOnRoaXMuX2dldE1lc2hBdHRyaWJ1dGVzKHRoaXMudGVycmFpbix4LHYpLGluZGljZXM6dn19X2dldE1lc2hBdHRyaWJ1dGVzKGksZSxzKXtjb25zdCB0PU1hdGguZmxvb3IoTWF0aC5zcXJ0KGkubGVuZ3RoKSksbj10LTEsbz1lLmxlbmd0aC8yLHI9bmV3IEZsb2F0MzJBcnJheShvKjMpLGw9bmV3IEZsb2F0MzJBcnJheShvKjIpO2ZvcihsZXQgaD0wO2g8bztoKyspe2NvbnN0IGE9ZVtoKjJdLGc9ZVtoKjIrMV0sTT1nKnQrYTtyWzMqaCswXT1hL24tLjUsclszKmgrMV09LjUtZy9uLHJbMypoKzJdPWlbTV0sbFsyKmgrMF09YS9uLGxbMipoKzFdPTEtZy9ufWNvbnN0IHU9VShyLHMpO3JldHVybntwb3NpdGlvbjp7dmFsdWU6cixzaXplOjN9LHRleGNvb3JkOnt2YWx1ZTpsLHNpemU6Mn0sbm9ybWFsOnt2YWx1ZTp1LHNpemU6M319fX1jb25zdCBMPXswOjdlMywxOjZlMywyOjVlMywzOjRlMyw0OjNlMyw1OjI1MDAsNjoyZTMsNzoxNTAwLDg6ODAwLDk6NTAwLDEwOjIwMCwxMToxMDAsMTI6NDAsMTM6MTIsMTQ6NSwxNToyLDE2OjEsMTc6LjUsMTg6LjIsMTk6LjEsMjA6LjA1fTtmdW5jdGlvbiBWKGMsaSl7Y29uc3QgZT1iKGMpLHM9TWF0aC5mbG9vcihNYXRoLnNxcnQoZS5sZW5ndGgpKSxuPW5ldyBrKHMpLmNyZWF0ZVRpbGUoZSksbz1MW2ldLzFlM3x8MCxyPW4uZ2V0R2VvbWV0cnlEYXRhKG8pO3JldHVybiBPKHIuYXR0cmlidXRlcyxyLmluZGljZXMsMSl9ZnVuY3Rpb24gYihjKXtjb25zdCBpPWMuZGF0YSxlPWMud2lkdGgscz1lKzEsdD1uZXcgRmxvYXQzMkFycmF5KHMqcyk7Zm9yKGxldCBuPTAsbz0wO288ZTtvKyspZm9yKGxldCByPTA7cjxlO3IrKyxuKyspe2lbbio0KzNdPT09MCYmKHRbbitvXT0wKTtjb25zdCBsPW4qNCx1PWlbbCswXSxoPWlbbCsxXSxhPWlbbCsyXSxnPXU8PDE2fGg8PDh8YTt0W24rb109Zy8xZTQtMTB9Zm9yKGxldCBuPXMqKHMtMSksbz0wO288cy0xO28rKyxuKyspdFtuXT10W24tc107Zm9yKGxldCBuPXMtMSxvPTA7bzxzO28rKyxuKz1zKXRbbl09dFtuLTFdO3JldHVybiB0fXNlbGYub25tZXNzYWdlPWM9Pntjb25zdHtpbWdEYXRhOmksejplfT1jLmRhdGEscz1WKGksZSk7c2VsZi5wb3N0TWVzc2FnZShzKSxzZWxmLmNsb3NlKCl9fSkoKTsK",np=i=>Uint8Array.from(atob(i),A=>A.charCodeAt(0)),BI=typeof self<"u"&&self.Blob&&new Blob([np(AC)],{type:"text/javascript;charset=utf-8"});function sp(i){let A;try{if(A=BI&&(self.URL||self.webkitURL).createObjectURL(BI),!A)throw"";const e=new Worker(A,{name:i?.name});return e.addEventListener("error",()=>{(self.URL||self.webkitURL).revokeObjectURL(A)}),e}catch{return new Worker("data:text/javascript;base64,"+AC,{name:i?.name})}finally{A&&(self.URL||self.webkitURL).revokeObjectURL(A)}}class op{dataType="terrain-rgb-martini";discription="Mapbox-RGB + Martini geometry loader. Deprecated!";_useWorker=!0;get useWorker(){return this._useWorker}set useWorker(A){this._useWorker=A}imageLoader=new Sa(Ee.manager);load(A,e,t,n,s,o){const r=new qE,{url:a,bounds:g}=Ma(A,e,t,n);return a?this._load(a,e,t,n,r,g,s,o):s(),r}_load(A,e,t,n,s,o,r,a){return this.imageLoader.load(A,g=>{const I=ap(g,o);if(this.useWorker){const E=new sp;E.onmessage=C=>{s.setData(C.data),r()},E.postMessage({z:n,imgData:I},I)}else{const E=tp(I,n);s.setData(E),r()}},void 0,r,a),s}}function rp(i,A){const e=Math.floor(i[0]*A),t=Math.floor(i[1]*A),n=Math.floor((i[2]-i[0])*A),s=Math.floor((i[3]-i[1])*A);return{sx:e,sy:t,sw:n,sh:s}}function ap(i,A){const e=rp(A,i.width),t=Math.min(256,e.sw),n=new OffscreenCanvas(t,t).getContext("2d");return n.imageSmoothingEnabled=!1,n.drawImage(i,e.sx,e.sy,e.sw,e.sh,0,0,t,t),n.getImageData(0,0,t,t)}Ee.registerGeometryLoader(new op);new Mi;new Ht;new L;var gp=function(){return performance.now()},Ip=(function(){function i(){this._tweens={},this._tweensAddedDuringUpdate={}}return i.prototype.getAll=function(){var A=this;return Object.keys(this._tweens).map(function(e){return A._tweens[e]})},i.prototype.removeAll=function(){this._tweens={}},i.prototype.add=function(A){this._tweens[A.getId()]=A,this._tweensAddedDuringUpdate[A.getId()]=A},i.prototype.remove=function(A){delete this._tweens[A.getId()],delete this._tweensAddedDuringUpdate[A.getId()]},i.prototype.update=function(A,e){A===void 0&&(A=gp()),e===void 0&&(e=!1);var t=Object.keys(this._tweens);if(t.length===0)return!1;for(;t.length>0;){this._tweensAddedDuringUpdate={};for(var n=0;n<t.length;n++){var s=this._tweens[t[n]],o=!e;s&&s.update(A,o)===!1&&!e&&delete this._tweens[t[n]]}t=Object.keys(this._tweensAddedDuringUpdate)}return!0},i})(),Ep=new Ip,wt=Ep;wt.getAll.bind(wt);wt.removeAll.bind(wt);wt.add.bind(wt);wt.remove.bind(wt);wt.update.bind(wt);let G=1;const Xs=G++,Cp=G++,Qp=G++,eC=G++;G++;G++;G++;G++;const tC=G++,iC=G++,Na=G++;G++;G++;G++;const nC=G++;G++;const sC=G++,Bp=G++;G++;G++;const oC=G++,rC=G++,aC=G++,gC=G++;G++;const cp=G++,hp=G++;G++;const lp=G++;G++;const We=G++,en=G++;G++;const cI=G++,hI=G++,lI=G++,IC=G++,dp=G++,dI=G++,Ms=G++,Ns=G++,uI=G++,fI=G++,pI=G++,bn=G++,DI=G++,EC=G++,CC=G++,xs=G++,Yo=G++,up=G++,QC=G++,fp=G++,pp=G++,BC=G++,qo=G++,Wo=G++;G++;G++;G++;G++;G++;const cC=G++,pe=G++,Vr=G++,Dp=G++,Vo=G++;G++;const mp=G++,yp=G++,Pe=G++,zr=G++,mI=G++,hC=G++,lC=G++,dC=G++,uC=G++,yI=G++,fC=G++,Rp=G++,pC=G++,DC=G++,ks=G++,wp=G++,mC=G++,yC=G++;G++;G++;G++;G++;G++;const RI=G++;G++;G++;G++;G++;G++;G++;G++;const Sp=G++;G++;G++;G++;G++;G++;G++;G++;G++;G++;G++;G++;G++;const ce=G++,Mp=G++;G++;G++;G++;G++;G++;G++;G++;G++;G++;G++;G++;G++;G++;G++;G++;G++;G++;G++;G++;const Np=G++;G++;G++;G++;G++;G++;const Xr=G++;G++;const RC=G++,xp=G++;G++;G++;G++;G++;G++;G++;G++;G++;G++;const Fp=G++;G++;G++;const Lp=G++;G++;const Zr=G++,wC=G++,Un=G++,SC=G++,MC=G++,NC=G++,_p=G++,Up=G++;G++;G++;G++;const Gp=G++,vp=G++;G++;const jr=G++,Tp=G++,xC=G++,$r=G++,Aa=G++,Zs=G++;G++;G++;G++;G++;G++;G++;G++;G++;G++;G++;G++;G++;G++;G++;G++;G++;G++;G++;G++;G++;G++;G++;G++;class bp{constructor(){this.map=new Map}on(A,e=null,t=!1){if(!A)return console.error("Invalid event key",A),null;if(!e)return this.map.get(A);if(t){let n=this.map.get(A);n?typeof n=="function"?console.error("Invalid event type","multiFn=true",A):n.push(e):(n=[],this.map.set(A,n),n.push(e))}else{let n=this.map.get(A);n?typeof n=="function"?console.warn("Replace event",A):console.error("Invalid event type","multiFn=false",A):this.map.set(A,e)}return this.map.get(A)}fire(A,...e){const t=this.map.get(A);if(!t){this.map.size&&[...e];return}if(typeof t=="function")return t(...e);let n=[];return t.forEach(s=>n.push(s(...e))),n}tryFire(A,...e){return this.map.get(A)?this.fire(A,...e):void 0}off(A){this.map.delete(A)}clear(){this.map.clear()}}class kp{}class Hp{constructor(A,e={}){this.fileSize=0,this.downloadSize=0,this.status=0,this.splatData=null,this.watermarkData=null,this.dataSplatCount=0,this.watermarkCount=0,this.sh12Data=[],this.sh3Data=[],this.sh12Count=0,this.sh3Count=0,this.rowLength=0,this.modelSplatCount=-1,this.downloadSplatCount=0,this.renderSplatCount=0,this.header=null,this.dataShDegree=0,this.minX=1/0,this.maxX=-1/0,this.minY=1/0,this.maxY=-1/0,this.minZ=1/0,this.maxZ=-1/0,this.topY=0,this.currentRadius=0,this.maxRadius=0,this.textWatermarkVersion=0,this.lastTextWatermarkVersion=0,this.fetchLimit=0,this.opts={...A};const t=this;t.meta=e,e.autoCut&&(t.map=new Map),t.metaMatrix=e.transform?new UA().fromArray(e.transform):null,A.format||(A.url?.endsWith(".spx")?t.opts.format="spx":A.url?.endsWith(".splat")?t.opts.format="splat":A.url?.endsWith(".ply")?t.opts.format="ply":A.url?.endsWith(".spz")?t.opts.format="spz":console.error("unknown format!")),t.abortController=new AbortController}}var SA=(i=>(i[i.FetchReady=0]="FetchReady",i[i.Fetching=1]="Fetching",i[i.FetchDone=2]="FetchDone",i[i.FetchAborted=3]="FetchAborted",i[i.FetchFailed=4]="FetchFailed",i[i.Invalid=5]="Invalid",i))(SA||{});const FC="v1.6.0",Kt=navigator.userAgent.includes("Mobi"),Pp="QWERTYUIOPLKJHGFDSAZXCVBNM1234567890qwertyuioplkjhgfdsazxcvbnm`~!@#$%^&*()-_=+\\|]}[{'\";::,<.>//? 	",Op=Kt?600:300,Jp=Kt?2e3:300,qi=128,Kp=32,KA=32,Yp=20,qp=16,LC=64*1024,Wp=1024*1e4,Vp=10240*1e4,Hs=.28209479177387814,zp=0,Xp=20,xa=1,Kn=2,Fa=3,Zp=3141592653;function jp(i){let A=!1;const e=(Q,h,l)=>i.on(Q,h,l),t=(Q,...h)=>i.fire(Q,...h);e(mI,()=>t(pe).debugMode),e(cC,()=>A=!0);let n=0;(function Q(){n++,!A&&requestAnimationFrame(Q)})(),e(Xs,(Q,h=null,l=0)=>{const B=()=>{A||(l>0?!(n%l)&&Q(n):Q(n),h&&h()&&requestAnimationFrame(B))};B()}),e(Cp,(Q,h=null,l=20)=>{const B=()=>{A||(Q(),h&&h()&&setTimeout(B,l))};B()});let s=!1,o=0,r=0;e(pC,()=>{s=!0,t(pe).debugMode?((async()=>{const Q=document.querySelector("#gsviewer #progressBarWrap");if(Q){Q.style.display="block";const h=document.querySelector("#gsviewer #progressBar");h&&(h.style.width="0%")}})(),(async()=>document.querySelector("#gsviewer .logo")?.classList.add("loading"))()):parent?.onProgress&&parent.onProgress(.001,"0.001%")}),e(ks,Q=>{Q&&(o=Q),s=!1,Q!==void 0&&((async()=>{const h=document.querySelector("#gsviewer #progressBarWrap");h&&(h.style.display="none")})(),(async()=>document.querySelector("#gsviewer .logo")?.classList.remove("loading"))(),parent?.onProgress&&parent.onProgress(0,"100%",9))}),e(DC,Q=>{s=!0,t(pe).debugMode?(async()=>{const h=document.querySelector("#gsviewer #progressBar");h&&(h.style.width=`${Q}%`)})():parent?.onProgress&&parent.onProgress(Q,`${Q}%`)}),e(wp,()=>s),e(mC,Q=>{r=Q}),e(yC,()=>!s&&o&&r>=o),e(Vr,()=>{const Q=t(iC).parentElement.getBoundingClientRect();return{width:Q.width,height:Q.height,left:Q.left,top:Q.top}}),e(Rp,Q=>{let h=Q.x.toFixed(3).split("."),l=Q.y.toFixed(3).split("."),B=Q.z.toFixed(3).split(".");return(h[1]==="000"||h[1]==="00000")&&(h[1]="0"),(l[1]==="000"||l[1]==="00000")&&(l[1]="0"),(B[1]==="000"||B[1]==="00000")&&(B[1]="0"),`${h.join(".")}, ${l.join(".")}, ${B.join(".")}`}),e(cp,Q=>btoa(Q)),e(hp,Q=>atob(Q));const a=.001;let g=new L,I=new L,E=0;e(yp,()=>{const Q=t(Na),h=Q.fov,l=Q.position.clone(),B=Q.getWorldDirection(new L);return Math.abs(E-h)<a&&Math.abs(l.x-g.x)<a&&Math.abs(l.y-g.y)<a&&Math.abs(l.z-g.z)<a&&Math.abs(B.x-I.x)<a&&Math.abs(B.y-I.y)<a&&Math.abs(B.z-I.z)<a?!1:(E=h,g=l,I=B,!0)}),e(Xr,Q=>{if(!Q)return;const h=[];Q.traverse(l=>h.push(l)),h.forEach(l=>{l.dispose?l.dispose():(l.geometry?.dispose?.(),l.material&&l.material instanceof Array?l.material.forEach(B=>B?.dispose?.()):l.material?.dispose?.())}),Q.clear()}),e(We,async({renderSplatCount:Q,visibleSplatCount:h,modelSplatCount:l,fps:B,realFps:c,sortTime:R,fov:p,position:d,lookUp:w,lookAt:S,worker:F,scene:N,scale:u,cuts:f,shDegree:m}={})=>{if(!t(mI))return;m!==void 0&&C("shDegree",`${m}`),Q!==void 0&&C("renderSplatCount",`${Q}`),h!==void 0&&C("visibleSplatCount",`${h}`),l!==void 0&&C("modelSplatCount",`${l}`),B!==void 0&&C("fps",B),c!==void 0&&C("realFps",`raw ${c}`),R!==void 0&&C("sort",`${R} ms`),f!==void 0&&C("cuts",f===""?"":`（${f} cuts）`),F&&C("worker",`${F}`),N&&C("scene",N),p&&C("fov",p),d&&C("position",d),w&&C("lookUp",w),S&&C("lookAt",S),S&&C("viewer-version",FC);let T=performance.memory||{usedJSHeapSize:0,totalJSHeapSize:0,jsHeapSizeLimit:0},M="",_=T.usedJSHeapSize/1024/1024;_>1e3?M+=(_/1024).toFixed(2)+" G":M+=_.toFixed(0)+" M",M+=" / ";let P=T.totalJSHeapSize/1024/1024;P>1e3?M+=(P/1024).toFixed(2)+" G":M+=P.toFixed(0)+" M";let b=T.jsHeapSizeLimit/1024/1024;M+=" / ",b>1e3?M+=(b/1024).toFixed(2)+" G":M+=b.toFixed(0)+" M",C("memory",M),u&&C("scale",u)});async function C(Q,h){let l=document.querySelector(`#gsviewer .debug .${Q}`);l&&(l.innerText=h)}}function $p(i=0){const A=new Date;return A.setDate(A.getDate()-7),i>=A.getFullYear()*1e4+(A.getMonth()+1)*100+A.getDate()}async function _C(i){try{const A=new ReadableStream({async start(t){t.enqueue(i),t.close()}}),e=new Response(A.pipeThrough(new DecompressionStream("gzip")));return new Uint8Array(await e.arrayBuffer())}catch(A){return console.error("unGzip Failed:",A),null}}function Fe(i){return i<0?0:i>255?255:i|0}function Fs(i){const A=Fe(Math.round(i*128)+128);return Fe(Math.floor((A+4)/8)*8)}const La="AGFzbQEAAAAADwhkeWxpbmsuMAEEAAAAAAEeBmABfQF9YAAAYAF9AX9gAX8Bf2ACf38AYAJ/fwF/AhoCA2VudgRleHBmAAADZW52Bm1lbW9yeQIAAAMGBQECAwQFByEEEV9fd2FzbV9jYWxsX2N0b3JzAAEBSAADAXcABAFEAAUKigsFAwABC3IBBH8gALwiBEH///8DcSEBAkAgBEEXdkH/AXEiAkUNACACQfAATQRAIAFBgICABHJB8QAgAmt2IQEMAQsgAkGNAUsEQEGA+AEhA0EAIQEMAQsgAkEKdEGAgAdrIQMLIAMgBEEQdkGAgAJxciABQQ12cgsyAQJ/QcGmFiEBA0AgACACai0AACABQSFscyEBIAJBAWoiAkH8AEcNAAsgASAAKAJ8RwszACAAQQhBBCABQQFGG2pBADYCACAAQQA2ABwgAP0MAAABAIwRFgCVAWwS7YEyE/0LAgwLqQkDKH8OfQR8IAEoAgRBi/AJRgR/IAEoAgAiBEEASgRAIAFBCWoiAiAEQRNsaiEIIAIgBEESbGohCSACIARBEWxqIQogAiAEQQR0aiELIAIgBEEPbGohDCACIARBDmxqIQ0gAiAEQQ1saiEOIAIgBEEMbGohDyACIARBC2xqIRAgAiAEQQpsaiERIAIgBEEJbGohEiACIARBBmxqIRMgAiAEQQNsaiEUIAEtAAghFUEAIQIDQCACIAlqLQAAIQcgAiAKai0AACEWIAIgC2otAAAhFyACIAxqLQAAIRggAiANai0AACEZIAIgDmotAAAhGiACIA9qLQAAIRsgAiAQai0AACEcIAIgEWotAAAhHSACIBJqLQAAIR4gEyACQQNsIgNqIgUtAAAhHyADIBRqIgYtAAAhICABIANqIgMtAAohISADLQAJISIgBS0AASEjIAYtAAEhJCADLQALIiXAISYgBS0AAiInwCEoIAYtAAIiBsAhKUEAIQUgFQRAIAggAkEBdGoiAy0AASIFQQh0QYD+AXEgAy0AAHIgBUEJdEGAgARxciEFCyAes0MAAIA9lEMAACDBkhAAIS8gHbNDAACAPZRDAAAgwZIQACExIByzQwAAgD2UQwAAIMGSEAAhMkMAAAAAQwAAgD8gB7NDAAAAw5JDAAAAPJQiKiAqlCAXs0MAAADDkkMAAAA8lCIrICuUIBazQwAAAMOSQwAAADyUIiwgLJSSkpMiLZEgLUMAAAAAXRshLSAAIAJBBXRqIgMgIUEIdCAiciAlQRB0ciIHQYCAgHhyIAcgJkEASBuyQwAAgDmUOAIAIAMgBTYCDCADICNBCHQgH3IgJ0EQdHIiBUGAgIB4ciAFIChBAEgbskMAAIA5lDgCCCADICRBCHQgIHIgBkEQdHIiBUGAgIB4ciAFIClBAEgbskMAAIA5lDgCBCADICsgKiAqlCAsICyUIC0gLZQgKyArlJKSkpEiLpUiKyAqIC6VIiqUIjQgLSAulSIwICwgLpUiLJQiNZK7IjggOKAgMrsiOKK2Ii0gLZREAAAAAAAA8D8gLCAslCIyICogKpQiNpK7IjogOqChIC+7IjqitiIuIC6UICsgLJQiMyAwICqUIjeTuyI7IDugIDG7IjuitiIvIC+UkpJDAACAQJQQAiAtICwgKpQiMSAwICuUIjCTuyI5IDmgIDiitiIqlCAuIDMgN5K7IjkgOaAgOqK2IiyUIC9EAAAAAAAA8D8gKyArlCIzIDaSuyI5IDmgoSA7orYiK5SSkkMAAIBAlBACQRB0cjYCECADIC1EAAAAAAAA8D8gMyAykrsiOSA5oKEgOKK2Ii2UIC4gNCA1k7siOCA4oCA6orYiLpQgLyAxIDCSuyI4IDigIDuitiIvlJKSQwAAgECUEAIgKiAqlCAsICyUICsgK5SSkkMAAIBAlBACQRB0cjYCFCADIBpBCHQgG3IgGUEQdHIgGEEYdHI2AhwgAyAqIC2UICwgLpQgKyAvlJKSQwAAgECUEAIgLSAtlCAuIC6UIC8gL5SSkkMAAIBAlBACQRB0cjYCGCACQQFqIgIgBEcNAAsLQQAFQQELCw==",_a="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";async function A0(i){const A=new Uint32Array(i.buffer),e=new Float32Array(i.buffer),t=new kp;t.Fixed=String.fromCharCode(i[0])+String.fromCharCode(i[1])+String.fromCharCode(i[2]),t.Version=i[3],t.SplatCount=A[1],t.MinX=e[2],t.MaxX=e[3],t.MinY=e[4],t.MaxY=e[5],t.MinZ=e[6],t.MaxZ=e[7],t.MinTopY=e[8],t.MaxTopY=e[9],t.CreateDate=A[10],t.CreaterId=A[11],t.ExclusiveId=A[12],t.ShDegree=i[52],t.Flag1=i[53],t.Flag2=i[54],t.Flag3=i[55],t.Reserve1=A[14],t.Reserve2=A[15];let n="";for(let g=64;g<124;g++)n+=String.fromCharCode(i[g]);if(t.Comment=n.trim(),t.HashCheck=!0,t.Fixed!=="spx"&&t.Version!==1)return null;const s=t.CreaterId==1202056903?_a:La,o=WebAssembly.compile(Uint8Array.from(atob(s),g=>g.charCodeAt(0)).buffer),r=new WebAssembly.Memory({initial:1,maximum:1}),a=(await WebAssembly.instantiate(await o,{env:{memory:r,expf:oo}})).exports.H;return new Uint8Array(r.buffer).set(i,0),a(0)&&(t.HashCheck=!1),t}async function yt(i){const A=new Uint32Array(i.slice(0,8).buffer),e=A[0],t=A[1],n=xa==t,s=Kn==t,o=Fa==t,r=n||s||o,a=!r,g=t==20||r?_a:La,I=e*(r?qp:KA),E=WebAssembly.compile(Uint8Array.from(atob(g),B=>B.charCodeAt(0)).buffer),C=Math.floor((I+i.byteLength)/LC)+2,Q=new WebAssembly.Memory({initial:C,maximum:C}),h=(await WebAssembly.instantiate(await E,{env:{memory:Q,expf:oo}})).exports.D,l=new Uint8Array(Q.buffer);return l.set(i,I),h(0,I)?{splatCount:e,blockFormat:t,success:!1}:{splatCount:e,blockFormat:t,success:!0,datas:l.slice(0,I),isSplat:a,isSh:r,isSh1:n,isSh2:s,isSh3:o}}async function ea(i,A){const e=WebAssembly.compile(Uint8Array.from(atob(_a),a=>a.charCodeAt(0)).buffer),t=Math.floor(A*KA/LC)+2,n=new WebAssembly.Memory({initial:t,maximum:t}),s=(await WebAssembly.instantiate(await e,{env:{memory:n,expf:oo}})).exports.s,o=new Uint8Array(n.buffer);o.set(i.slice(0,A*KA),0);const r=s(0,A);return r?(console.error("splat data parser failed:",r),new Uint8Array(0)):o.slice(0,A*KA)}async function e0(i,A,e=!0,t=!0){const n=WebAssembly.compile(Uint8Array.from(atob(La),I=>I.charCodeAt(0)).buffer),s=new WebAssembly.Memory({initial:1,maximum:1}),o=(await WebAssembly.instantiate(await n,{env:{memory:s,expf:oo}})).exports.w,r=new Uint8Array(s.buffer),a=new Float32Array(r.buffer),g=t?-1:1;return a[0]=i,e?a[1]=g*A:a[2]=g*A,o(0,e?1:0),r.slice(0,KA)}function oo(i){return Math.exp(i)}const Mn=Kt?20480:51200;async function t0(i){try{i.status=SA.Fetching;const n=i.abortController.signal,s=i.opts.fetchReload?"reload":"default",o=await fetch(i.opts.url,{mode:"cors",credentials:"omit",cache:s,signal:n});if(o.status!=200){console.warn(`fetch error: ${o.status}`),i.status===SA.Fetching&&(i.status=SA.FetchFailed);return}const r=o.body.getReader(),a=parseInt(o.headers.get("content-length")||"0");i.fileSize=a,i.downloadSize=0,i.downloadSplatCount=0,i.watermarkData=new Uint8Array(0);let g=new Uint8Array(256),I=0,E=[],C;for(;;){let{done:Q,value:h}=await r.read();if(Q)break;if(i.downloadSize+=h.byteLength,E){if(E.push(h),i.downloadSize<200)continue;const l=new Uint8Array(i.downloadSize);for(let B=0,c=0;B<E.length;B++)l.set(E[B],c),c+=E[B].byteLength;if(C=t(l),!C){E=[l];continue}E=null,h=l.slice(C.headerLength),i.rowLength=C.rowLength,i.dataShDegree=C.shDegree,i.modelSplatCount=C.vertexCount,i.splatData=new Uint8Array(Math.min(i.modelSplatCount,i.fetchLimit)*32)}I+h.byteLength<i.rowLength?(g.set(h,I),I+=h.byteLength):(I=await A(C,i,I,g,h),I&&g.set(h.slice(h.byteLength-I),0)),i.downloadSplatCount>=i.fetchLimit&&i.abortController.abort()}}catch(n){n.name==="AbortError"?(i.opts.url,i.status===SA.Fetching&&(i.status=SA.FetchAborted)):(console.error(n),i.status===SA.Fetching&&(i.status=SA.FetchFailed))}finally{i.status===SA.Fetching&&(i.status=SA.FetchDone)}async function A(n,s,o,r,a){return new Promise(async g=>{let I=(o+a.byteLength)/s.rowLength|0,E=(o+a.byteLength)%s.rowLength,C;o?(C=new Uint8Array(I*s.rowLength),C.set(r.slice(0,o),0),C.set(a.slice(0,a.byteLength-E),o)):C=a.slice(0,I*s.rowLength),s.downloadSplatCount+I>s.fetchLimit&&(I=s.fetchLimit-s.downloadSplatCount,E=0);const Q=async()=>{if(I>Mn){const h=await e(n,C,Mn);wI(s,h),s.downloadSplatCount+=Mn,I-=Mn,C=C.slice(Mn*s.rowLength),setTimeout(Q)}else{const h=await e(n,C,I);wI(s,h),s.downloadSplatCount+=I,g(E)}};await Q()})}async function e(n,s,o){const r=new Uint8Array(o*Kp),a=new Float32Array(s.buffer),g=new Float32Array(r.buffer);for(let I=0;I<o;I++)g[I*8+0]=a[(I*i.rowLength+n.offsets.x)/4],g[I*8+1]=a[(I*i.rowLength+n.offsets.y)/4],g[I*8+2]=a[(I*i.rowLength+n.offsets.z)/4],g[I*8+3]=Math.exp(a[(I*i.rowLength+n.offsets.scale_0)/4]),g[I*8+4]=Math.exp(a[(I*i.rowLength+n.offsets.scale_1)/4]),g[I*8+5]=Math.exp(a[(I*i.rowLength+n.offsets.scale_2)/4]),r[I*32+24]=Fe((.5+Hs*a[(I*i.rowLength+n.offsets.f_dc_0)/4])*255),r[I*32+25]=Fe((.5+Hs*a[(I*i.rowLength+n.offsets.f_dc_1)/4])*255),r[I*32+26]=Fe((.5+Hs*a[(I*i.rowLength+n.offsets.f_dc_2)/4])*255),r[I*32+27]=Fe(1/(1+Math.exp(-a[(I*i.rowLength+n.offsets.opacity)/4]))*255),r[I*32+28]=Fe(a[(I*i.rowLength+n.offsets.rot_0)/4]*128+128),r[I*32+29]=Fe(a[(I*i.rowLength+n.offsets.rot_1)/4]*128+128),r[I*32+30]=Fe(a[(I*i.rowLength+n.offsets.rot_2)/4]*128+128),r[I*32+31]=Fe(a[(I*i.rowLength+n.offsets.rot_3)/4]*128+128);if(n.shDegree==3){const I=new Uint8Array(o*24+8),E=new Uint8Array(o*21+8),C=new Uint32Array(2);C[0]=o,C[1]=Kn,I.set(new Uint8Array(C.buffer),0);const Q=new Uint32Array(2);Q[0]=o,Q[1]=Fa,E.set(new Uint8Array(Q.buffer),0);for(let B=0,c=0;B<o;B++)for(let R=0;R<8;R++)for(let p=0;p<3;p++)I[8+c++]=Fs(a[(B*i.rowLength+n.offsets["f_rest_"+(R+p*15)])/4]);for(let B=0,c=0;B<o;B++)for(let R=8;R<15;R++)for(let p=0;p<3;p++)E[8+c++]=Fs(a[(B*i.rowLength+n.offsets["f_rest_"+(R+p*15)])/4]);const h=await yt(I);i.sh12Data.push(h.datas);const l=await yt(E);i.sh3Data.push(l.datas)}else if(n.shDegree==2){const I=new Uint8Array(o*24+8),E=new Uint32Array(2);E[0]=o,E[1]=Kn,I.set(new Uint8Array(E.buffer),0);for(let Q=0,h=0;Q<o;Q++)for(let l=0;l<8;l++)for(let B=0;B<3;B++)I[8+h++]=Fs(a[(Q*i.rowLength+n.offsets["f_rest_"+(l+B*8)])/4]);const C=await yt(I);i.sh12Data.push(C.datas)}else if(n.shDegree==1){const I=new Uint8Array(o*9+8),E=new Uint32Array(2);E[0]=o,E[1]=xa,I.set(new Uint8Array(E.buffer),0);for(let Q=0,h=0;Q<o;Q++)for(let l=0;l<3;l++)for(let B=0;B<3;B++)I[8+h++]=Fs(a[(Q*i.rowLength+n.offsets["f_rest_"+(l+B*3)])/4]);const C=await yt(I);i.sh12Data.push(C.datas)}return await ea(r,o)}function t(n){let s=new TextDecoder().decode(n.slice(0,2048));const o=`end_header
`,r=s.indexOf(o);if(r<0){if(n.byteLength>1024*2)throw new Error("Unable to read .ply file header");return null}if(!s.startsWith("ply")||s.indexOf("format binary_little_endian 1.0")<0)throw new Error("Unknow .ply file header");const a=parseInt(/element vertex (\d+)\n/.exec(s)[1]);let g=0,I={},E={};const C={double:"getFloat64",int:"getInt32",uint:"getUint32",float:"getFloat32",short:"getInt16",ushort:"getUint16",uchar:"getUint8"};for(let l of s.slice(0,r).split(`
`).filter(B=>B.startsWith("property "))){const[B,c,R]=l.split(" "),p=C[c]||"getInt8";E[R]=p,I[R]=g,g+=parseInt(p.replace(/[^\d]/g,""))/8}let Q=0;E.f_rest_44?Q=3:E.f_rest_23?Q=2:E.f_rest_8&&(Q=1);const h=["x","y","z","scale_0","scale_1","scale_2","f_dc_0","f_dc_1","f_dc_2","opacity","rot_0","rot_1","rot_2","rot_3"];for(let l=0;l<h.length;l++){const B=h[l];if(!E[B])throw new Error(`Property not found: ${B}`)}return{headerLength:r+o.length,offsets:I,rowLength:g,vertexCount:a,shDegree:Q}}}function wI(i,A){let e=A.byteLength/KA;const t=Math.min(i.fetchLimit,i.modelSplatCount);i.dataSplatCount+e>t?(e=t-i.dataSplatCount,i.splatData.set(A.slice(0,e*KA),i.dataSplatCount*KA)):i.splatData.set(A,i.dataSplatCount*KA);const n=new Float32Array(A.buffer);for(let o=0,r=0,a=0,g=0;o<e;o++)r=n[o*8],a=n[o*8+1],g=n[o*8+2],i.minX=Math.min(i.minX,r),i.maxX=Math.max(i.maxX,r),i.minY=Math.min(i.minY,a),i.maxY=Math.max(i.maxY,a),i.minZ=Math.min(i.minZ,g),i.maxZ=Math.max(i.maxZ,g);i.dataSplatCount+=e;const s=0;i.currentRadius=Math.sqrt(i.maxX*i.maxX+s*s+i.maxZ*i.maxZ),i.aabbCenter=new L((i.minX+i.maxX)/2,(i.minY+i.maxY)/2,(i.minZ+i.maxZ)/2),i.maxRadius=.5*Math.sqrt(Math.pow(i.maxX-i.minX,2)+Math.pow(i.maxY-i.minY,2)+Math.pow(i.maxZ-i.minZ,2)),i.metaMatrix&&i.aabbCenter.applyMatrix4(i.metaMatrix)}const Wi=Kt?20480:51200;async function i0(i){let A=0;try{i.status=SA.Fetching;const t=i.abortController.signal,n=i.opts.fetchReload?"reload":"default",s=await fetch(i.opts.url,{mode:"cors",credentials:"omit",cache:n,signal:t});if(s.status!=200){console.warn(`fetch error: ${s.status}`),i.status===SA.Fetching&&(i.status=SA.FetchFailed);return}const o=s.body.getReader(),r=parseInt(s.headers.get("content-length")||"0");i.rowLength=32,i.fileSize=r;const a=r/i.rowLength|0;if(a<1){console.warn("data empty",i.opts.url),i.status===SA.Fetching&&(i.status=SA.Invalid);return}i.modelSplatCount=a,i.downloadSplatCount=0,i.splatData=new Uint8Array(Math.min(i.modelSplatCount,i.fetchLimit)*32),i.watermarkData=new Uint8Array(0);let g=new Uint8Array(32),I=0;for(;;){let{done:E,value:C}=await o.read();if(E)break;I+C.byteLength<i.rowLength?(g.set(C,I),I+=C.byteLength,A+=C.length,i.downloadSize=A):(I=await e(i,I,g,C),I&&g.set(C.slice(C.byteLength-I),0)),i.downloadSplatCount>=i.fetchLimit&&i.abortController.abort()}}catch(t){t.name==="AbortError"?(i.opts.url,i.status===SA.Fetching&&(i.status=SA.FetchAborted)):(console.error(t),i.status===SA.Fetching&&(i.status=SA.FetchFailed))}finally{i.status===SA.Fetching&&(i.status=SA.FetchDone)}async function e(t,n,s,o){return new Promise(async r=>{let a=(n+o.byteLength)/t.rowLength|0,g=(n+o.byteLength)%t.rowLength,I;n?(I=new Uint8Array(a*t.rowLength),I.set(s.slice(0,n),0),I.set(o.slice(0,o.byteLength-g),n)):I=o.slice(0,a*t.rowLength),t.downloadSplatCount+a>t.fetchLimit&&(a=t.fetchLimit-t.downloadSplatCount,g=0);const E=async()=>{if(a>Wi){const C=await ea(I,Wi);SI(t,C),t.downloadSplatCount+=Wi,A+=Wi*t.rowLength,t.downloadSize=A,a-=Wi,I=I.slice(Wi*t.rowLength),setTimeout(E)}else{const C=await ea(I,a);SI(t,C),t.downloadSplatCount+=a,A+=a*t.rowLength,t.downloadSize=A,r(g)}};await E()})}}function SI(i,A){let e=A.byteLength/KA;const t=Math.min(i.fetchLimit,i.modelSplatCount);i.dataSplatCount+e>t?(e=t-i.dataSplatCount,i.splatData.set(A.slice(0,e*KA),i.dataSplatCount*KA)):i.splatData.set(A,i.dataSplatCount*KA);const n=new Float32Array(A.buffer);for(let o=0,r=0,a=0,g=0;o<e;o++)r=n[o*8],a=n[o*8+1],g=n[o*8+2],i.minX=Math.min(i.minX,r),i.maxX=Math.max(i.maxX,r),i.minY=Math.min(i.minY,a),i.maxY=Math.max(i.maxY,a),i.minZ=Math.min(i.minZ,g),i.maxZ=Math.max(i.maxZ,g);i.dataSplatCount+=e;const s=i.header?.MinTopY||0;i.currentRadius=Math.sqrt(i.maxX*i.maxX+s*s+i.maxZ*i.maxZ),i.aabbCenter=new L((i.minX+i.maxX)/2,(i.minY+i.maxY)/2,(i.minZ+i.maxZ)/2),i.maxRadius=.5*Math.sqrt(Math.pow(i.maxX-i.minX,2)+Math.pow(i.maxY-i.minY,2)+Math.pow(i.maxZ-i.minZ,2)),i.metaMatrix&&i.aabbCenter.applyMatrix4(i.metaMatrix)}const n0=[zp,Zp];async function s0(i){try{i.status=SA.Fetching;const A=i.abortController.signal,e=i.opts.fetchReload?"reload":"default",t=await fetch(i.opts.url,{mode:"cors",credentials:"omit",cache:e,signal:A});if(t.status!=200){console.warn(`fetch error: ${t.status}`),i.status===SA.Fetching&&(i.status=SA.FetchFailed);return}const n=t.body.getReader(),s=parseInt(t.headers.get("content-length")||"0");if(s-qi<Yp){console.warn("data empty",i.opts.url),i.status===SA.Fetching&&(i.status=SA.Invalid);return}i.fileSize=s;let o=[],r=new Uint8Array(qi),a=new Uint8Array(KA),g=0,I=!1,E=0,C=0,Q,h=!1;for(;;){let{done:l,value:B}=await n.read();if(l)break;if(i.downloadSize+=B.byteLength,o){o.push(B);let p=0;for(let S=0;S<o.length;S++)p+=o[S].byteLength;if(p<qi)continue;let d=0;for(let S=0;S<o.length;S++)d+o[S].byteLength<qi?(r.set(o[S],d),d+=o[S].byteLength):(r.set(o[S].slice(0,qi-d),d),B=new Uint8Array(o[S].slice(qi-d)));const w=await A0(r);if(!w){i.abortController.abort(),i.status===SA.Fetching&&(i.status=SA.Invalid),console.error("invalid spx format");continue}if(i.meta.autoCut>1&&!r0(w)){i.abortController.abort(),i.status===SA.Fetching&&(i.status=SA.Invalid),console.error("invalid LOD format");continue}if(i.header=w,i.modelSplatCount=w.SplatCount,i.dataShDegree=w.ShDegree,i.aabbCenter=new L((w.MinX+w.MaxX)/2,(w.MinY+w.MaxY)/2,(w.MinZ+w.MaxZ)/2),i.maxRadius=.5*Math.sqrt(Math.pow(w.MaxX-w.MinX,2)+Math.pow(w.MaxY-w.MinY,2)+Math.pow(w.MaxZ-w.MinZ,2)),i.metaMatrix&&i.aabbCenter.applyMatrix4(i.metaMatrix),o=null,r=null,!n0.includes(w.ExclusiveId)){i.abortController.abort(),i.status=SA.Invalid,console.error("Unrecognized format, creater id =",w.CreaterId,", exclusive id =",w.ExclusiveId,w.Comment);continue}}if(!I){if(g+B.byteLength<4){a.set(B,g),g+=B.byteLength;continue}const p=new Uint8Array(g+B.byteLength);p.set(a.slice(0,g),0),p.set(B,g),B=p.slice(4),g=0,I=!0,Q=[],C=0;const d=new Int32Array(p.slice(0,4).buffer);h=d[0]<0,E=Math.abs(d[0])}let c=C+B.byteLength;if(Q.push(B),c<E){C+=B.byteLength;continue}for(;c>=E;){let p=new Uint8Array(E),d=0;for(let S=0;S<Q.length;S++)d+Q[S].byteLength<E?(p.set(Q[S],d),d+=Q[S].byteLength):(p.set(Q[S].slice(0,E-d),d),B=new Uint8Array(Q[S].slice(E-d)));h&&(p=await _C(p));const w=await yt(p);if(!w.success){console.error("spx block data parser failed. block format:",w.blockFormat),i.abortController.abort(),i.status=SA.Invalid;break}if(w.isSplat)i.downloadSplatCount+=w.datas.byteLength/32,o0(i,w.datas);else{const S=Math.min(i.fetchLimit,i.modelSplatCount);if(w.isSh3)if(i.sh3Count+w.splatCount>S){const F=S-i.sh3Count;i.sh3Data.push(w.datas.slice(0,F*16)),i.sh3Count+=F}else i.sh3Data.push(w.datas),i.sh3Count+=w.splatCount;else if(i.sh12Count+w.splatCount>S){const F=S-i.sh12Count;i.sh12Data.push(w.datas.slice(0,F*16)),i.sh12Count+=F}else i.sh12Data.push(w.datas),i.sh12Count+=w.splatCount}if(B.byteLength<4){a.set(B,0),g=B.byteLength,I=!1;break}else{const S=new Int32Array(B.slice(0,4).buffer);E=Math.abs(S[0]),h=S[0]<0,B=B.slice(4),c=B.byteLength,Q=[B],C=B.byteLength}}const R=i.fetchLimit;i.header.ShDegree===3?i.downloadSplatCount>=R&&i.sh12Count>=R&&i.sh3Count>=R&&i.abortController.abort():i.header.ShDegree?i.downloadSplatCount>=R&&i.sh12Count>=R&&i.abortController.abort():i.downloadSplatCount>=R&&i.abortController.abort()}}catch(A){A.name==="AbortError"?(console.warn("Fetch Abort",i.opts.url),i.status===SA.Fetching&&(i.status=SA.FetchAborted)):(console.error(A),i.status===SA.Fetching&&(i.status=SA.FetchFailed),i.abortController.abort())}finally{i.status===SA.Fetching&&(i.status=SA.FetchDone)}}function o0(i,A){let e=!!i.meta.autoCut,t=A.byteLength/32;const n=4096;if(!e){const a=Math.min(i.fetchLimit,i.modelSplatCount);if(!i.splatData&&(i.splatData=new Uint8Array(a*KA)),!i.watermarkData&&(i.watermarkData=new Uint8Array(0)),i.dataSplatCount+t>a&&(t=a-i.dataSplatCount,!t))return;const g=new Float32Array(A.buffer),I=new Uint32Array(A.buffer);for(let C=0,Q=0,h=0,l=0;C<t;C++)if(Q=g[C*8],h=g[C*8+1],l=g[C*8+2],i.minX=Math.min(i.minX,Q),i.maxX=Math.max(i.maxX,Q),i.minY=Math.min(i.minY,h),i.maxY=Math.max(i.maxY,h),i.minZ=Math.min(i.minZ,l),i.maxZ=Math.max(i.maxZ,l),I[C*8+3]>>16){if(i.watermarkCount*KA===i.watermarkData.byteLength){const B=new Uint8Array((i.watermarkCount+n)*KA);B.set(i.watermarkData,0),i.watermarkData=B}i.watermarkData.set(A.slice(C*32,C*32+32),i.watermarkCount++*KA)}else i.splatData.set(A.slice(C*32,C*32+32),i.dataSplatCount++*KA);const E=i.header.MinTopY||0;i.currentRadius=Math.sqrt(i.maxX*i.maxX+E*E+i.maxZ*i.maxZ);return}let s=Math.min(Math.max(i.meta.autoCut,2),50);!i.watermarkData&&(i.watermarkData=new Uint8Array(0));const o=new Float32Array(A.buffer),r=new Uint32Array(A.buffer);for(let a=0,g=Math.floor(A.byteLength/KA),I=0,E=0,C=0,Q="";a<g;a++){if(r[a*8+3]>>16){if(i.watermarkCount*KA===i.watermarkData.byteLength){const c=new Uint8Array((i.watermarkCount+n)*KA);c.set(i.watermarkData,0),i.watermarkData=c}i.watermarkData.set(A.slice(a*32,a*32+32),i.watermarkCount++*KA);continue}I=o[a*8],E=o[a*8+1],C=o[a*8+2];let h=Math.min(s-1,Math.floor(Math.max(0,I-i.header.MinX)/(i.header.MaxX-i.header.MinX)*s)),l=Math.min(s-1,Math.floor(Math.max(0,C-i.header.MinZ)/(i.header.MaxZ-i.header.MinZ)*s));Q=`${h}-${l}`;let B=i.map.get(Q);if(!B)B={},B.minX=I,B.maxX=I,B.minY=E,B.maxY=E,B.minZ=C,B.maxZ=C,B.center=new L(I,E,C),i.metaMatrix&&B.center.applyMatrix4(i.metaMatrix),B.radius=0,B.splatData=new Uint8Array(n*KA),B.splatData.set(A.slice(a*KA,a*KA+KA),0),B.splatCount=1,i.map.set(Q,B);else{if(B.splatData.byteLength/KA==B.splatCount){const d=new Uint8Array(B.splatData.byteLength+n*KA);d.set(B.splatData,0),B.splatData=d}B.minX=Math.min(B.minX,I),B.maxX=Math.max(B.maxX,I),B.minY=Math.min(B.minY,E),B.maxY=Math.max(B.maxY,E),B.minZ=Math.min(B.minZ,C),B.maxZ=Math.max(B.maxZ,C),B.center=new L((B.maxX+B.minX)/2,(B.maxY+B.minY)/2,(B.maxZ+B.minZ)/2),i.metaMatrix&&B.center.applyMatrix4(i.metaMatrix);const c=B.maxX-B.minX,R=B.maxY-B.minY,p=B.maxZ-B.minZ;B.radius=Math.sqrt(c*c+R*R+p*p)/2,i.metaMatrix&&(B.radius*=i.metaMatrix.getMaxScaleOnAxis()),B.splatData.set(A.slice(a*KA,a*KA+KA),B.splatCount++*KA)}i.dataSplatCount++}}function r0(i){return((i?.Flag1||0)&128)>0}const jA=Kt?20480:51200,zo=16,MI=511;async function a0(i){try{i.status=SA.Fetching;const n=i.abortController.signal,s=i.opts.fetchReload?"reload":"default",o=await fetch(i.opts.url,{mode:"cors",credentials:"omit",cache:s,signal:n});if(o.status!=200){console.warn(`fetch error: ${o.status}`),i.status===SA.Fetching&&(i.status=SA.FetchFailed);return}const r=o.body.getReader(),a=parseInt(o.headers.get("content-length")||"0");i.fileSize=a,i.downloadSize=0,i.downloadSplatCount=0,i.watermarkData=new Uint8Array(0);const g=new Uint8Array(a);for(;;){let{done:C,value:Q}=await r.read();if(C)break;g.set(Q,i.downloadSize),i.downloadSize+=Q.length}const I=await _C(g);if(!I||I.length<16){console.error("Invalid spz format"),i.status=SA.Invalid;return}const E=t(I);i.spzVersion=E.version,i.modelSplatCount=E.numPoints,i.dataShDegree=E.shDegree,i.splatData=new Uint8Array(Math.min(i.modelSplatCount,i.fetchLimit)*32),await A(E,i,I)}catch(n){n.name==="AbortError"?(i.opts.url,i.status===SA.Fetching&&(i.status=SA.FetchAborted)):(console.error(n),i.status===SA.Fetching&&(i.status=SA.FetchFailed))}finally{i.status===SA.Fetching&&(i.status=SA.FetchDone)}async function A(n,s,o){const r=n.numPoints*9,a=n.numPoints,g=n.numPoints*3,I=n.numPoints*3,E=n.numPoints*(n.version==2?3:4),C=zo,Q=C+r,h=Q+a,l=h+g,B=l+I,c=B+E,R=Math.min(n.numPoints,s.fetchLimit),p=Math.ceil(R/jA);for(let d=0;d<p;d++){let w=d<p-1?jA:R-d*jA;s.dataSplatCount+w>s.fetchLimit&&(w=s.fetchLimit-s.dataSplatCount);const S=new Uint8Array(w*20+8),F=new Uint32Array(2);F[0]=w,F[1]=Xp,S.set(new Uint8Array(F.buffer),0);let N=8;for(let m=0;m<w;m++)S[N++]=o[C+(d*jA+m)*9+0],S[N++]=o[C+(d*jA+m)*9+1],S[N++]=o[C+(d*jA+m)*9+2];for(let m=0;m<w;m++)S[N++]=o[C+(d*jA+m)*9+3],S[N++]=o[C+(d*jA+m)*9+4],S[N++]=o[C+(d*jA+m)*9+5];for(let m=0;m<w;m++)S[N++]=o[C+(d*jA+m)*9+6],S[N++]=o[C+(d*jA+m)*9+7],S[N++]=o[C+(d*jA+m)*9+8];for(let m=0;m<w;m++)S[N++]=o[l+(d*jA+m)*3];for(let m=0;m<w;m++)S[N++]=o[l+(d*jA+m)*3+1];for(let m=0;m<w;m++)S[N++]=o[l+(d*jA+m)*3+2];for(let m=0;m<w;m++)S[N++]=Xo(o[h+(d*jA+m)*3]);for(let m=0;m<w;m++)S[N++]=Xo(o[h+(d*jA+m)*3+1]);for(let m=0;m<w;m++)S[N++]=Xo(o[h+(d*jA+m)*3+2]);const u=[];if(n.version==2)for(let m=0,T=0,M=0,_=0;m<w;m++)S[N++]=o[Q+(d*jA+m)],T=o[B+(d*jA+m)*3+0],M=o[B+(d*jA+m)*3+1],_=o[B+(d*jA+m)*3+2],u.push(g0(T,M,_));else for(let m=0,T=0,M=0,_=0,P=0;m<w;m++){S[N++]=o[Q+(d*jA+m)],T=o[B+(d*jA+m)*4+0],M=o[B+(d*jA+m)*4+1],_=o[B+(d*jA+m)*4+2],P=o[B+(d*jA+m)*4+3];const b=T|M<<8|_<<16|P<<24,z=b>>>30;let O=b,eA=0,oA=[];for(let gA=3;gA>=0;gA--)if(gA!==z){const pA=O&MI,qA=(O>>9&1)>0;oA[gA]=Math.SQRT1_2*(pA/MI),qA&&(oA[gA]=-oA[gA]),eA+=oA[gA]*oA[gA],O=O>>10}oA[z]=Math.sqrt(Math.max(1-eA,0));for(let gA=0;gA<4;gA++)oA[gA]=Fe(oA[gA]*128+128);u.push(oA)}for(let m=0;m<w;m++)S[N++]=u[m][0];for(let m=0;m<w;m++)S[N++]=u[m][1];for(let m=0;m<w;m++)S[N++]=u[m][2];for(let m=0;m<w;m++)S[N++]=u[m][3];const f=await yt(S);if(e(n,s,f.datas),n.shDegree===1){const m=new Uint8Array(w*9+8),T=new Uint32Array(2);T[0]=w,T[1]=xa,m.set(new Uint8Array(T.buffer),0);for(let _=0,P=8;_<w;_++)m.set(o.slice(c+(d*jA+_)*9,c+(d*jA+_)*9+9),P),P+=9;const M=await yt(m);s.sh12Data.push(M.datas)}else if(n.shDegree===2){const m=new Uint8Array(w*24+8),T=new Uint32Array(2);T[0]=w,T[1]=Kn,m.set(new Uint8Array(T.buffer),0);for(let _=0,P=8;_<w;_++)m.set(o.slice(c+(d*jA+_)*24,c+(d*jA+_)*24+24),P),P+=24;const M=await yt(m);s.sh12Data.push(M.datas)}else if(n.shDegree===3){const m=new Uint8Array(w*24+8),T=new Uint32Array(2);T[0]=w,T[1]=Kn,m.set(new Uint8Array(T.buffer),0);for(let z=0,O=8;z<w;z++)m.set(o.slice(c+(d*jA+z)*45,c+(d*jA+z)*45+24),O),O+=24;const M=await yt(m);s.sh12Data.push(M.datas);const _=new Uint8Array(w*21+8),P=new Uint32Array(2);P[0]=w,P[1]=Fa,_.set(new Uint8Array(P.buffer),0);for(let z=0,O=8;z<w;z++)_.set(o.slice(c+(d*jA+z)*45+24,c+(d*jA+z)*45+45),O),O+=21;const b=await yt(_);s.sh3Data.push(b.datas)}if(s.dataSplatCount>=s.fetchLimit)break}}function e(n,s,o){let r=o.byteLength/KA;const a=Math.min(s.fetchLimit,n.numPoints);s.dataSplatCount+r>a?(r=a-s.dataSplatCount,s.splatData.set(o.slice(0,r*KA),s.dataSplatCount*KA)):s.splatData.set(o,s.dataSplatCount*KA);const g=new Float32Array(o.buffer);for(let E=0,C=0,Q=0,h=0;E<r;E++)C=g[E*8],Q=g[E*8+1],h=g[E*8+2],s.minX=Math.min(s.minX,C),s.maxX=Math.max(s.maxX,C),s.minY=Math.min(s.minY,Q),s.maxY=Math.max(s.maxY,Q),s.minZ=Math.min(s.minZ,h),s.maxZ=Math.max(s.maxZ,h);s.dataSplatCount+=r,s.downloadSplatCount+=r;const I=0;s.currentRadius=Math.sqrt(s.maxX*s.maxX+I*I+s.maxZ*s.maxZ),s.aabbCenter=new L((s.minX+s.maxX)/2,(s.minY+s.maxY)/2,(s.minZ+s.maxZ)/2),s.maxRadius=.5*Math.sqrt(Math.pow(s.maxX-s.minX,2)+Math.pow(s.maxY-s.minY,2)+Math.pow(s.maxZ-s.minZ,2)),s.metaMatrix&&s.aabbCenter.applyMatrix4(s.metaMatrix)}function t(n){const s=n.slice(0,zo),o=new Uint32Array(s.buffer),r={};if(r.magic=o[0],r.version=o[1],r.numPoints=o[2],r.shDegree=s[12],r.fractionalBits=s[13],r.flags=s[14],r.reserved=s[15],r.magic!==1347635022)throw new Error("[SPZ ERROR] header not found");if(r.version<2||r.version>3)throw new Error("[SPZ ERROR] version not supported:"+r.version);if(r.shDegree>3)throw new Error("[SPZ ERROR] unsupported SH degree:"+r.shDegree);if(r.fractionalBits!==12)throw new Error("[SPZ ERROR] unsupported FractionalBits:"+r.fractionalBits);const a=r.version==2?19:20;let g=0;if(r.shDegree===1?g=9:r.shDegree===2?g=24:r.shDegree===3&&(g=45),n.length!==zo+r.numPoints*(a+g))throw new Error("[SPZ ERROR] invalid spz data");return r}}function Xo(i){const A=(i-127.5)/38.25;return Fe((.5+Hs*A)*255)}function g0(i,A,e){const t=i/127.5-1,n=A/127.5-1,s=e/127.5-1,o=Math.sqrt(Math.max(0,1-(t*t+n*n+s*s)));return[Fe(o*128+128),Fe(t*128+128),Fe(n*128+128),Fe(s*128+128)]}function I0(i){const A=(N,u,f)=>i.on(N,u,f),e=(N,...u)=>i.fire(N,...u);let t,n=Date.now()+36e5,s=null,o,r={index:0,version:0},a={index:1,version:0},g=!1;const I=e(Pe);let E=!1,C=0;A(Up,()=>o?.aabbCenter||new L);let Q;const h=new Promise(N=>Q=N);A(en,async()=>{const N=e(pe);let u=Kt?N.maxRenderCountOfMobile:N.maxRenderCountOfPc;if(!N.bigSceneMode){let f=await h;u=Math.min(f,u)+10240}return u}),A(Un,async N=>{const u=e(pe);if(u.bigSceneMode)return 1;let f=Kt?u.maxRenderCountOfMobile:u.maxRenderCountOfPc,m=await h;if(f=Math.min(m,f),!o.dataShDegree)return 1;if(N>=3){if(o.dataShDegree<3)return 1}else if(N>=1){if(o.dataShDegree<1)return 1}else return 1;const T=1024*2;return Math.ceil(f/T)}),A(NC,async()=>e(pe).bigSceneMode?0:(await h,o.dataShDegree)),A(xp,async(N,u=!0)=>{try{await h;const f=!!o.header?.Flag2;s=await e(RC,N,u,f),o&&(o.textWatermarkVersion=Date.now())}catch{console.info("failed to generate watermark")}}),A(wC,N=>{I&&(N?(!a.active&&(a.activeTime=Date.now()),a.active=!0):(!r.active&&(r.activeTime=Date.now()),r.active=!0))}),A(RI,()=>{if(I)return r.version<=a.version?r.xyz:a.xyz;if(o?.status===SA.FetchDone||o?.status===SA.FetchAborted){if(o.activePoints&&o.activePoints.length===void 0)return o.activePoints;const N={},u=r.xyz;for(let f=0,m=u.length/3,T=0,M=0,_=0,P="";f<m;f++)T=u[f*3],M=u[f*3+1],_=u[f*3+2],P=`${Math.floor(T/2)*2+1},${Math.floor(M/2)*2+1},${Math.floor(_/2)*2+1}`,(N[P]=N[P]||[]).push(T,M,_);return o.activePoints=N}return r.xyz});async function l(N){if(t)return;if(o&&(o.status===SA.Invalid||o.status===SA.FetchFailed))return e(pe).viewerEvents?.fire(lp),e(ks,0)||e(We,{renderSplatCount:0,visibleSplatCount:0,modelSplatCount:0});if(!o||!o.downloadSize)return;const u=o.status!==SA.FetchReady&&o.status!==SA.Fetching;if(d(u),u){const f=Math.min(o.fetchLimit,o.downloadSplatCount);!o.notifyFetchStopDone&&(o.notifyFetchStopDone=!0)&&e(ks,f)}else e(DC,100*o.downloadSize/o.fileSize);o.downloadSplatCount&&(g||(g=!0,setTimeout(async()=>{N?await c(u):await B(u),g=!1})))}async function B(N){if(t)return;const u=r,f=await e(en),m=s;let T=o.dataSplatCount,M=N?o.watermarkCount:0,_=o.meta.showWatermark&&N?(m?.byteLength||0)/32:0;if(o.renderSplatCount=T+M+_,o.renderSplatCount>=f&&(o.renderSplatCount=f,M=0,_=0,T>f&&(T=f)),e(We,{visibleSplatCount:o.renderSplatCount,modelSplatCount:o.modelSplatCount+_}),Date.now()-u.textureReadyTime<Op||o.smallSceneUploadDone&&o.lastTextWatermarkVersion==o.textWatermarkVersion)return;if(!u.version){e(CC,(o.header?.Flag2?o.header.MaxTopY:o.header?.MinTopY)||0);let pA=o.opts.format;o.opts.format=="spx"?pA="spx"+(o.header.ExclusiveId?(" "+o.header.ExclusiveId).substring(0,6):""):o.opts.format=="spz"&&(pA="spz v"+o.spzVersion),e(We,{scene:`small (${pA})`})}o.lastTextWatermarkVersion=o.textWatermarkVersion,u.textureReady=!1;const P=1024*2,b=Math.ceil(2*f/P),z=new Uint32Array(P*b*4),O=new Float32Array(z.buffer),eA=new Uint8Array(z.buffer);eA.set(o.splatData.slice(0,T*32),0),M&&eA.set(o.watermarkData.slice(0,M*32),T*32),_&&eA.set(m.slice(0,_*32),(T+M)*32);const oA=new Float32Array(o.renderSplatCount*3);for(let pA=0,qA=0;pA<o.renderSplatCount;pA++)oA[pA*3]=O[pA*8],oA[pA*3+1]=O[pA*8+1],oA[pA*3+2]=O[pA*8+2];const gA=Date.now();if(u.version=gA,u.txdata=z,u.xyz=oA,u.renderSplatCount=o.renderSplatCount,u.visibleSplatCount=o.downloadSplatCount+_,u.modelSplatCount=o.downloadSplatCount+_,u.watermarkCount=M+_,u.minX=o.minX,u.maxX=o.maxX,u.minY=o.minY,u.maxY=o.maxY,u.minZ=o.minZ,u.maxZ=o.maxZ,o.meta.particleMode&&!C&&(C=performance.now(),e($r,C),e(bn,!1),e(Zs,1)),o.maxRadius&&e(xC,o.maxRadius),e(Zr,u,o.currentRadius,o.currentRadius),n=gA,N&&!o.smallSceneUploadDone){o.smallSceneUploadDone=!0,e(SC,o.sh12Data),e(MC,o.sh3Data),o.sh12Data=null,o.sh3Data=null;const pA=e(pe);e(BC,pA.shDegree===void 0?3:pA.shDegree),e(RI),o.meta.particleMode&&setTimeout(()=>{e($r,performance.now()+5e3),e(Zs,2),setTimeout(()=>e(Aa,!0),5e3)},Math.max(5e3+C-performance.now(),0))}e(We,{renderSplatCount:o.renderSplatCount})}async function c(N){if(t)return;const u=await e(en),f=1024*2,m=Math.ceil(2*u/f),T=s,M=0,_=(T?.byteLength||0)/32,P=u-M-_;e(We,{modelSplatCount:o.downloadSplatCount+_});let b=r.version<=a.version?r:a;if(r.version&&(!b.index&&!a.active||b.index&&!r.active)||Date.now()-b.activeTime<Jp)return;if(N){const EA=e(pe).viewerEvents;if(EA&&!EA.fire(mp))return}if(!b.version){let EA=o.opts.format;o.opts.format=="spx"&&(EA="spx"+(o.header.ExclusiveId?(" "+o.header.ExclusiveId).substring(0,6):"")),e(We,{scene:`large (${EA})`})}const z=Date.now();b.version=z,b.active=!1;let O=0;const eA=[],oA=e(rC),gA=e(sC),pA=e(nC);for(const EA of o.map.values())p(oA,gA,pA,EA)&&(eA.push(EA),EA.currentRenderCnt=EA.splatCount,O+=EA.splatCount);e(We,{cuts:`${eA.length} / ${o.map.size}`});const qA=Math.min(P/O,1);if(qA>.95)for(const EA of eA)EA.currentRenderCnt=EA.splatCount*qA|0;else{eA.sort((xA,yA)=>xA.distance-yA.distance);for(const xA of eA)xA.distance<5?xA.distance*=.5:xA.distance<4?xA.distance*=.4:xA.distance<3?xA.distance*=.3:xA.distance<2&&(xA.distance*=.1);R(eA,P);let EA=0;for(let xA of eA)EA+=xA.currentRenderCnt;if(EA>P){let xA=EA-P;for(let yA=eA.length-1;yA>=0&&!(xA<=0);yA--){const WA=eA[yA];WA.currentRenderCnt>=xA?(WA.currentRenderCnt-=xA,xA=0):(xA-=WA.currentRenderCnt,WA.currentRenderCnt=0)}}else if(EA<P){let xA=P-EA;for(let yA=0;yA<eA.length&&!(xA<=0);yA++){let WA=eA[yA];if(WA.splatCount>WA.currentRenderCnt)if(WA.splatCount-WA.currentRenderCnt>=xA)WA.currentRenderCnt+=xA,xA=0;else{const U=WA.splatCount-WA.currentRenderCnt;WA.currentRenderCnt+=U,xA-=U}}}}const X=new Uint32Array(f*m*4),AA=new Float32Array(X.buffer),hA=new Uint8Array(X.buffer);let rA=0;for(let EA of eA)hA.set(EA.splatData.slice(0,EA.currentRenderCnt*32),rA*32),rA+=EA.currentRenderCnt;_&&hA.set(T.slice(0,_*32),(rA+M)*32);const mA=rA+M+_,LA=new Float32Array(mA*3);for(let EA=0,xA=0;EA<mA;EA++)LA[EA*3]=AA[EA*8],LA[EA*3+1]=AA[EA*8+1],LA[EA*3+2]=AA[EA*8+2];b.txdata=X,b.xyz=LA,b.renderSplatCount=mA,b.visibleSplatCount=O+o.watermarkCount+_,b.modelSplatCount=o.downloadSplatCount+_,b.watermarkCount=M+_,b.minX=o.header.MinX,b.maxX=o.header.MaxX,b.minY=o.header.MinY,b.maxY=o.header.MaxY,b.minZ=o.header.MinZ,b.maxZ=o.header.MaxZ,e(Zr,b),n=z,e(We,{visibleSplatCount:b.visibleSplatCount,modelSplatCount:b.modelSplatCount})}function R(N,u){const f=N.map(M=>1/(M.distance+1e-6)),m=f.reduce((M,_)=>M+_,0);let T=0;if(N.forEach((M,_)=>{M.currentRenderCnt=Math.min(Math.floor(f[_]/m*u),M.splatCount),T+=M.currentRenderCnt}),T<u){const M=u-T,_=N.map((b,z)=>b.currentRenderCnt<b.splatCount?f[z]:0),P=_.reduce((b,z)=>b+z,0);N.forEach((b,z)=>{if(P>0&&b.currentRenderCnt<b.splatCount){const O=Math.min(Math.floor(_[z]/P*M),b.splatCount-b.currentRenderCnt);b.currentRenderCnt+=O}})}}function p(N,u,f,m){if(m.distance=Math.max(m.center.distanceTo(u)-m.radius,0),!m.distance||m.center.distanceTo(f)<=2*m.radius)return!0;const T=new YA(m.center.x,m.center.y,m.center.z,1).applyMatrix4(N),M=3*T.w;return!(T.z<-M||T.x<-M||T.x>M||T.y<-M||T.y>M)}function d(N){if(!E){if(o.header){E=!0;const u=new L(o.header.MinX,o.header.MinY,o.header.MinZ),f=new L(o.header.MaxX,o.header.MaxY,o.header.MaxZ);e(jr,u.x,u.y,u.z,f.x,f.y,f.z,o.meta.showBoundBox)}else if(N){E=!0;const u=new L(o.minX,o.minY,o.minZ),f=new L(o.maxX,o.maxY,o.maxZ);e(jr,u.x,u.y,u.z,f.x,f.y,f.z,o.meta.showBoundBox)}}}function w(){t||(t=!0,o?.abortController?.abort(),o?.map?.clear(),o=null,s=null,r=null,a=null)}function S(N){if(N.opts.format==="spx")s0(N);else if(N.opts.format==="splat")i0(N);else if(N.opts.format==="ply")t0(N);else if(N.opts.format==="spz")a0(N);else return!1;return!0}async function F(N,u){if(t)return;const f=e(pe),m=Kt?f.maxRenderCountOfMobile:f.maxRenderCountOfPc,T=e(Pe);if(N.fetchReload=$p(u.updateDate||0),o=new Hp(N,u),T&&u.autoCut){const P=u.pcDownloadLimitSplatCount||Vp,b=u.mobileDownloadLimitSplatCount||Wp,z=Kt?b:P;o.fetchLimit=Math.min(u.autoCut*u.autoCut*m+m,z)}else o.fetchLimit=m;const M=Date.now(),_=()=>{if(!o||o.status==SA.Invalid||o.status==SA.FetchFailed)return Q(0);if(o.modelSplatCount>=0)Q(o.modelSplatCount),!o.meta.particleMode&&setTimeout(()=>e(fC),5);else{if(Date.now()-M>=3e3)return Q(0);setTimeout(_,10)}};if(_(),!S(o)){console.error("Unsupported format:",N.format),e(ks,0);return}e(pC),e(We,{cuts:""})}A(hC,async(N,u)=>await F(N,u)),A(lC,(N=1e4)=>Date.now()-n<N),A(dC,()=>w()),e(Xs,async()=>await l(I),()=>!t)}const NI="currentVisibleRadius",xI="currentLightRadius",Zo="splatShTexture12",jo="splatShTexture3",FI="performanceNow",$o="performanceAct",E0="waterMarkColor",LI="showWaterMark",Ar="splatTexture0",er="splatTexture1",_I="particleMode",UI="bigSceneMode",GI="lightFactor",vI="debugEffect",TI="usingIndex",C0="splatIndex",bI="maxRadius",kI="flagValue",HI="pointMode",PI="markPoint",OI="shDegree",JI="viewport",KI="focal",YI="topY";let se=0;se++;const qI=`$${se++}`;se++;se++;se++;const WI=`$${se++}`,Q0=`$${se++}`,VI=`$${se++}`,B0=`$${se++}`,c0=`$${se++}`,h0=`$${se++}`,l0=`$${se++}`,d0=`$${se++}`;se++;const u0=`$${se++}`,f0=`$${se++}`;se++;const p0=`$${se++}`;se++;const D0=`$${se++}`;se++;const m0=`$${se++}`,y0=`$${se++}`,R0=`$${se++}`,w0=`$${se++}`,S0=`$${se++}`,M0=`$${se++}`,N0=`$${se++}`,x0=`$${se++}`;se++;var F0=`precision highp float;\r
precision highp int;

uniform highp usampler2D splatTexture0, splatTexture1, splatShTexture12, splatShTexture3;\r
uniform vec2 focal, viewport;\r
uniform int usingIndex, shDegree, particleMode;\r
uniform bool pointMode, bigSceneMode, showWaterMark, debugEffect;\r
uniform float topY, maxRadius, currentVisibleRadius, currentLightRadius, performanceNow, performanceAct;\r
uniform vec4 markPoint, waterMarkColor;\r
uniform uint flagValue;

attribute uint splatIndex;

varying vec4 vColor;\r
varying vec3 vPosition;\r
vec3 animateParticle(vec3 v3Cen) {\r
    if (particleMode < 1)\r
        return v3Cen;\r
    float factor = particleMode > 1 ? ((performanceAct - performanceNow) / 5000.0) : ((performanceNow - performanceAct) / 5000.0);\r
    float radius = particleMode > 1 ? (max(currentVisibleRadius, maxRadius) * 0.6 * min((performanceNow) / 3000.0, 1.0)) : (max(currentVisibleRadius, maxRadius) * 0.6 * min((performanceNow - performanceAct) / 3000.0, 1.0));\r
    if (factor <= 0.0)\r
        return v3Cen;

    
    vec3 randSeed = fract(sin(vec3(dot(v3Cen, vec3(12.9898, 78.233, 37.719)), dot(v3Cen.yzx, vec3(49.123, 23.456, 87.654)), dot(v3Cen.zxy, vec3(34.567, 91.234, 56.789))))) * 2.0 - 1.0;

    
    float phase = factor * 12.0 + v3Cen.y * (15.0 + randSeed.x * 3.0) + v3Cen.z * (13.0 + randSeed.y * 2.0);

    
    float wave1 = sin(phase * (2.0 + randSeed.y * 1.5 + randSeed.z * 1.5));\r
    float wave2 = cos(phase * (1.2 + randSeed.x * 0.3) + v3Cen.x * 20.0);\r
    float dynamicFactor = mix(wave1, wave2, 0.5 + randSeed.z * 0.2) * 0.5 + 0.5;

    
    float amplitude = radius * 0.25 * factor * (0.9 + randSeed.z * 0.2);

    
    vec3 offset = vec3(amplitude * (dynamicFactor * 2.0 - 1.0), amplitude * randSeed.x * 5.0, amplitude * randSeed.y * 2.5);

    
    vec3 newPos = v3Cen + offset;\r
    float newDist = length(newPos);\r
    if (newDist > radius) {\r
        vec3 dir = normalize(newPos);\r
        float penetration = newDist - radius;\r
        float elasticity = 0.7 + randSeed.z * 0.2;

        
        vec3 bounceVec = dir * penetration * elasticity;\r
        vec3 tangent = normalize(cross(dir, vec3(randSeed.x, randSeed.y, 1.0)));\r
        newPos -= bounceVec - tangent * (length(randSeed.xy) * penetration * 0.2);\r
    }

    
    return normalize(newPos) * min(length(newPos), radius);\r
}\r
const float FactorSH = 0.0625;\r
const uint MaskSH = 0x1Fu;\r
const float SH_C1 = 0.4886025119029199;\r
const float[5] SH_C2 = float[](1.0925484305920792, -1.0925484305920792, 0.31539156525252005, -1.0925484305920792, 0.5462742152960396);\r
const float[7] SH_C3 = float[](-0.5900435899266435, 2.890611442640554, -0.4570457994644658, 0.3731763325901154, -0.4570457994644658, 1.445305721320277, -0.5900435899266435);

vec3[15] splatReadShDatas() {\r
    int shCnt = 0;\r
    float[45] fSHs;\r
    uvec4 rgb12 = texelFetch(splatShTexture12, ivec2((splatIndex & 0x7ffu), (splatIndex >> 11)), 0);\r
    if (rgb12.a > 0u) {\r
        shCnt = 3;\r
        fSHs[0] = float((rgb12.r >> 27) & MaskSH) * FactorSH - 1.0;\r
        fSHs[1] = float((rgb12.r >> 22) & MaskSH) * FactorSH - 1.0;\r
        fSHs[2] = float((rgb12.r >> 17) & MaskSH) * FactorSH - 1.0;\r
        fSHs[3] = float((rgb12.r >> 12) & MaskSH) * FactorSH - 1.0;\r
        fSHs[4] = float((rgb12.r >> 7) & MaskSH) * FactorSH - 1.0;\r
        fSHs[5] = float((rgb12.r >> 2) & MaskSH) * FactorSH - 1.0;\r
        fSHs[6] = float(((rgb12.r << 3) | (rgb12.g >> 29)) & MaskSH) * FactorSH - 1.0;\r
        fSHs[7] = float((rgb12.g >> 24) & MaskSH) * FactorSH - 1.0;\r
        fSHs[8] = float((rgb12.g >> 19) & MaskSH) * FactorSH - 1.0;

        if (shDegree > 1) {\r
            shCnt = 8;\r
            fSHs[9] = float((rgb12.g >> 14) & MaskSH) * FactorSH - 1.0;\r
            fSHs[10] = float((rgb12.g >> 9) & MaskSH) * FactorSH - 1.0;\r
            fSHs[11] = float((rgb12.g >> 4) & MaskSH) * FactorSH - 1.0;\r
            fSHs[12] = float(((rgb12.g << 1) | (rgb12.b >> 31)) & MaskSH) * FactorSH - 1.0;\r
            fSHs[13] = float((rgb12.b >> 26) & MaskSH) * FactorSH - 1.0;\r
            fSHs[14] = float((rgb12.b >> 21) & MaskSH) * FactorSH - 1.0;\r
            fSHs[15] = float((rgb12.b >> 16) & MaskSH) * FactorSH - 1.0;\r
            fSHs[16] = float((rgb12.b >> 11) & MaskSH) * FactorSH - 1.0;\r
            fSHs[17] = float((rgb12.b >> 6) & MaskSH) * FactorSH - 1.0;\r
            fSHs[18] = float((rgb12.b >> 1) & MaskSH) * FactorSH - 1.0;\r
            fSHs[19] = float(((rgb12.b << 4) | (rgb12.a >> 28)) & MaskSH) * FactorSH - 1.0;\r
            fSHs[20] = float(((rgb12.a >> 23) & MaskSH)) * FactorSH - 1.0;\r
            fSHs[21] = float((rgb12.a >> 18) & MaskSH) * FactorSH - 1.0;\r
            fSHs[22] = float((rgb12.a >> 13) & MaskSH) * FactorSH - 1.0;\r
            fSHs[23] = float((rgb12.a >> 8) & MaskSH) * FactorSH - 1.0;

            if (shDegree > 2) {\r
                uvec4 rgb3 = texelFetch(splatShTexture3, ivec2(splatIndex & 0x7ffu, splatIndex >> 11), 0);\r
                if (rgb3.a > 0u) {\r
                    shCnt = 15;\r
                    fSHs[24] = float((rgb3.r >> 27) & MaskSH) * FactorSH - 1.0;\r
                    fSHs[25] = float((rgb3.r >> 22) & MaskSH) * FactorSH - 1.0;\r
                    fSHs[26] = float((rgb3.r >> 17) & MaskSH) * FactorSH - 1.0;\r
                    fSHs[27] = float((rgb3.r >> 12) & MaskSH) * FactorSH - 1.0;\r
                    fSHs[28] = float((rgb3.r >> 7) & MaskSH) * FactorSH - 1.0;\r
                    fSHs[29] = float((rgb3.r >> 2) & MaskSH) * FactorSH - 1.0;\r
                    fSHs[30] = float(((rgb3.r << 3) | (rgb3.g >> 29)) & MaskSH) * FactorSH - 1.0;\r
                    fSHs[31] = float((rgb3.g >> 24) & MaskSH) * FactorSH - 1.0;\r
                    fSHs[32] = float((rgb3.g >> 19) & MaskSH) * FactorSH - 1.0;\r
                    fSHs[33] = float((rgb3.g >> 14) & MaskSH) * FactorSH - 1.0;\r
                    fSHs[34] = float((rgb3.g >> 9) & MaskSH) * FactorSH - 1.0;\r
                    fSHs[35] = float((rgb3.g >> 4) & MaskSH) * FactorSH - 1.0;\r
                    fSHs[36] = float(((rgb3.g << 1) | (rgb3.b >> 31)) & MaskSH) * FactorSH - 1.0;\r
                    fSHs[37] = float((rgb3.b >> 26) & MaskSH) * FactorSH - 1.0;\r
                    fSHs[38] = float((rgb3.b >> 21) & MaskSH) * FactorSH - 1.0;\r
                    fSHs[39] = float((rgb3.b >> 16) & MaskSH) * FactorSH - 1.0;\r
                    fSHs[40] = float((rgb3.b >> 11) & MaskSH) * FactorSH - 1.0;\r
                    fSHs[41] = float((rgb3.b >> 6) & MaskSH) * FactorSH - 1.0;\r
                    fSHs[42] = float((rgb3.b >> 1) & MaskSH) * FactorSH - 1.0;\r
                    fSHs[43] = float(((rgb3.b << 4) | (rgb3.a >> 28)) & MaskSH) * FactorSH - 1.0;\r
                    fSHs[44] = float((rgb3.a >> 23) & MaskSH) * FactorSH - 1.0;\r
                }\r
            }\r
        }\r
    }

    vec3[15] sh;\r
    for (int i = 0; i < 15; ++i) {\r
        sh[i] = i < shCnt ? vec3(fSHs[i * 3], fSHs[i * 3 + 1], fSHs[i * 3 + 2]) : vec3(0.0);\r
    }\r
    return sh;\r
}

vec3 splatEvalSH(in vec3 v3Cen) {\r
    vec3 dir = normalize(v3Cen - cameraPosition);\r
    float x = dir.x;\r
    float y = dir.y;\r
    float z = dir.z;

    vec3[15] sh = splatReadShDatas();\r
    vec3 result = SH_C1 * (-sh[0] * y + sh[1] * z - sh[2] * x);

    if (shDegree > 1) {\r
        float xx = x * x;\r
        float yy = y * y;\r
        float zz = z * z;\r
        float xy = x * y;\r
        float yz = y * z;\r
        float xz = x * z;

        result += sh[3] * (SH_C2[0] * xy) +\r
            sh[4] * (SH_C2[1] * yz) +\r
            sh[5] * (SH_C2[2] * (2.0 * zz - xx - yy)) +\r
            sh[6] * (SH_C2[3] * xz) +\r
            sh[7] * (SH_C2[4] * (xx - yy));

        if (shDegree > 2) {\r
            result += sh[8] * (SH_C3[0] * y * (3.0 * xx - yy)) +\r
                sh[9] * (SH_C3[1] * xy * z) +\r
                sh[10] * (SH_C3[2] * y * (4.0 * zz - xx - yy)) +\r
                sh[11] * (SH_C3[3] * z * (2.0 * zz - 3.0 * xx - 3.0 * yy)) +\r
                sh[12] * (SH_C3[4] * x * (4.0 * zz - xx - yy)) +\r
                sh[13] * (SH_C3[5] * z * (xx - yy)) +\r
                sh[14] * (SH_C3[6] * x * (xx - 3.0 * yy));\r
        }\r
    }\r
    return result;\r
}\r
float getFvAlpha(uvec4 cen) {\r
    uint fvSplat = cen.w & 65535u;\r
    uint fvHide = flagValue >> 16u;\r
    uint fvShow = flagValue & 65535u;\r
    float fvAlpha = 1.0;\r
    if (fvSplat > 0u) {\r
        if (fvSplat == fvShow) {\r
            fvAlpha = clamp((performanceNow - performanceAct) / 2000.0, 0.0, 1.0);\r
        } else if (fvSplat == fvHide) {\r
            fvAlpha = 1.0 - clamp((performanceNow - performanceAct) / 2000.0, 0.0, 1.0);\r
        } else {\r
            gl_Position = vec4(0.0, 0.0, 2.0, 1.0);\r
            fvAlpha = 0.0;\r
        }\r
    }\r
    return fvAlpha;\r
}

void main() {\r
    uvec4 cen, cov3d;\r
    if (bigSceneMode) {\r
        if (usingIndex == 0) {\r
            cen = texelFetch(splatTexture0, ivec2((splatIndex & 0x3ffu) << 1, splatIndex >> 10), 0);\r
            cov3d = texelFetch(splatTexture0, ivec2(((splatIndex & 0x3ffu) << 1) | 1u, splatIndex >> 10), 0);\r
        } else {\r
            cen = texelFetch(splatTexture1, ivec2((splatIndex & 0x3ffu) << 1, splatIndex >> 10), 0);\r
            cov3d = texelFetch(splatTexture1, ivec2(((splatIndex & 0x3ffu) << 1) | 1u, splatIndex >> 10), 0);\r
        }\r
    } else {\r
        cen = texelFetch(splatTexture0, ivec2((splatIndex & 0x3ffu) << 1, splatIndex >> 10), 0);\r
        cov3d = texelFetch(splatTexture0, ivec2(((splatIndex & 0x3ffu) << 1) | 1u, splatIndex >> 10), 0);\r
    }

    float fvAlpha = getFvAlpha(cen);\r
    if (fvAlpha <= 0.0)\r
        return;

    bool isWatermark = (cen.w & 65536u) > 0u;\r
    vec3 v3Cen = uintBitsToFloat(cen.xyz);

    v3Cen = animateParticle(v3Cen);

    if (isWatermark && debugEffect) {\r
        v3Cen.y += sin(performanceNow * 0.002 + v3Cen.x) * 0.1; 
    }

    vec4 cam = modelViewMatrix * vec4(v3Cen, 1.0);\r
    vec4 pos2d = projectionMatrix * cam;\r
    float clip = 1.2 * pos2d.w;\r
    if (pos2d.z < -clip || pos2d.x < -clip || pos2d.x > clip || pos2d.y < -clip || pos2d.y > clip || isWatermark && (!showWaterMark || pointMode)) {\r
        gl_Position = vec4(0.0, 0.0, 2.0, 1.0);\r
        return;\r
    }

    float currentRadius = length(vec3(0.0, topY, 0.0) - v3Cen);\r
    if (currentVisibleRadius > 0.0 && currentRadius > currentVisibleRadius) {\r
        gl_Position = vec4(0.0, 0.0, 2.0, 1.0);\r
        return;\r
    }

    vec2 uh1 = unpackHalf2x16(cov3d.x), uh2 = unpackHalf2x16(cov3d.y), uh3 = unpackHalf2x16(cov3d.z);\r
    mat3 Vrk = mat3(uh1.x, uh1.y, uh2.x, uh1.y, uh2.y, uh3.x, uh2.x, uh3.x, uh3.y);

    float ZxZ = cam.z * cam.z;\r
    mat3 J_m3 = mat3(focal.x / cam.z, 0.0, -(focal.x * cam.x) / ZxZ, 0.0, focal.y / cam.z, -(focal.y * cam.y) / ZxZ, 0.0, 0.0, 0.0);

    mat3 T_m3 = transpose(mat3(modelViewMatrix)) * J_m3;\r
    mat3 cov2d = transpose(T_m3) * Vrk * T_m3;

    cov2d[0][0] += 0.3;\r
    cov2d[1][1] += 0.3;\r
    vec3 cov2Dv = vec3(cov2d[0][0], cov2d[0][1], cov2d[1][1]);\r
    float eigenValue1 = 0.5 * (cov2Dv.x + cov2Dv.z) + sqrt((cov2Dv.x + cov2Dv.z) * (cov2Dv.x + cov2Dv.z) / 4.0 - (cov2Dv.x * cov2Dv.z - cov2Dv.y * cov2Dv.y));\r
    float eigenValue2 = max(0.5 * (cov2Dv.x + cov2Dv.z) - sqrt((cov2Dv.x + cov2Dv.z) * (cov2Dv.x + cov2Dv.z) / 4.0 - (cov2Dv.x * cov2Dv.z - cov2Dv.y * cov2Dv.y)), 0.0);\r
    float eigenValueOrig1 = eigenValue1;\r
    float eigenValueOrig2 = eigenValue2;

    bool isLightColor = false;\r
    if (!isWatermark) {\r
        if (pointMode) {\r
            eigenValue1 = eigenValue2 = 0.5;\r
        }

        if (!bigSceneMode && currentLightRadius > 0.0) {\r
            
            if (currentRadius < currentLightRadius && currentRadius > currentLightRadius * 0.9) {\r
                eigenValue1 = eigenValueOrig1;\r
                eigenValue2 = eigenValueOrig2;\r
                isLightColor = true;\r
            }\r
            if (currentRadius < currentLightRadius * 0.9) {\r
                if (pointMode) {\r
                    eigenValue1 = eigenValueOrig1;\r
                    eigenValue2 = eigenValueOrig2;\r
                } else {\r
                    eigenValue1 = eigenValue2 = 0.5;\r
                }\r
            }\r
        }\r
    }

    vPosition = vec3(position.xy, -1.0);\r
    vec2 eigenVector1 = normalize(vec2(cov2Dv.y, eigenValue1 - cov2Dv.x));\r
    if (markPoint.w > 0.0 && length(vec3(markPoint.xyz) - v3Cen) < 0.000001) {\r
        vColor = vec4(1.0, 1.0, 0.0, 1.0);\r
        eigenValue1 = eigenValue2 = 11.0;\r
        eigenVector1 = normalize(vec2(11.0, 0.0));\r
        vPosition.z = 1.0; 
    } else if (isLightColor) {\r
        vColor = vec4(1.0, 1.0, 1.0, 0.2);\r
    } else if (isWatermark) {\r
        vColor = waterMarkColor;\r
    } else {\r
        vColor = vec4(float(cov3d.w & 0xFFu) / 255.0, float((cov3d.w >> 8) & 0xFFu) / 255.0, float((cov3d.w >> 16) & 0xFFu) / 255.0, (float(cov3d.w >> 24) / 255.0) * fvAlpha);\r
        if (shDegree > 0) {\r
            vColor.rgb += splatEvalSH(v3Cen);\r
        }\r
    }

    vec2 eigenVector2 = vec2(eigenVector1.y, -eigenVector1.x);\r
    vec2 majorAxis = eigenVector1 * min(sqrt(2.0 * eigenValue1), 1024.0);\r
    vec2 minorAxis = eigenVector2 * min(sqrt(2.0 * eigenValue2), 1024.0);

    vec2 v2Center = vec2(pos2d) / pos2d.w;  
    gl_Position = vec4(v2Center + vPosition.x * majorAxis / viewport + vPosition.y * minorAxis / viewport, 1.0, 1.0);\r
}`,L0=`precision highp float;

uniform float lightFactor;\r
varying vec4 vColor;\r
varying vec3 vPosition;

void main() {\r
    float dtPos = -dot(vPosition.xy, vPosition.xy);\r
    if (dtPos < -4.0)\r
        discard;

    dtPos = vPosition.z >= 1.0 ? 1.0 : exp(dtPos) * vColor.a;\r
    gl_FragColor = vec4(lightFactor * vColor.rgb, dtPos);\r
}`;function _0(i){let A=!1;const e=(E,C,Q)=>i.on(E,C,Q),t=(E,...C)=>i.fire(E,...C);let n=0,s=0;const o=[];let r=0;e(_p,()=>r),e(qo,()=>{},!0),e(Wo,()=>{},!0),e(Ms,()=>{},!0),e(Ns,()=>{},!0),e(hI,async()=>{const E=new Yr;E.setIndex([0,1,2,0,2,3]);const C=new Float32Array(12),Q=new Qe(C,3);E.setAttribute("position",Q),Q.setXYZ(0,-2,-2,0),Q.setXYZ(1,-2,2,0),Q.setXYZ(2,2,2,0),Q.setXYZ(3,2,-2,0),Q.needsUpdate=!0;let h=new Yr().copy(E);const l=await t(en);if(A)return;const B=new Uint32Array(l),c=new qs(B,1,!1);return c.setUsage(TQ),c.needsUpdate=!0,h.setAttribute(C0,c),h.instanceCount=0,e(uI,(R,p,d,w,S)=>{t(pI,p),B.set(R,0),c.clearUpdateRanges(),c.addUpdateRange(0,R.length),c.needsUpdate=!0,c.onUpload(()=>{t(wC,p),t(We,{renderSplatCount:S})}),h.instanceCount=R.length,t(ce),t(We,{sortTime:`${d} / ${Date.now()-w}`})}),e(dp,()=>h),e(qo,()=>{c.array=null,h.dispose()},!0),h}),e(lI,async()=>{const E=await t(en);if(A)return;const C=1024*2,Q=Math.ceil(2*E/C),h=t(pe),l=new Wt({uniforms:t(cI),vertexShader:F0,fragmentShader:L0,transparent:!0,alphaTest:1,blending:Ri,depthTest:h.depthTest!==!1,depthWrite:!1,side:Bt}),B=new Uint32Array(C*Q*4);let c=new bt(B,C,Q,mt,Oe);c.internalFormat="RGBA32UI",c.needsUpdate=!0,l.uniforms[Ar].value=c;const R=t(Pe)?Q:1,p=new Uint32Array(C*R*4);let d=new bt(p,C,R,mt,Oe);d.internalFormat="RGBA32UI",d.needsUpdate=!0,l.uniforms[er].value=d;const w=await t(Un,1),S=new Uint32Array(C*w*4);let F=new bt(S,C,w,mt,Oe);F.internalFormat="RGBA32UI",F.needsUpdate=!0,l.uniforms[Zo].value=F;const N=await t(Un,3),u=new Uint32Array(C*N*4);let f=new bt(u,C,N,mt,Oe);f.internalFormat="RGBA32UI",f.needsUpdate=!0,l.uniforms[jo].value=f,l.needsUpdate=!0;let m=!1;e(fI,M=>{if(!t(Pe)){if(m&&!M.renderSplatCount)return;m=!M.renderSplatCount}const _=M.txdata;M.txdata=null;const P=new bt(_,C,Q,mt,Oe);P.onUpdate=()=>{M.textureReady=!0,M.textureReadyTime=Date.now(),I(M),t(mC,M.renderSplatCount)},P.internalFormat="RGBA32UI",P.needsUpdate=!0,M.index?(l.uniforms[er].value=P,d=P):(l.uniforms[Ar].value=P,c=P),l.needsUpdate=!0,t(ce)}),e(SC,async M=>{if(t(Pe)||!M||!M.length)return;const _=new Uint32Array(C*await t(Un,1)*4),P=new Uint8Array(_.buffer);for(let z=0,O=0;z<M.length;z++)P.set(M[z],O),O+=M[z].byteLength;const b=new bt(_,C,w,mt,Oe);b.internalFormat="RGBA32UI",b.needsUpdate=!0,l.uniforms[Zo].value=b,l.needsUpdate=!0,t(ce)}),e(MC,async M=>{if(t(Pe)||!M||!M.length)return;const _=new Uint32Array(C*await t(Un,3)*4),P=new Uint8Array(_.buffer);for(let z=0,O=0;z<M.length;z++)P.set(M[z],O),O+=M[z].byteLength;const b=new bt(_,C,w,mt,Oe);b.internalFormat="RGBA32UI",b.needsUpdate=!0,l.uniforms[jo].value=b,l.needsUpdate=!0,t(ce)}),e(dI,()=>l),e(Ms,()=>{const M=t(Na),{width:_,height:P}=t(Vr),b=Math.abs(M.projectionMatrix.elements[0])*.5*_,z=Math.abs(M.projectionMatrix.elements[5])*.5*P,O=t(dI);O.uniforms[KI].value.set(b,z),O.uniformsNeedUpdate=!0,t(ce)},!0),e(Ns,()=>{const{width:M,height:_}=t(Vr);l.uniforms[JI].value.set(M,_),l.uniformsNeedUpdate=!0,t(ce)},!0),e(pI,M=>{l.uniforms[TI].value=M,l.uniformsNeedUpdate=!0,t(ce)}),e(bn,M=>{const _=t(pe);M===void 0&&(M=!_.pointcloudMode),l.uniforms[HI].value=M,l.uniformsNeedUpdate=!0,_.pointcloudMode=M,t(ce),_.viewerEvents&&(_.viewerEvents.fire(pe).pointcloudMode=M)}),e(DI,M=>{l.uniforms[UI].value=M,l.uniformsNeedUpdate=!0;const _=t(pe);_.bigSceneMode=M,t(ce)}),e(EC,M=>{l.uniforms[GI].value=M,l.uniformsNeedUpdate=!0;const _=t(pe);_.lightFactor=M,t(ce)});let T=!1;return e(CC,M=>{t(Pe)||T||(T=!0,l.uniforms[YI].value=M,l.uniformsNeedUpdate=!0,t(ce))}),e(xs,M=>{l.uniforms[NI].value=M,l.uniformsNeedUpdate=!0,t(ce)}),e(Yo,M=>{l.uniforms[xI].value=M,l.uniformsNeedUpdate=!0,t(ce)}),e(xC,M=>{l.uniforms[bI].value=M,l.uniformsNeedUpdate=!0,t(ce)}),e(up,(M,_,P,b)=>{l.uniforms[PI].value=[M,_,P,b?1:-1],l.uniformsNeedUpdate=!0,t(ce)}),e(fp,(M=!0)=>{l.uniforms[LI].value=M,l.uniformsNeedUpdate=!0,t(ce)}),e(QC,M=>{l.uniforms[FI].value=M,l.uniformsNeedUpdate=!0}),e($r,M=>{l.uniforms[$o].value=M,l.uniformsNeedUpdate=!0,t(ce)}),e(Zs,M=>{l.uniforms[_I].value=M,l.uniformsNeedUpdate=!0,t(ce)}),e(pp,M=>{l.uniforms[vI].value=M,l.uniformsNeedUpdate=!0}),e(BC,async M=>{if(t(Pe))return;const _=await t(NC);M<0&&(M=0),M>_&&(M=_),r=M,l.uniforms[OI].value=M,l.uniformsNeedUpdate=!0,t(We,{shDegree:`${M} / max ${_}`}),t(ce)}),e(Gp,(M=0,_=0)=>{l.uniforms[kI].value=M<<16|_,l.uniforms[$o].value=performance.now(),l.uniformsNeedUpdate=!0,t(ce)}),e(Wo,()=>{l.dispose(),c&&c.dispose(),d&&d.dispose(),F&&F.dispose(),f&&f.dispose()},!0),l}),e(IC,async()=>{const E=new ve(await t(hI),await t(lI));return t(Ms),t(Ns),t(DI,t(Pe)),t(bn,t(zr)),E});function a(){t(Ms),t(Ns)}window.addEventListener("resize",a),e(uC,()=>{A=!0,window.removeEventListener("resize",a),t(qo),t(Wo)}),e(fC,async()=>{if(t(Pe))return;let E=.01,C=.01,Q=!1,h=0;t(xs,C),t(Xs,()=>{if(A||s<=C)return;C+=(s-C)*E,t(xs,C);let l=t(yC);l&&!h&&(h=Date.now());let B=C/n;l&&(B>.9||Date.now()-h>2500)?(t(zr)&&t(yI,!0),t(xs,0),Q=!0,setTimeout(()=>t(pe)?.viewerEvents?.fire(vp),5e3)):l&&B>.7?E=Math.min(E*1.2,.3):l&&B>.5?E=Math.min(E*1.2,.2):B>.4&&(E=Math.min(E*1.05,.1))},()=>!A&&!Q,3)}),e(yI,(E=!1)=>{if(t(Pe))return;for(;o.length;)o.pop().stop=!0;const C=t(pe),Q=n*.001;let h={currentPointMode:C.pointcloudMode,stepRate:.0015,currentLightRadius:Q,stop:!1};o.push(h),t(Xs,()=>{A||(h.currentLightRadius+=n*h.stepRate,t(Yo,h.currentLightRadius),h.currentLightRadius>n?(t(bn,!h.currentPointMode),t(Yo,0),h.stop=!0,o.length===1&&o[0]===h&&o.pop(),t(Aa,E)):h.currentLightRadius/n<.4?h.stepRate=Math.min(h.stepRate*1.02,.03):h.stepRate*=1.04)},()=>!A&&!h.stop)}),e(Aa,(E=!1)=>{t(Zs,0),E&&t(pe).viewerEvents?.fire(Np),t(pe).viewerEvents?.fire(Fp)}),e(cI,()=>({[Ar]:{type:"t",value:null},[er]:{type:"t",value:null},[Zo]:{type:"t",value:null},[jo]:{type:"t",value:null},[KI]:{type:"v2",value:new bA},[JI]:{type:"v2",value:new bA},[TI]:{type:"int",value:0},[HI]:{type:"bool",value:!1},[vI]:{type:"bool",value:!0},[UI]:{type:"bool",value:!1},[OI]:{type:"int",value:0},[GI]:{type:"float",value:1},[YI]:{type:"float",value:0},[NI]:{type:"float",value:0},[xI]:{type:"float",value:0},[bI]:{type:"float",value:0},[PI]:{type:"v4",value:new YA(0,0,0,-1)},[_I]:{type:"int",value:0},[FI]:{type:"float",value:performance.now()},[$o]:{type:"float",value:0},[E0]:{type:"v4",value:new YA(1,1,0,.5)},[LI]:{type:"bool",value:!0},[kI]:{type:"uint",value:1}}));const g=t(tC);g.onmessage=E=>{const C=E.data;C[qI]&&t(uI,C[qI],C[WI],C[l0],C[h0],C[VI])},e(Zr,(E,C,Q)=>{t(Pe)||(s=C,n=Q),t(fI,E)});function I(E){const C=E.xyz.slice(0);g.postMessage({[d0]:!0,[D0]:C,[x0]:E.watermarkCount,[WI]:E.index,[Q0]:E.version,[VI]:E.renderSplatCount,[B0]:E.visibleSplatCount,[c0]:E.modelSplatCount,[m0]:E.minX,[y0]:E.maxX,[R0]:E.minY,[w0]:E.maxY,[S0]:E.minZ,[M0]:E.maxZ},[C.buffer])}}function U0(i){const A=(n,...s)=>i.fire(n,...s),e=(n,s,o)=>i.on(n,s,o),t=new Set(Pp.split(""));e(RC,async(n="",s=!0,o=!0)=>{const r=n.trim().substring(0,100);let a=await A(eC,r),g=[];for(let p=0;p<a.length;p++){let d=[],w=a[p];for(let S=0;S<w.length;S++)d.push([(w[S]%20-10)*.02,((w[S]/20|0)-10)*.02]);g.push(d)}let I=[],E=r.split("");for(let p=0;p<E.length;p++)I[p]=t.has(E[p])?.22:.4;let C=E.length/2|0,Q=I[C]/2,h=!(E.length%2),l=h?0:-Q;for(let p=C-1;p>=0;p--){l-=I[p]/2;for(let d of g[p])d[0]+=l;l-=I[p]/2}Q=I[C]/2,l=h?0:Q;for(let p=g.length-C;p<g.length;p++){l+=I[p]/2;for(let d of g[p])d[0]+=l;l+=I[p]/2}let B=0;for(let p of g)B+=p.length;const c=new Uint8Array(B*KA);let R=0;for(let p of g)for(let d of p)c.set(await e0(d[0],d[1],s,o),KA*R++);return c})}function G0(i){const A=(e,t,n)=>i.on(e,t,n);A(Qp,e=>{e.url;const t={...e};delete t.url;const n=JSON.stringify(t,null,2);console.info(n)}),A(eC,(e="")=>{const t="https://reall3d.com/gsfont/api/getGaussianText",n=new FormData;return n.append("text",e.substring(0,100)),n.append("ver",FC),new Promise(s=>{fetch(t,{method:"POST",body:n}).then(o=>o.ok?o.json():{}).then(o=>o.success?s(JSON.parse(o.data)):s([])).catch(o=>s([]))})})}new L;new L;new L;new L;new L;new GA;function v0(i){const A={...i};return A.bigSceneMode??(A.bigSceneMode=!1),A.pointcloudMode??(A.pointcloudMode=!A.bigSceneMode),A.lightFactor??(A.lightFactor=1),A.name??(A.name=""),A.showWatermark??(A.showWatermark=!0),A.shDegree??(A.shDegree=0),A.depthTest??(A.depthTest=!0),A.debugMode??(A.debugMode=!1),A.maxRenderCountOfMobile??(A.maxRenderCountOfMobile=A.bigSceneMode?256*1e4:384*10240),A.maxRenderCountOfPc??(A.maxRenderCountOfPc=A.bigSceneMode?320*1e4:384*1e4),A}function T0(i){const A=(o,r,a)=>i.on(o,r,a),e=(o,...r)=>i.fire(o,...r),t="KGZ1bmN0aW9uKCl7InVzZSBzdHJpY3QiO2xldCBpPTA7aSsrO2NvbnN0IEQ9YCQke2krK31gO2krKyxpKyssaSsrO2NvbnN0IFc9YCQke2krK31gLHA9YCQke2krK31gLFM9YCQke2krK31gLHk9YCQke2krK31gLEM9YCQke2krK31gLEE9YCQke2krK31gLFI9YCQke2krK31gLEc9YCQke2krK31gO2krKztjb25zdCBIPWAkJHtpKyt9YCxKPWAkJHtpKyt9YDtpKys7Y29uc3QgVD1gJCR7aSsrfWA7aSsrO2NvbnN0IEs9YCQke2krK31gO2krKztjb25zdCBMPWAkJHtpKyt9YCxOPWAkJHtpKyt9YCxPPWAkJHtpKyt9YCxRPWAkJHtpKyt9YCxfPWAkJHtpKyt9YCxWPWAkJHtpKyt9YCxqPWAkJHtpKyt9YCxQPWAkJHtpKyt9YDtpKys7Y29uc3Qgbm49bmF2aWdhdG9yLnVzZXJBZ2VudC5pbmNsdWRlcygiTW9iaSIpLGI9c2VsZjtsZXQgWD17aW5kZXg6MCx2ZXJzaW9uOjB9LFk9e2luZGV4OjEsdmVyc2lvbjowfSx3PSExLFo7Y29uc3QgdG49LjI7bGV0IGssZj1bXSxNLHo9MCxCO2Z1bmN0aW9uIGFuKG4pe2lmKCF3KXJldHVybjtsZXQgYT1YLnZlcnNpb24+WS52ZXJzaW9uP1g6WTtpZighYS52ZXJzaW9uKXJldHVybjtjb25zdHt4eXo6dCxyZW5kZXJTcGxhdENvdW50Om8sdmlzaWJsZVNwbGF0Q291bnQ6bSxtb2RlbFNwbGF0Q291bnQ6RSx3YXRlcm1hcmtDb3VudDp4LGluZGV4OkYsdmVyc2lvbjp1fT1hO2lmKHo9PT11JiZNYXRoLmFicyhmWzJdLW5bMl0pK01hdGguYWJzKGZbNl0tbls2XSkrTWF0aC5hYnMoZlsxMF0tblsxMF0pK01hdGguYWJzKGZbMTRdLW5bMTRdKTx0bilyZXR1cm47Zj1uLHo9dTtsZXQgST1EYXRlLm5vdygpLGw7aWYoIW8pe2w9bmV3IFVpbnQzMkFycmF5KDApLGIucG9zdE1lc3NhZ2Uoe1tEXTpsLFtTXTpvLFt5XTptLFtDXTpFLFtXXTpGLFtwXTp1LFtSXTowLFtBXTpJfSxbbC5idWZmZXJdKTtyZXR1cm59bGV0IHE9MDtjb25zdCByPW8teDtsPW5ldyBVaW50MzJBcnJheShvKTtjb25zdHttYXhEZXB0aDp2LG1pbkRlcHRoOmR9PWVuKGEsayk7aWYodi1kPD0xZS01KWZvcihsZXQgcz0wO3M8bztzKyspbFtzXT1zO2Vsc2V7bGV0IHM9TWF0aC5taW4ociw2NTUzNSksZz0ocy0xKS8odi1kKSxjPW5ldyBJbnQzMkFycmF5KHMpO2ZvcihsZXQgZT0wLGg9MDtlPHI7ZSsrKWg9KCQobix0WzMqZV0sdFszKmUrMV0sdFszKmUrMl0pLWQpKmd8MCxjW01bZV09aF0rKztmb3IobGV0IGU9MTtlPHM7ZSsrKWNbZV0rPWNbZS0xXTtmb3IobGV0IGU9MDtlPHI7ZSsrKWxbLS1jW01bZV1dXT1lO2lmKHgpe3M9TWF0aC5taW4oTWF0aC5tYXgoeC84fDAsNTEyKSw2NTUzNSksZz0ocy0xKS8odi1kKSxjPW5ldyBJbnQzMkFycmF5KHMpO2ZvcihsZXQgZT1yLGg9MDtlPG87ZSsrKWg9KCQobix0WzMqZV0sdFszKmUrMV0sdFszKmUrMl0pLWQpKmd8MCxjW01bZS1yXT1oXSsrO2ZvcihsZXQgZT0xO2U8cztlKyspY1tlXSs9Y1tlLTFdO2ZvcihsZXQgZT0wO2U8eDtlKyspbFtyKy0tY1tNW2VdXV09citlfX1xPURhdGUubm93KCktSSxiLnBvc3RNZXNzYWdlKHtbRF06bCxbU106byxbeV06bSxbQ106RSxbV106RixbcF06dSxbQV06SSxbUl06cX0sW2wuYnVmZmVyXSl9ZnVuY3Rpb24gJChuLGEsdCxvKXtyZXR1cm4tKG5bMl0qYStuWzZdKnQrblsxMF0qbyl9ZnVuY3Rpb24gZW4obixhKXtsZXQgdD0tMS8wLG89MS8wLG09MDtyZXR1cm4gbT0kKGEsbi5taW5YLG4ubWluWSxuLm1pblopLHQ9TWF0aC5tYXgodCxtKSxvPU1hdGgubWluKG8sbSksbT0kKGEsbi5taW5YLG4ubWluWSxuLm1heFopLHQ9TWF0aC5tYXgodCxtKSxvPU1hdGgubWluKG8sbSksbT0kKGEsbi5taW5YLG4ubWF4WSxuLm1pblopLHQ9TWF0aC5tYXgodCxtKSxvPU1hdGgubWluKG8sbSksbT0kKGEsbi5taW5YLG4ubWF4WSxuLm1heFopLHQ9TWF0aC5tYXgodCxtKSxvPU1hdGgubWluKG8sbSksbT0kKGEsbi5tYXhYLG4ubWluWSxuLm1pblopLHQ9TWF0aC5tYXgodCxtKSxvPU1hdGgubWluKG8sbSksbT0kKGEsbi5tYXhYLG4ubWluWSxuLm1heFopLHQ9TWF0aC5tYXgodCxtKSxvPU1hdGgubWluKG8sbSksbT0kKGEsbi5tYXhYLG4ubWF4WSxuLm1pblopLHQ9TWF0aC5tYXgodCxtKSxvPU1hdGgubWluKG8sbSksbT0kKGEsbi5tYXhYLG4ubWF4WSxuLm1heFopLHQ9TWF0aC5tYXgodCxtKSxvPU1hdGgubWluKG8sbSkse21heERlcHRoOnQsbWluRGVwdGg6b319Y29uc3QgVT0oKT0+e2lmKCFaKXtaPSEwO2NvbnN0IG49azthbihuKSxzZXRUaW1lb3V0KCgpPT4hKFo9ITEpJiZuIT09ayYmVSgpKX19O2Iub25tZXNzYWdlPW49Pntjb25zdCBhPW4uZGF0YTtpZihhW0ddKXtsZXQgdD0hQnx8YVtXXT09PTA/WDpZO3QubWluWD1hW0xdLHQubWF4WD1hW05dLHQubWluWT1hW09dLHQubWF4WT1hW1FdLHQubWluWj1hW19dLHQubWF4Wj1hW1ZdLHQueHl6PW5ldyBGbG9hdDMyQXJyYXkoYVtLXS5idWZmZXIpLHQud2F0ZXJtYXJrQ291bnQ9YVtQXSx0LnZlcnNpb249YVtwXSx0LnJlbmRlclNwbGF0Q291bnQ9YVtTXSx0LnZpc2libGVTcGxhdENvdW50PWFbeV0sdC5tb2RlbFNwbGF0Q291bnQ9YVtDXSx0LnRleHR1cmVSZWFkeT0hMCx0LnRleHR1cmVSZWFkeVRpbWU9RGF0ZS5ub3coKX1lbHNlIGFbVF0/KGs9YVtUXSxVKCkpOmFbal0mJihCPWFbSF0sTT1uZXcgSW50MzJBcnJheShhW0pdKSx3PSEwKX19KSgpOwo=",n=URL.createObjectURL(new Blob([atob(t)],{type:"text/javascript"})),s=new Worker(new URL(n,import.meta.url),{type:"module"});A(tC,()=>s),A(aC,()=>s.postMessage({[p0]:e(oC)})),A(gC,()=>s.terminate()),(async()=>s.postMessage({[N0]:!0,[f0]:await e(en),[u0]:e(Pe)}))()}class b0 extends Be{constructor(A=0,e=0,t=0,n=0,s=0,o=0){super();const r=this,a=new Xe,g=new la({color:"#ffffff"});r.boxLines=new xE(a,g),r.update(A,e,t,n,s,o),r.add(r.boxLines)}update(A,e,t,n,s,o,r){const a=(n-A)/8,g=(s-e)/8,I=(o-t)/8,E=[new L(A,e,t),new L(n,e,t),new L(n,s,t),new L(A,s,t),new L(A,e,o),new L(n,e,o),new L(n,s,o),new L(A,s,o)],C=[];E.forEach(Q=>{C.push(Q.x,Q.y,Q.z),C.push(Q.x+(Q.x<n?a:-a),Q.y,Q.z),C.push(Q.x,Q.y,Q.z),C.push(Q.x,Q.y+(Q.y<s?g:-g),Q.z),C.push(Q.x,Q.y,Q.z),C.push(Q.x,Q.y,Q.z+(Q.z<o?I:-I))}),this.boxLines.geometry.setAttribute("position",new Rt(C,3)),r&&(this.visible=!0)}dispose(){this.boxLines=null}}class UC extends ve{constructor(A){super(),this.isSplatMesh=!0,this.disposed=!1;const e=this,t=new bp,n=(g,I,E)=>t.on(g,I,E),s=(g,...I)=>t.fire(g,...I),o=v0(A),r=o.controls.object;n(pe,()=>o),n(iC,()=>o.renderer.domElement),n(Na,()=>r),n(Bp,()=>r.fov),n(sC,(g=!1)=>g?r.position.clone():r.position),n(nC,(g=!1)=>g?o.controls.target.clone():o.controls.target),n(oC,()=>r.projectionMatrix.clone().multiply(r.matrixWorldInverse).multiply(e.matrix).toArray()),n(rC,()=>r.projectionMatrix.clone().multiply(r.matrixWorldInverse)),n(Sp,()=>r.getWorldDirection(new L).toArray()),n(Dp,()=>o.renderer),n(Vo,()=>o.scene),n(Pe,()=>o.bigSceneMode),n(zr,()=>o.pointcloudMode),n(Lp,()=>e),n(ce,()=>o.viewerEvents?.fire(Mp)),jp(t),G0(t),I0(t),T0(t),_0(t),U0(t),e.name=`${o.name||e.id}`,e.events=t,e.opts=o,(async()=>(e.copy(await t.fire(IC)),e.meta.transform&&e.applyMatrix4(new UA().fromArray(e.meta.transform)),e.frustumCulled=!1,e.onBeforeRender=()=>{s(aC),s(QC,performance.now())},e.onAfterRender=()=>{s(lC,1e4)&&s(ce)}))();const a=new b0;a.visible=!1,a.renderOrder=99999,e.boundBox=a,e.add(a),n(jr,(g,I,E,C,Q,h,l)=>{a.update(g,I,E,C,Q,h,l)}),n(Tp,(g=!0)=>a.visible=g)}options(A){const e=this;if(e.disposed)return;const t=(s,...o)=>e.events.fire(s,...o),n=e.opts;return A&&(A.pointcloudMode!==void 0&&t(bn,A.pointcloudMode),A.lightFactor!==void 0&&t(EC,A.lightFactor),A.maxRenderCountOfMobile!==void 0&&(n.maxRenderCountOfMobile=A.maxRenderCountOfMobile),A.maxRenderCountOfPc!==void 0&&(n.maxRenderCountOfPc=A.maxRenderCountOfPc),t(ce)),{...n}}async addModel(A,e={}){const t=this;t.disposed||(t.meta=e,await t.events.fire(hC,A,e))}fire(A,...e){const t=this;if(!t.disposed)return t.events.fire(A,...e)}dispose(){const A=this;if(A.disposed)return;A.disposed=!0;const e=(t,...n)=>A.events.fire(t,...n);e(Xr,A),e(Xr,A.boundBox),e(Vo).remove(A),e(Vo).remove(A.boundBox),e(cC),e(dC),e(gC),e(uC),A.events.clear(),A.events=null,A.opts=null,A.onAfterRender=null,A.boundBox=null}}new Mi;new Ht;new L;new rt;new L;aA.line={worldUnits:{value:1},linewidth:{value:1},resolution:{value:new bA(1,1)},dashOffset:{value:0},dashScale:{value:1},dashSize:{value:1},gapSize:{value:1}};Qt.line={uniforms:wE.merge([aA.common,aA.fog,aA.line]),vertexShader:`
		#include <common>
		#include <color_pars_vertex>
		#include <fog_pars_vertex>
		#include <logdepthbuf_pars_vertex>
		#include <clipping_planes_pars_vertex>

		uniform float linewidth;
		uniform vec2 resolution;

		attribute vec3 instanceStart;
		attribute vec3 instanceEnd;

		attribute vec3 instanceColorStart;
		attribute vec3 instanceColorEnd;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#ifdef USE_DASH

			uniform float dashScale;
			attribute float instanceDistanceStart;
			attribute float instanceDistanceEnd;
			varying float vLineDistance;

		#endif

		void trimSegment( const in vec4 start, inout vec4 end ) {

			// trim end segment so it terminates between the camera plane and the near plane

			// conservative estimate of the near plane
			float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
			float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
			float nearEstimate = - 0.5 * b / a;

			float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );

			end.xyz = mix( start.xyz, end.xyz, alpha );

		}

		void main() {

			#ifdef USE_COLOR

				vColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;

			#endif

			#ifdef USE_DASH

				vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;
				vUv = uv;

			#endif

			float aspect = resolution.x / resolution.y;

			// camera space
			vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );
			vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );

			#ifdef WORLD_UNITS

				worldStart = start.xyz;
				worldEnd = end.xyz;

			#else

				vUv = uv;

			#endif

			// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
			// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
			// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
			// perhaps there is a more elegant solution -- WestLangley

			bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column

			if ( perspective ) {

				if ( start.z < 0.0 && end.z >= 0.0 ) {

					trimSegment( start, end );

				} else if ( end.z < 0.0 && start.z >= 0.0 ) {

					trimSegment( end, start );

				}

			}

			// clip space
			vec4 clipStart = projectionMatrix * start;
			vec4 clipEnd = projectionMatrix * end;

			// ndc space
			vec3 ndcStart = clipStart.xyz / clipStart.w;
			vec3 ndcEnd = clipEnd.xyz / clipEnd.w;

			// direction
			vec2 dir = ndcEnd.xy - ndcStart.xy;

			// account for clip-space aspect ratio
			dir.x *= aspect;
			dir = normalize( dir );

			#ifdef WORLD_UNITS

				vec3 worldDir = normalize( end.xyz - start.xyz );
				vec3 tmpFwd = normalize( mix( start.xyz, end.xyz, 0.5 ) );
				vec3 worldUp = normalize( cross( worldDir, tmpFwd ) );
				vec3 worldFwd = cross( worldDir, worldUp );
				worldPos = position.y < 0.5 ? start: end;

				// height offset
				float hw = linewidth * 0.5;
				worldPos.xyz += position.x < 0.0 ? hw * worldUp : - hw * worldUp;

				// don't extend the line if we're rendering dashes because we
				// won't be rendering the endcaps
				#ifndef USE_DASH

					// cap extension
					worldPos.xyz += position.y < 0.5 ? - hw * worldDir : hw * worldDir;

					// add width to the box
					worldPos.xyz += worldFwd * hw;

					// endcaps
					if ( position.y > 1.0 || position.y < 0.0 ) {

						worldPos.xyz -= worldFwd * 2.0 * hw;

					}

				#endif

				// project the worldpos
				vec4 clip = projectionMatrix * worldPos;

				// shift the depth of the projected points so the line
				// segments overlap neatly
				vec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;
				clip.z = clipPose.z * clip.w;

			#else

				vec2 offset = vec2( dir.y, - dir.x );
				// undo aspect ratio adjustment
				dir.x /= aspect;
				offset.x /= aspect;

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				// endcaps
				if ( position.y < 0.0 ) {

					offset += - dir;

				} else if ( position.y > 1.0 ) {

					offset += dir;

				}

				// adjust for linewidth
				offset *= linewidth;

				// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
				offset /= resolution.y;

				// select end
				vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;

				// back to clip space
				offset *= clip.w;

				clip.xy += offset;

			#endif

			gl_Position = clip;

			vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation

			#include <logdepthbuf_vertex>
			#include <clipping_planes_vertex>
			#include <fog_vertex>

		}
		`,fragmentShader:`
		uniform vec3 diffuse;
		uniform float opacity;
		uniform float linewidth;

		#ifdef USE_DASH

			uniform float dashOffset;
			uniform float dashSize;
			uniform float gapSize;

		#endif

		varying float vLineDistance;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#include <common>
		#include <color_pars_fragment>
		#include <fog_pars_fragment>
		#include <logdepthbuf_pars_fragment>
		#include <clipping_planes_pars_fragment>

		vec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {

			float mua;
			float mub;

			vec3 p13 = p1 - p3;
			vec3 p43 = p4 - p3;

			vec3 p21 = p2 - p1;

			float d1343 = dot( p13, p43 );
			float d4321 = dot( p43, p21 );
			float d1321 = dot( p13, p21 );
			float d4343 = dot( p43, p43 );
			float d2121 = dot( p21, p21 );

			float denom = d2121 * d4343 - d4321 * d4321;

			float numer = d1343 * d4321 - d1321 * d4343;

			mua = numer / denom;
			mua = clamp( mua, 0.0, 1.0 );
			mub = ( d1343 + d4321 * ( mua ) ) / d4343;
			mub = clamp( mub, 0.0, 1.0 );

			return vec2( mua, mub );

		}

		void main() {

			#include <clipping_planes_fragment>

			#ifdef USE_DASH

				if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps

				if ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX

			#endif

			float alpha = opacity;

			#ifdef WORLD_UNITS

				// Find the closest points on the view ray and the line segment
				vec3 rayEnd = normalize( worldPos.xyz ) * 1e5;
				vec3 lineDir = worldEnd - worldStart;
				vec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );

				vec3 p1 = worldStart + lineDir * params.x;
				vec3 p2 = rayEnd * params.y;
				vec3 delta = p1 - p2;
				float len = length( delta );
				float norm = len / linewidth;

				#ifndef USE_DASH

					#ifdef USE_ALPHA_TO_COVERAGE

						float dnorm = fwidth( norm );
						alpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );

					#else

						if ( norm > 0.5 ) {

							discard;

						}

					#endif

				#endif

			#else

				#ifdef USE_ALPHA_TO_COVERAGE

					// artifacts appear on some hardware if a derivative is taken within a conditional
					float a = vUv.x;
					float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
					float len2 = a * a + b * b;
					float dlen = fwidth( len2 );

					if ( abs( vUv.y ) > 1.0 ) {

						alpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );

					}

				#else

					if ( abs( vUv.y ) > 1.0 ) {

						float a = vUv.x;
						float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
						float len2 = a * a + b * b;

						if ( len2 > 1.0 ) discard;

					}

				#endif

			#endif

			vec4 diffuseColor = vec4( diffuse, alpha );

			#include <logdepthbuf_fragment>
			#include <color_fragment>

			gl_FragColor = vec4( diffuseColor.rgb, alpha );

			#include <tonemapping_fragment>
			#include <colorspace_fragment>
			#include <fog_fragment>
			#include <premultiplied_alpha_fragment>

		}
		`};new YA;new L;new L;new YA;new YA;new YA;new L;new UA;new lc;new L;new rt;new Dt;new YA;new L;new L;new UA;new UA;var k0=function(){return performance.now()},H0=(function(){function i(){for(var A=[],e=0;e<arguments.length;e++)A[e]=arguments[e];this._tweens={},this._tweensAddedDuringUpdate={},this.add.apply(this,A)}return i.prototype.getAll=function(){var A=this;return Object.keys(this._tweens).map(function(e){return A._tweens[e]})},i.prototype.removeAll=function(){this._tweens={}},i.prototype.add=function(){for(var A,e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];for(var n=0,s=e;n<s.length;n++){var o=s[n];(A=o._group)===null||A===void 0||A.remove(o),o._group=this,this._tweens[o.getId()]=o,this._tweensAddedDuringUpdate[o.getId()]=o}},i.prototype.remove=function(){for(var A=[],e=0;e<arguments.length;e++)A[e]=arguments[e];for(var t=0,n=A;t<n.length;t++){var s=n[t];s._group=void 0,delete this._tweens[s.getId()],delete this._tweensAddedDuringUpdate[s.getId()]}},i.prototype.allStopped=function(){return this.getAll().every(function(A){return!A.isPlaying()})},i.prototype.update=function(A,e){A===void 0&&(A=k0()),e===void 0&&(e=!0);var t=Object.keys(this._tweens);if(t.length!==0)for(;t.length>0;){this._tweensAddedDuringUpdate={};for(var n=0;n<t.length;n++){var s=this._tweens[t[n]],o=!e;s&&s.update(A,o)===!1&&!e&&this.remove(s)}t=Object.keys(this._tweensAddedDuringUpdate)}},i})(),P0=new H0,St=P0;St.getAll.bind(St);St.removeAll.bind(St);St.add.bind(St);St.remove.bind(St);St.update.bind(St);navigator.userAgent.includes("Mobi");const Vi=new pt(0,0,0,"YXZ"),zi=new L,O0={type:"change"},J0={type:"lock"},K0={type:"unlock"},zI=Math.PI/2;class Y0 extends dc{constructor(A,e=null){super(A,e),this.isLocked=!1,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.pointerSpeed=1,this._onMouseMove=q0.bind(this),this._onPointerlockChange=W0.bind(this),this._onPointerlockError=V0.bind(this),this.domElement!==null&&this.connect()}connect(){this.domElement.ownerDocument.addEventListener("mousemove",this._onMouseMove),this.domElement.ownerDocument.addEventListener("pointerlockchange",this._onPointerlockChange),this.domElement.ownerDocument.addEventListener("pointerlockerror",this._onPointerlockError)}disconnect(){this.domElement.ownerDocument.removeEventListener("mousemove",this._onMouseMove),this.domElement.ownerDocument.removeEventListener("pointerlockchange",this._onPointerlockChange),this.domElement.ownerDocument.removeEventListener("pointerlockerror",this._onPointerlockError)}dispose(){this.disconnect()}getObject(){return console.warn("THREE.PointerLockControls: getObject() has been deprecated. Use controls.object instead."),this.object}getDirection(A){return A.set(0,0,-1).applyQuaternion(this.object.quaternion)}moveForward(A){if(this.enabled===!1)return;const e=this.object;zi.setFromMatrixColumn(e.matrix,0),zi.crossVectors(e.up,zi),e.position.addScaledVector(zi,A)}moveRight(A){if(this.enabled===!1)return;const e=this.object;zi.setFromMatrixColumn(e.matrix,0),e.position.addScaledVector(zi,A)}lock(){this.domElement.requestPointerLock()}unlock(){this.domElement.ownerDocument.exitPointerLock()}}function q0(i){if(this.enabled===!1||this.isLocked===!1)return;const A=this.object;Vi.setFromQuaternion(A.quaternion),Vi.y-=i.movementX*.002*this.pointerSpeed,Vi.x-=i.movementY*.002*this.pointerSpeed,Vi.x=Math.max(zI-this.maxPolarAngle,Math.min(zI-this.minPolarAngle,Vi.x)),A.quaternion.setFromEuler(Vi),this.dispatchEvent(O0)}function W0(){this.domElement.ownerDocument.pointerLockElement===this.domElement?(this.dispatchEvent(J0),this.isLocked=!0):(this.dispatchEvent(K0),this.isLocked=!1)}function V0(){console.error("THREE.PointerLockControls: Unable to use Pointer Lock API")}function XI(i,A){if(A===wQ)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),i;if(A===Or||A===lE){let e=i.getIndex();if(e===null){const o=[],r=i.getAttribute("position");if(r!==void 0){for(let a=0;a<r.count;a++)o.push(a);i.setIndex(o),e=i.getIndex()}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),i}const t=e.count-2,n=[];if(A===Or)for(let o=1;o<=t;o++)n.push(e.getX(0)),n.push(e.getX(o)),n.push(e.getX(o+1));else for(let o=0;o<t;o++)o%2===0?(n.push(e.getX(o)),n.push(e.getX(o+1)),n.push(e.getX(o+2))):(n.push(e.getX(o+2)),n.push(e.getX(o+1)),n.push(e.getX(o)));n.length/3!==t&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const s=i.clone();return s.setIndex(n),s.clearGroups(),s}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",A),i}class z0 extends Ei{constructor(A){super(A),this.dracoLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.pluginCallbacks=[],this.register(function(e){return new AD(e)}),this.register(function(e){return new eD(e)}),this.register(function(e){return new ID(e)}),this.register(function(e){return new ED(e)}),this.register(function(e){return new CD(e)}),this.register(function(e){return new iD(e)}),this.register(function(e){return new nD(e)}),this.register(function(e){return new sD(e)}),this.register(function(e){return new oD(e)}),this.register(function(e){return new $0(e)}),this.register(function(e){return new rD(e)}),this.register(function(e){return new tD(e)}),this.register(function(e){return new gD(e)}),this.register(function(e){return new aD(e)}),this.register(function(e){return new Z0(e)}),this.register(function(e){return new QD(e)}),this.register(function(e){return new BD(e)})}load(A,e,t,n){const s=this;let o;if(this.resourcePath!=="")o=this.resourcePath;else if(this.path!==""){const g=Tn.extractUrlBase(A);o=Tn.resolveURL(g,this.path)}else o=Tn.extractUrlBase(A);this.manager.itemStart(A);const r=function(g){n?n(g):console.error(g),s.manager.itemError(A),s.manager.itemEnd(A)},a=new TE(this.manager);a.setPath(this.path),a.setResponseType("arraybuffer"),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(A,function(g){try{s.parse(g,o,function(I){e(I),s.manager.itemEnd(A)},r)}catch(I){r(I)}},t,r)}setDRACOLoader(A){return this.dracoLoader=A,this}setKTX2Loader(A){return this.ktx2Loader=A,this}setMeshoptDecoder(A){return this.meshoptDecoder=A,this}register(A){return this.pluginCallbacks.indexOf(A)===-1&&this.pluginCallbacks.push(A),this}unregister(A){return this.pluginCallbacks.indexOf(A)!==-1&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(A),1),this}parse(A,e,t,n){let s;const o={},r={},a=new TextDecoder;if(typeof A=="string")s=JSON.parse(A);else if(A instanceof ArrayBuffer)if(a.decode(new Uint8Array(A,0,4))===GC){try{o[XA.KHR_BINARY_GLTF]=new cD(A)}catch(E){n&&n(E);return}s=JSON.parse(o[XA.KHR_BINARY_GLTF].content)}else s=JSON.parse(a.decode(A));else s=A;if(s.asset===void 0||s.asset.version[0]<2){n&&n(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));return}const g=new MD(s,{path:e||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});g.fileLoader.setRequestHeader(this.requestHeader);for(let I=0;I<this.pluginCallbacks.length;I++){const E=this.pluginCallbacks[I](g);E.name||console.error("THREE.GLTFLoader: Invalid plugin found: missing name"),r[E.name]=E,o[E.name]=!0}if(s.extensionsUsed)for(let I=0;I<s.extensionsUsed.length;++I){const E=s.extensionsUsed[I],C=s.extensionsRequired||[];switch(E){case XA.KHR_MATERIALS_UNLIT:o[E]=new j0;break;case XA.KHR_DRACO_MESH_COMPRESSION:o[E]=new hD(s,this.dracoLoader);break;case XA.KHR_TEXTURE_TRANSFORM:o[E]=new lD;break;case XA.KHR_MESH_QUANTIZATION:o[E]=new dD;break;default:C.indexOf(E)>=0&&r[E]===void 0&&console.warn('THREE.GLTFLoader: Unknown extension "'+E+'".')}}g.setExtensions(o),g.setPlugins(r),g.parse(t,n)}parseAsync(A,e){const t=this;return new Promise(function(n,s){t.parse(A,e,n,s)})}}function X0(){let i={};return{get:function(A){return i[A]},add:function(A,e){i[A]=e},remove:function(A){delete i[A]},removeAll:function(){i={}}}}const XA={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_DISPERSION:"KHR_materials_dispersion",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_SHEEN:"KHR_materials_sheen",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_IRIDESCENCE:"KHR_materials_iridescence",KHR_MATERIALS_ANISOTROPY:"KHR_materials_anisotropy",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",KHR_MATERIALS_EMISSIVE_STRENGTH:"KHR_materials_emissive_strength",EXT_MATERIALS_BUMP:"EXT_materials_bump",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_TEXTURE_AVIF:"EXT_texture_avif",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression",EXT_MESH_GPU_INSTANCING:"EXT_mesh_gpu_instancing"};class Z0{constructor(A){this.parser=A,this.name=XA.KHR_LIGHTS_PUNCTUAL,this.cache={refs:{},uses:{}}}_markDefs(){const A=this.parser,e=this.parser.json.nodes||[];for(let t=0,n=e.length;t<n;t++){const s=e[t];s.extensions&&s.extensions[this.name]&&s.extensions[this.name].light!==void 0&&A._addNodeRef(this.cache,s.extensions[this.name].light)}}_loadLight(A){const e=this.parser,t="light:"+A;let n=e.cache.get(t);if(n)return n;const s=e.json,a=((s.extensions&&s.extensions[this.name]||{}).lights||[])[A];let g;const I=new GA(16777215);a.color!==void 0&&I.setRGB(a.color[0],a.color[1],a.color[2],be);const E=a.range!==void 0?a.range:0;switch(a.type){case"directional":g=new tc(I),g.target.position.set(0,0,-1),g.add(g.target);break;case"point":g=new Ac(I),g.distance=E;break;case"spot":g=new jB(I),g.distance=E,a.spot=a.spot||{},a.spot.innerConeAngle=a.spot.innerConeAngle!==void 0?a.spot.innerConeAngle:0,a.spot.outerConeAngle=a.spot.outerConeAngle!==void 0?a.spot.outerConeAngle:Math.PI/4,g.angle=a.spot.outerConeAngle,g.penumbra=1-a.spot.innerConeAngle/a.spot.outerConeAngle,g.target.position.set(0,0,-1),g.add(g.target);break;default:throw new Error("THREE.GLTFLoader: Unexpected light type: "+a.type)}return g.position.set(0,0,0),g.decay=2,kt(g,a),a.intensity!==void 0&&(g.intensity=a.intensity),g.name=e.createUniqueName(a.name||"light_"+A),n=Promise.resolve(g),e.cache.add(t,n),n}getDependency(A,e){if(A==="light")return this._loadLight(e)}createNodeAttachment(A){const e=this,t=this.parser,s=t.json.nodes[A],r=(s.extensions&&s.extensions[this.name]||{}).light;return r===void 0?null:this._loadLight(r).then(function(a){return t._getNodeRef(e.cache,r,a)})}}class j0{constructor(){this.name=XA.KHR_MATERIALS_UNLIT}getMaterialType(){return tt}extendParams(A,e,t){const n=[];A.color=new GA(1,1,1),A.opacity=1;const s=e.pbrMetallicRoughness;if(s){if(Array.isArray(s.baseColorFactor)){const o=s.baseColorFactor;A.color.setRGB(o[0],o[1],o[2],be),A.opacity=o[3]}s.baseColorTexture!==void 0&&n.push(t.assignTexture(A,"map",s.baseColorTexture,De))}return Promise.all(n)}}class $0{constructor(A){this.parser=A,this.name=XA.KHR_MATERIALS_EMISSIVE_STRENGTH}extendMaterialParams(A,e){const n=this.parser.json.materials[A];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const s=n.extensions[this.name].emissiveStrength;return s!==void 0&&(e.emissiveIntensity=s),Promise.resolve()}}class AD{constructor(A){this.parser=A,this.name=XA.KHR_MATERIALS_CLEARCOAT}getMaterialType(A){const t=this.parser.json.materials[A];return!t.extensions||!t.extensions[this.name]?null:Mt}extendMaterialParams(A,e){const t=this.parser,n=t.json.materials[A];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const s=[],o=n.extensions[this.name];if(o.clearcoatFactor!==void 0&&(e.clearcoat=o.clearcoatFactor),o.clearcoatTexture!==void 0&&s.push(t.assignTexture(e,"clearcoatMap",o.clearcoatTexture)),o.clearcoatRoughnessFactor!==void 0&&(e.clearcoatRoughness=o.clearcoatRoughnessFactor),o.clearcoatRoughnessTexture!==void 0&&s.push(t.assignTexture(e,"clearcoatRoughnessMap",o.clearcoatRoughnessTexture)),o.clearcoatNormalTexture!==void 0&&(s.push(t.assignTexture(e,"clearcoatNormalMap",o.clearcoatNormalTexture)),o.clearcoatNormalTexture.scale!==void 0)){const r=o.clearcoatNormalTexture.scale;e.clearcoatNormalScale=new bA(r,r)}return Promise.all(s)}}class eD{constructor(A){this.parser=A,this.name=XA.KHR_MATERIALS_DISPERSION}getMaterialType(A){const t=this.parser.json.materials[A];return!t.extensions||!t.extensions[this.name]?null:Mt}extendMaterialParams(A,e){const n=this.parser.json.materials[A];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const s=n.extensions[this.name];return e.dispersion=s.dispersion!==void 0?s.dispersion:0,Promise.resolve()}}class tD{constructor(A){this.parser=A,this.name=XA.KHR_MATERIALS_IRIDESCENCE}getMaterialType(A){const t=this.parser.json.materials[A];return!t.extensions||!t.extensions[this.name]?null:Mt}extendMaterialParams(A,e){const t=this.parser,n=t.json.materials[A];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const s=[],o=n.extensions[this.name];return o.iridescenceFactor!==void 0&&(e.iridescence=o.iridescenceFactor),o.iridescenceTexture!==void 0&&s.push(t.assignTexture(e,"iridescenceMap",o.iridescenceTexture)),o.iridescenceIor!==void 0&&(e.iridescenceIOR=o.iridescenceIor),e.iridescenceThicknessRange===void 0&&(e.iridescenceThicknessRange=[100,400]),o.iridescenceThicknessMinimum!==void 0&&(e.iridescenceThicknessRange[0]=o.iridescenceThicknessMinimum),o.iridescenceThicknessMaximum!==void 0&&(e.iridescenceThicknessRange[1]=o.iridescenceThicknessMaximum),o.iridescenceThicknessTexture!==void 0&&s.push(t.assignTexture(e,"iridescenceThicknessMap",o.iridescenceThicknessTexture)),Promise.all(s)}}class iD{constructor(A){this.parser=A,this.name=XA.KHR_MATERIALS_SHEEN}getMaterialType(A){const t=this.parser.json.materials[A];return!t.extensions||!t.extensions[this.name]?null:Mt}extendMaterialParams(A,e){const t=this.parser,n=t.json.materials[A];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const s=[];e.sheenColor=new GA(0,0,0),e.sheenRoughness=0,e.sheen=1;const o=n.extensions[this.name];if(o.sheenColorFactor!==void 0){const r=o.sheenColorFactor;e.sheenColor.setRGB(r[0],r[1],r[2],be)}return o.sheenRoughnessFactor!==void 0&&(e.sheenRoughness=o.sheenRoughnessFactor),o.sheenColorTexture!==void 0&&s.push(t.assignTexture(e,"sheenColorMap",o.sheenColorTexture,De)),o.sheenRoughnessTexture!==void 0&&s.push(t.assignTexture(e,"sheenRoughnessMap",o.sheenRoughnessTexture)),Promise.all(s)}}class nD{constructor(A){this.parser=A,this.name=XA.KHR_MATERIALS_TRANSMISSION}getMaterialType(A){const t=this.parser.json.materials[A];return!t.extensions||!t.extensions[this.name]?null:Mt}extendMaterialParams(A,e){const t=this.parser,n=t.json.materials[A];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const s=[],o=n.extensions[this.name];return o.transmissionFactor!==void 0&&(e.transmission=o.transmissionFactor),o.transmissionTexture!==void 0&&s.push(t.assignTexture(e,"transmissionMap",o.transmissionTexture)),Promise.all(s)}}class sD{constructor(A){this.parser=A,this.name=XA.KHR_MATERIALS_VOLUME}getMaterialType(A){const t=this.parser.json.materials[A];return!t.extensions||!t.extensions[this.name]?null:Mt}extendMaterialParams(A,e){const t=this.parser,n=t.json.materials[A];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const s=[],o=n.extensions[this.name];e.thickness=o.thicknessFactor!==void 0?o.thicknessFactor:0,o.thicknessTexture!==void 0&&s.push(t.assignTexture(e,"thicknessMap",o.thicknessTexture)),e.attenuationDistance=o.attenuationDistance||1/0;const r=o.attenuationColor||[1,1,1];return e.attenuationColor=new GA().setRGB(r[0],r[1],r[2],be),Promise.all(s)}}class oD{constructor(A){this.parser=A,this.name=XA.KHR_MATERIALS_IOR}getMaterialType(A){const t=this.parser.json.materials[A];return!t.extensions||!t.extensions[this.name]?null:Mt}extendMaterialParams(A,e){const n=this.parser.json.materials[A];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const s=n.extensions[this.name];return e.ior=s.ior!==void 0?s.ior:1.5,Promise.resolve()}}class rD{constructor(A){this.parser=A,this.name=XA.KHR_MATERIALS_SPECULAR}getMaterialType(A){const t=this.parser.json.materials[A];return!t.extensions||!t.extensions[this.name]?null:Mt}extendMaterialParams(A,e){const t=this.parser,n=t.json.materials[A];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const s=[],o=n.extensions[this.name];e.specularIntensity=o.specularFactor!==void 0?o.specularFactor:1,o.specularTexture!==void 0&&s.push(t.assignTexture(e,"specularIntensityMap",o.specularTexture));const r=o.specularColorFactor||[1,1,1];return e.specularColor=new GA().setRGB(r[0],r[1],r[2],be),o.specularColorTexture!==void 0&&s.push(t.assignTexture(e,"specularColorMap",o.specularColorTexture,De)),Promise.all(s)}}class aD{constructor(A){this.parser=A,this.name=XA.EXT_MATERIALS_BUMP}getMaterialType(A){const t=this.parser.json.materials[A];return!t.extensions||!t.extensions[this.name]?null:Mt}extendMaterialParams(A,e){const t=this.parser,n=t.json.materials[A];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const s=[],o=n.extensions[this.name];return e.bumpScale=o.bumpFactor!==void 0?o.bumpFactor:1,o.bumpTexture!==void 0&&s.push(t.assignTexture(e,"bumpMap",o.bumpTexture)),Promise.all(s)}}class gD{constructor(A){this.parser=A,this.name=XA.KHR_MATERIALS_ANISOTROPY}getMaterialType(A){const t=this.parser.json.materials[A];return!t.extensions||!t.extensions[this.name]?null:Mt}extendMaterialParams(A,e){const t=this.parser,n=t.json.materials[A];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const s=[],o=n.extensions[this.name];return o.anisotropyStrength!==void 0&&(e.anisotropy=o.anisotropyStrength),o.anisotropyRotation!==void 0&&(e.anisotropyRotation=o.anisotropyRotation),o.anisotropyTexture!==void 0&&s.push(t.assignTexture(e,"anisotropyMap",o.anisotropyTexture)),Promise.all(s)}}class ID{constructor(A){this.parser=A,this.name=XA.KHR_TEXTURE_BASISU}loadTexture(A){const e=this.parser,t=e.json,n=t.textures[A];if(!n.extensions||!n.extensions[this.name])return null;const s=n.extensions[this.name],o=e.options.ktx2Loader;if(!o){if(t.extensionsRequired&&t.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return e.loadTextureImage(A,s.source,o)}}class ED{constructor(A){this.parser=A,this.name=XA.EXT_TEXTURE_WEBP,this.isSupported=null}loadTexture(A){const e=this.name,t=this.parser,n=t.json,s=n.textures[A];if(!s.extensions||!s.extensions[e])return null;const o=s.extensions[e],r=n.images[o.source];let a=t.textureLoader;if(r.uri){const g=t.options.manager.getHandler(r.uri);g!==null&&(a=g)}return this.detectSupport().then(function(g){if(g)return t.loadTextureImage(A,o.source,a);if(n.extensionsRequired&&n.extensionsRequired.indexOf(e)>=0)throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");return t.loadTexture(A)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(A){const e=new Image;e.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",e.onload=e.onerror=function(){A(e.height===1)}})),this.isSupported}}class CD{constructor(A){this.parser=A,this.name=XA.EXT_TEXTURE_AVIF,this.isSupported=null}loadTexture(A){const e=this.name,t=this.parser,n=t.json,s=n.textures[A];if(!s.extensions||!s.extensions[e])return null;const o=s.extensions[e],r=n.images[o.source];let a=t.textureLoader;if(r.uri){const g=t.options.manager.getHandler(r.uri);g!==null&&(a=g)}return this.detectSupport().then(function(g){if(g)return t.loadTextureImage(A,o.source,a);if(n.extensionsRequired&&n.extensionsRequired.indexOf(e)>=0)throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");return t.loadTexture(A)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(A){const e=new Image;e.src="data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=",e.onload=e.onerror=function(){A(e.height===1)}})),this.isSupported}}class QD{constructor(A){this.name=XA.EXT_MESHOPT_COMPRESSION,this.parser=A}loadBufferView(A){const e=this.parser.json,t=e.bufferViews[A];if(t.extensions&&t.extensions[this.name]){const n=t.extensions[this.name],s=this.parser.getDependency("buffer",n.buffer),o=this.parser.options.meshoptDecoder;if(!o||!o.supported){if(e.extensionsRequired&&e.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return s.then(function(r){const a=n.byteOffset||0,g=n.byteLength||0,I=n.count,E=n.byteStride,C=new Uint8Array(r,a,g);return o.decodeGltfBufferAsync?o.decodeGltfBufferAsync(I,E,C,n.mode,n.filter).then(function(Q){return Q.buffer}):o.ready.then(function(){const Q=new ArrayBuffer(I*E);return o.decodeGltfBuffer(new Uint8Array(Q),I,E,C,n.mode,n.filter),Q})})}else return null}}class BD{constructor(A){this.name=XA.EXT_MESH_GPU_INSTANCING,this.parser=A}createNodeMesh(A){const e=this.parser.json,t=e.nodes[A];if(!t.extensions||!t.extensions[this.name]||t.mesh===void 0)return null;const n=e.meshes[t.mesh];for(const g of n.primitives)if(g.mode!==At.TRIANGLES&&g.mode!==At.TRIANGLE_STRIP&&g.mode!==At.TRIANGLE_FAN&&g.mode!==void 0)return null;const o=t.extensions[this.name].attributes,r=[],a={};for(const g in o)r.push(this.parser.getDependency("accessor",o[g]).then(I=>(a[g]=I,a[g])));return r.length<1?null:(r.push(this.parser.createNodeMesh(A)),Promise.all(r).then(g=>{const I=g.pop(),E=I.isGroup?I.children:[I],C=g[0].count,Q=[];for(const h of E){const l=new UA,B=new L,c=new Ii,R=new L(1,1,1),p=new FB(h.geometry,h.material,C);for(let d=0;d<C;d++)a.TRANSLATION&&B.fromBufferAttribute(a.TRANSLATION,d),a.ROTATION&&c.fromBufferAttribute(a.ROTATION,d),a.SCALE&&R.fromBufferAttribute(a.SCALE,d),p.setMatrixAt(d,l.compose(B,c,R));for(const d in a)if(d==="_COLOR_0"){const w=a[d];p.instanceColor=new qs(w.array,w.itemSize,w.normalized)}else d!=="TRANSLATION"&&d!=="ROTATION"&&d!=="SCALE"&&h.geometry.setAttribute(d,a[d]);Be.prototype.copy.call(p,h),this.parser.assignFinalMaterial(p),Q.push(p)}return I.isGroup?(I.clear(),I.add(...Q),I):Q[0]}))}}const GC="glTF",Nn=12,ZI={JSON:1313821514,BIN:5130562};class cD{constructor(A){this.name=XA.KHR_BINARY_GLTF,this.content=null,this.body=null;const e=new DataView(A,0,Nn),t=new TextDecoder;if(this.header={magic:t.decode(new Uint8Array(A.slice(0,4))),version:e.getUint32(4,!0),length:e.getUint32(8,!0)},this.header.magic!==GC)throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("THREE.GLTFLoader: Legacy binary file detected.");const n=this.header.length-Nn,s=new DataView(A,Nn);let o=0;for(;o<n;){const r=s.getUint32(o,!0);o+=4;const a=s.getUint32(o,!0);if(o+=4,a===ZI.JSON){const g=new Uint8Array(A,Nn+o,r);this.content=t.decode(g)}else if(a===ZI.BIN){const g=Nn+o;this.body=A.slice(g,g+r)}o+=r}if(this.content===null)throw new Error("THREE.GLTFLoader: JSON content not found.")}}class hD{constructor(A,e){if(!e)throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=XA.KHR_DRACO_MESH_COMPRESSION,this.json=A,this.dracoLoader=e,this.dracoLoader.preload()}decodePrimitive(A,e){const t=this.json,n=this.dracoLoader,s=A.extensions[this.name].bufferView,o=A.extensions[this.name].attributes,r={},a={},g={};for(const I in o){const E=ta[I]||I.toLowerCase();r[E]=o[I]}for(const I in A.attributes){const E=ta[I]||I.toLowerCase();if(o[I]!==void 0){const C=t.accessors[A.attributes[I]],Q=tn[C.componentType];g[E]=Q.name,a[E]=C.normalized===!0}}return e.getDependency("bufferView",s).then(function(I){return new Promise(function(E,C){n.decodeDracoFile(I,function(Q){for(const h in Q.attributes){const l=Q.attributes[h],B=a[h];B!==void 0&&(l.normalized=B)}E(Q)},r,g,be,C)})})}}class lD{constructor(){this.name=XA.KHR_TEXTURE_TRANSFORM}extendTexture(A,e){return(e.texCoord===void 0||e.texCoord===A.channel)&&e.offset===void 0&&e.rotation===void 0&&e.scale===void 0||(A=A.clone(),e.texCoord!==void 0&&(A.channel=e.texCoord),e.offset!==void 0&&A.offset.fromArray(e.offset),e.rotation!==void 0&&(A.rotation=e.rotation),e.scale!==void 0&&A.repeat.fromArray(e.scale),A.needsUpdate=!0),A}}class dD{constructor(){this.name=XA.KHR_MESH_QUANTIZATION}}class vC extends zn{constructor(A,e,t,n){super(A,e,t,n)}copySampleValue_(A){const e=this.resultBuffer,t=this.sampleValues,n=this.valueSize,s=A*n*3+n;for(let o=0;o!==n;o++)e[o]=t[s+o];return e}interpolate_(A,e,t,n){const s=this.resultBuffer,o=this.sampleValues,r=this.valueSize,a=r*2,g=r*3,I=n-e,E=(t-e)/I,C=E*E,Q=C*E,h=A*g,l=h-g,B=-2*Q+3*C,c=Q-C,R=1-B,p=c-C+E;for(let d=0;d!==r;d++){const w=o[l+d+r],S=o[l+d+a]*I,F=o[h+d+r],N=o[h+d]*I;s[d]=R*w+p*S+B*F+c*N}return s}}const uD=new Ii;class fD extends vC{interpolate_(A,e,t,n){const s=super.interpolate_(A,e,t,n);return uD.fromArray(s).normalize().toArray(s),s}}const At={POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6},tn={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},jI={9728:Te,9729:ze,9984:rE,9985:Ls,9986:xn,9987:Ot},$I={33071:ni,33648:Js,10497:rn},tr={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},ta={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",TEXCOORD_0:"uv",TEXCOORD_1:"uv1",TEXCOORD_2:"uv2",TEXCOORD_3:"uv3",COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},ei={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},pD={CUBICSPLINE:void 0,LINEAR:On,STEP:Pn},ir={OPAQUE:"OPAQUE",MASK:"MASK",BLEND:"BLEND"};function DD(i){return i.DefaultMaterial===void 0&&(i.DefaultMaterial=new io({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:ft})),i.DefaultMaterial}function fi(i,A,e){for(const t in e.extensions)i[t]===void 0&&(A.userData.gltfExtensions=A.userData.gltfExtensions||{},A.userData.gltfExtensions[t]=e.extensions[t])}function kt(i,A){A.extras!==void 0&&(typeof A.extras=="object"?Object.assign(i.userData,A.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+A.extras))}function mD(i,A,e){let t=!1,n=!1,s=!1;for(let g=0,I=A.length;g<I;g++){const E=A[g];if(E.POSITION!==void 0&&(t=!0),E.NORMAL!==void 0&&(n=!0),E.COLOR_0!==void 0&&(s=!0),t&&n&&s)break}if(!t&&!n&&!s)return Promise.resolve(i);const o=[],r=[],a=[];for(let g=0,I=A.length;g<I;g++){const E=A[g];if(t){const C=E.POSITION!==void 0?e.getDependency("accessor",E.POSITION):i.attributes.position;o.push(C)}if(n){const C=E.NORMAL!==void 0?e.getDependency("accessor",E.NORMAL):i.attributes.normal;r.push(C)}if(s){const C=E.COLOR_0!==void 0?e.getDependency("accessor",E.COLOR_0):i.attributes.color;a.push(C)}}return Promise.all([Promise.all(o),Promise.all(r),Promise.all(a)]).then(function(g){const I=g[0],E=g[1],C=g[2];return t&&(i.morphAttributes.position=I),n&&(i.morphAttributes.normal=E),s&&(i.morphAttributes.color=C),i.morphTargetsRelative=!0,i})}function yD(i,A){if(i.updateMorphTargets(),A.weights!==void 0)for(let e=0,t=A.weights.length;e<t;e++)i.morphTargetInfluences[e]=A.weights[e];if(A.extras&&Array.isArray(A.extras.targetNames)){const e=A.extras.targetNames;if(i.morphTargetInfluences.length===e.length){i.morphTargetDictionary={};for(let t=0,n=e.length;t<n;t++)i.morphTargetDictionary[e[t]]=t}else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}function RD(i){let A;const e=i.extensions&&i.extensions[XA.KHR_DRACO_MESH_COMPRESSION];if(e?A="draco:"+e.bufferView+":"+e.indices+":"+nr(e.attributes):A=i.indices+":"+nr(i.attributes)+":"+i.mode,i.targets!==void 0)for(let t=0,n=i.targets.length;t<n;t++)A+=":"+nr(i.targets[t]);return A}function nr(i){let A="";const e=Object.keys(i).sort();for(let t=0,n=e.length;t<n;t++)A+=e[t]+":"+i[e[t]]+";";return A}function ia(i){switch(i){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")}}function wD(i){return i.search(/\.jpe?g($|\?)/i)>0||i.search(/^data\:image\/jpeg/)===0?"image/jpeg":i.search(/\.webp($|\?)/i)>0||i.search(/^data\:image\/webp/)===0?"image/webp":i.search(/\.ktx2($|\?)/i)>0||i.search(/^data\:image\/ktx2/)===0?"image/ktx2":"image/png"}const SD=new UA;class MD{constructor(A={},e={}){this.json=A,this.extensions={},this.plugins={},this.options=e,this.cache=new X0,this.associations=new Map,this.primitiveCache={},this.nodeCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.sourceCache={},this.textureCache={},this.nodeNamesUsed={};let t=!1,n=-1,s=!1,o=-1;if(typeof navigator<"u"){const r=navigator.userAgent;t=/^((?!chrome|android).)*safari/i.test(r)===!0;const a=r.match(/Version\/(\d+)/);n=t&&a?parseInt(a[1],10):-1,s=r.indexOf("Firefox")>-1,o=s?r.match(/Firefox\/([0-9]+)\./)[1]:-1}typeof createImageBitmap>"u"||t&&n<17||s&&o<98?this.textureLoader=new XB(this.options.manager):this.textureLoader=new ic(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.textureLoader.setRequestHeader(this.options.requestHeader),this.fileLoader=new TE(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),this.options.crossOrigin==="use-credentials"&&this.fileLoader.setWithCredentials(!0)}setExtensions(A){this.extensions=A}setPlugins(A){this.plugins=A}parse(A,e){const t=this,n=this.json,s=this.extensions;this.cache.removeAll(),this.nodeCache={},this._invokeAll(function(o){return o._markDefs&&o._markDefs()}),Promise.all(this._invokeAll(function(o){return o.beforeRoot&&o.beforeRoot()})).then(function(){return Promise.all([t.getDependencies("scene"),t.getDependencies("animation"),t.getDependencies("camera")])}).then(function(o){const r={scene:o[0][n.scene||0],scenes:o[0],animations:o[1],cameras:o[2],asset:n.asset,parser:t,userData:{}};return fi(s,r,n),kt(r,n),Promise.all(t._invokeAll(function(a){return a.afterRoot&&a.afterRoot(r)})).then(function(){for(const a of r.scenes)a.updateMatrixWorld();A(r)})}).catch(e)}_markDefs(){const A=this.json.nodes||[],e=this.json.skins||[],t=this.json.meshes||[];for(let n=0,s=e.length;n<s;n++){const o=e[n].joints;for(let r=0,a=o.length;r<a;r++)A[o[r]].isBone=!0}for(let n=0,s=A.length;n<s;n++){const o=A[n];o.mesh!==void 0&&(this._addNodeRef(this.meshCache,o.mesh),o.skin!==void 0&&(t[o.mesh].isSkinnedMesh=!0)),o.camera!==void 0&&this._addNodeRef(this.cameraCache,o.camera)}}_addNodeRef(A,e){e!==void 0&&(A.refs[e]===void 0&&(A.refs[e]=A.uses[e]=0),A.refs[e]++)}_getNodeRef(A,e,t){if(A.refs[e]<=1)return t;const n=t.clone(),s=(o,r)=>{const a=this.associations.get(o);a!=null&&this.associations.set(r,a);for(const[g,I]of o.children.entries())s(I,r.children[g])};return s(t,n),n.name+="_instance_"+A.uses[e]++,n}_invokeOne(A){const e=Object.values(this.plugins);e.push(this);for(let t=0;t<e.length;t++){const n=A(e[t]);if(n)return n}return null}_invokeAll(A){const e=Object.values(this.plugins);e.unshift(this);const t=[];for(let n=0;n<e.length;n++){const s=A(e[n]);s&&t.push(s)}return t}getDependency(A,e){const t=A+":"+e;let n=this.cache.get(t);if(!n){switch(A){case"scene":n=this.loadScene(e);break;case"node":n=this._invokeOne(function(s){return s.loadNode&&s.loadNode(e)});break;case"mesh":n=this._invokeOne(function(s){return s.loadMesh&&s.loadMesh(e)});break;case"accessor":n=this.loadAccessor(e);break;case"bufferView":n=this._invokeOne(function(s){return s.loadBufferView&&s.loadBufferView(e)});break;case"buffer":n=this.loadBuffer(e);break;case"material":n=this._invokeOne(function(s){return s.loadMaterial&&s.loadMaterial(e)});break;case"texture":n=this._invokeOne(function(s){return s.loadTexture&&s.loadTexture(e)});break;case"skin":n=this.loadSkin(e);break;case"animation":n=this._invokeOne(function(s){return s.loadAnimation&&s.loadAnimation(e)});break;case"camera":n=this.loadCamera(e);break;default:if(n=this._invokeOne(function(s){return s!=this&&s.getDependency&&s.getDependency(A,e)}),!n)throw new Error("Unknown type: "+A);break}this.cache.add(t,n)}return n}getDependencies(A){let e=this.cache.get(A);if(!e){const t=this,n=this.json[A+(A==="mesh"?"es":"s")]||[];e=Promise.all(n.map(function(s,o){return t.getDependency(A,o)})),this.cache.add(A,e)}return e}loadBuffer(A){const e=this.json.buffers[A],t=this.fileLoader;if(e.type&&e.type!=="arraybuffer")throw new Error("THREE.GLTFLoader: "+e.type+" buffer type is not supported.");if(e.uri===void 0&&A===0)return Promise.resolve(this.extensions[XA.KHR_BINARY_GLTF].body);const n=this.options;return new Promise(function(s,o){t.load(Tn.resolveURL(e.uri,n.path),s,void 0,function(){o(new Error('THREE.GLTFLoader: Failed to load buffer "'+e.uri+'".'))})})}loadBufferView(A){const e=this.json.bufferViews[A];return this.getDependency("buffer",e.buffer).then(function(t){const n=e.byteLength||0,s=e.byteOffset||0;return t.slice(s,s+n)})}loadAccessor(A){const e=this,t=this.json,n=this.json.accessors[A];if(n.bufferView===void 0&&n.sparse===void 0){const o=tr[n.type],r=tn[n.componentType],a=n.normalized===!0,g=new r(n.count*o);return Promise.resolve(new Qe(g,o,a))}const s=[];return n.bufferView!==void 0?s.push(this.getDependency("bufferView",n.bufferView)):s.push(null),n.sparse!==void 0&&(s.push(this.getDependency("bufferView",n.sparse.indices.bufferView)),s.push(this.getDependency("bufferView",n.sparse.values.bufferView))),Promise.all(s).then(function(o){const r=o[0],a=tr[n.type],g=tn[n.componentType],I=g.BYTES_PER_ELEMENT,E=I*a,C=n.byteOffset||0,Q=n.bufferView!==void 0?t.bufferViews[n.bufferView].byteStride:void 0,h=n.normalized===!0;let l,B;if(Q&&Q!==E){const c=Math.floor(C/Q),R="InterleavedBuffer:"+n.bufferView+":"+n.componentType+":"+c+":"+n.count;let p=e.cache.get(R);p||(l=new g(r,c*Q,n.count*Q/I),p=new wB(l,Q/I),e.cache.add(R,p)),B=new ca(p,a,C%Q/I,h)}else r===null?l=new g(n.count*a):l=new g(r,C,n.count*a),B=new Qe(l,a,h);if(n.sparse!==void 0){const c=tr.SCALAR,R=tn[n.sparse.indices.componentType],p=n.sparse.indices.byteOffset||0,d=n.sparse.values.byteOffset||0,w=new R(o[1],p,n.sparse.count*c),S=new g(o[2],d,n.sparse.count*a);r!==null&&(B=new Qe(B.array.slice(),B.itemSize,B.normalized)),B.normalized=!1;for(let F=0,N=w.length;F<N;F++){const u=w[F];if(B.setX(u,S[F*a]),a>=2&&B.setY(u,S[F*a+1]),a>=3&&B.setZ(u,S[F*a+2]),a>=4&&B.setW(u,S[F*a+3]),a>=5)throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")}B.normalized=h}return B})}loadTexture(A){const e=this.json,t=this.options,s=e.textures[A].source,o=e.images[s];let r=this.textureLoader;if(o.uri){const a=t.manager.getHandler(o.uri);a!==null&&(r=a)}return this.loadTextureImage(A,s,r)}loadTextureImage(A,e,t){const n=this,s=this.json,o=s.textures[A],r=s.images[e],a=(r.uri||r.bufferView)+":"+o.sampler;if(this.textureCache[a])return this.textureCache[a];const g=this.loadImageSource(e,t).then(function(I){I.flipY=!1,I.name=o.name||r.name||"",I.name===""&&typeof r.uri=="string"&&r.uri.startsWith("data:image/")===!1&&(I.name=r.uri);const C=(s.samplers||{})[o.sampler]||{};return I.magFilter=jI[C.magFilter]||ze,I.minFilter=jI[C.minFilter]||Ot,I.wrapS=$I[C.wrapS]||rn,I.wrapT=$I[C.wrapT]||rn,I.generateMipmaps=!I.isCompressedTexture&&I.minFilter!==Te&&I.minFilter!==ze,n.associations.set(I,{textures:A}),I}).catch(function(){return null});return this.textureCache[a]=g,g}loadImageSource(A,e){const t=this,n=this.json,s=this.options;if(this.sourceCache[A]!==void 0)return this.sourceCache[A].then(E=>E.clone());const o=n.images[A],r=self.URL||self.webkitURL;let a=o.uri||"",g=!1;if(o.bufferView!==void 0)a=t.getDependency("bufferView",o.bufferView).then(function(E){g=!0;const C=new Blob([E],{type:o.mimeType});return a=r.createObjectURL(C),a});else if(o.uri===void 0)throw new Error("THREE.GLTFLoader: Image "+A+" is missing URI and bufferView");const I=Promise.resolve(a).then(function(E){return new Promise(function(C,Q){let h=C;e.isImageBitmapLoader===!0&&(h=function(l){const B=new de(l);B.needsUpdate=!0,C(B)}),e.load(Tn.resolveURL(E,s.path),h,void 0,Q)})}).then(function(E){return g===!0&&r.revokeObjectURL(a),kt(E,o),E.userData.mimeType=o.mimeType||wD(o.uri),E}).catch(function(E){throw console.error("THREE.GLTFLoader: Couldn't load texture",a),E});return this.sourceCache[A]=I,I}assignTexture(A,e,t,n){const s=this;return this.getDependency("texture",t.index).then(function(o){if(!o)return null;if(t.texCoord!==void 0&&t.texCoord>0&&(o=o.clone(),o.channel=t.texCoord),s.extensions[XA.KHR_TEXTURE_TRANSFORM]){const r=t.extensions!==void 0?t.extensions[XA.KHR_TEXTURE_TRANSFORM]:void 0;if(r){const a=s.associations.get(o);o=s.extensions[XA.KHR_TEXTURE_TRANSFORM].extendTexture(o,r),s.associations.set(o,a)}}return n!==void 0&&(o.colorSpace=n),A[e]=o,o})}assignFinalMaterial(A){const e=A.geometry;let t=A.material;const n=e.attributes.tangent===void 0,s=e.attributes.color!==void 0,o=e.attributes.normal===void 0;if(A.isPoints){const r="PointsMaterial:"+t.uuid;let a=this.cache.get(r);a||(a=new FE,ut.prototype.copy.call(a,t),a.color.copy(t.color),a.map=t.map,a.sizeAttenuation=!1,this.cache.add(r,a)),t=a}else if(A.isLine){const r="LineBasicMaterial:"+t.uuid;let a=this.cache.get(r);a||(a=new la,ut.prototype.copy.call(a,t),a.color.copy(t.color),a.map=t.map,this.cache.add(r,a)),t=a}if(n||s||o){let r="ClonedMaterial:"+t.uuid+":";n&&(r+="derivative-tangents:"),s&&(r+="vertex-colors:"),o&&(r+="flat-shading:");let a=this.cache.get(r);a||(a=t.clone(),s&&(a.vertexColors=!0),o&&(a.flatShading=!0),n&&(a.normalScale&&(a.normalScale.y*=-1),a.clearcoatNormalScale&&(a.clearcoatNormalScale.y*=-1)),this.cache.add(r,a),this.associations.set(a,this.associations.get(t))),t=a}A.material=t}getMaterialType(){return io}loadMaterial(A){const e=this,t=this.json,n=this.extensions,s=t.materials[A];let o;const r={},a=s.extensions||{},g=[];if(a[XA.KHR_MATERIALS_UNLIT]){const E=n[XA.KHR_MATERIALS_UNLIT];o=E.getMaterialType(),g.push(E.extendParams(r,s,e))}else{const E=s.pbrMetallicRoughness||{};if(r.color=new GA(1,1,1),r.opacity=1,Array.isArray(E.baseColorFactor)){const C=E.baseColorFactor;r.color.setRGB(C[0],C[1],C[2],be),r.opacity=C[3]}E.baseColorTexture!==void 0&&g.push(e.assignTexture(r,"map",E.baseColorTexture,De)),r.metalness=E.metallicFactor!==void 0?E.metallicFactor:1,r.roughness=E.roughnessFactor!==void 0?E.roughnessFactor:1,E.metallicRoughnessTexture!==void 0&&(g.push(e.assignTexture(r,"metalnessMap",E.metallicRoughnessTexture)),g.push(e.assignTexture(r,"roughnessMap",E.metallicRoughnessTexture))),o=this._invokeOne(function(C){return C.getMaterialType&&C.getMaterialType(A)}),g.push(Promise.all(this._invokeAll(function(C){return C.extendMaterialParams&&C.extendMaterialParams(A,r)})))}s.doubleSided===!0&&(r.side=Bt);const I=s.alphaMode||ir.OPAQUE;if(I===ir.BLEND?(r.transparent=!0,r.depthWrite=!1):(r.transparent=!1,I===ir.MASK&&(r.alphaTest=s.alphaCutoff!==void 0?s.alphaCutoff:.5)),s.normalTexture!==void 0&&o!==tt&&(g.push(e.assignTexture(r,"normalMap",s.normalTexture)),r.normalScale=new bA(1,1),s.normalTexture.scale!==void 0)){const E=s.normalTexture.scale;r.normalScale.set(E,E)}if(s.occlusionTexture!==void 0&&o!==tt&&(g.push(e.assignTexture(r,"aoMap",s.occlusionTexture)),s.occlusionTexture.strength!==void 0&&(r.aoMapIntensity=s.occlusionTexture.strength)),s.emissiveFactor!==void 0&&o!==tt){const E=s.emissiveFactor;r.emissive=new GA().setRGB(E[0],E[1],E[2],be)}return s.emissiveTexture!==void 0&&o!==tt&&g.push(e.assignTexture(r,"emissiveMap",s.emissiveTexture,De)),Promise.all(g).then(function(){const E=new o(r);return s.name&&(E.name=s.name),kt(E,s),e.associations.set(E,{materials:A}),s.extensions&&fi(n,E,s),E})}createUniqueName(A){const e=ae.sanitizeNodeName(A||"");return e in this.nodeNamesUsed?e+"_"+ ++this.nodeNamesUsed[e]:(this.nodeNamesUsed[e]=0,e)}loadGeometries(A){const e=this,t=this.extensions,n=this.primitiveCache;function s(r){return t[XA.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(r,e).then(function(a){return AE(a,r,e)})}const o=[];for(let r=0,a=A.length;r<a;r++){const g=A[r],I=RD(g),E=n[I];if(E)o.push(E.promise);else{let C;g.extensions&&g.extensions[XA.KHR_DRACO_MESH_COMPRESSION]?C=s(g):C=AE(new Xe,g,e),n[I]={primitive:g,promise:C},o.push(C)}}return Promise.all(o)}loadMesh(A){const e=this,t=this.json,n=this.extensions,s=t.meshes[A],o=s.primitives,r=[];for(let a=0,g=o.length;a<g;a++){const I=o[a].material===void 0?DD(this.cache):this.getDependency("material",o[a].material);r.push(I)}return r.push(e.loadGeometries(o)),Promise.all(r).then(function(a){const g=a.slice(0,a.length-1),I=a[a.length-1],E=[];for(let Q=0,h=I.length;Q<h;Q++){const l=I[Q],B=o[Q];let c;const R=g[Q];if(B.mode===At.TRIANGLES||B.mode===At.TRIANGLE_STRIP||B.mode===At.TRIANGLE_FAN||B.mode===void 0)c=s.isSkinnedMesh===!0?new MB(l,R):new ve(l,R),c.isSkinnedMesh===!0&&c.normalizeSkinWeights(),B.mode===At.TRIANGLE_STRIP?c.geometry=XI(c.geometry,lE):B.mode===At.TRIANGLE_FAN&&(c.geometry=XI(c.geometry,Or));else if(B.mode===At.LINES)c=new xE(l,R);else if(B.mode===At.LINE_STRIP)c=new da(l,R);else if(B.mode===At.LINE_LOOP)c=new UB(l,R);else if(B.mode===At.POINTS)c=new GB(l,R);else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: "+B.mode);Object.keys(c.geometry.morphAttributes).length>0&&yD(c,s),c.name=e.createUniqueName(s.name||"mesh_"+A),kt(c,s),B.extensions&&fi(n,c,B),e.assignFinalMaterial(c),E.push(c)}for(let Q=0,h=E.length;Q<h;Q++)e.associations.set(E[Q],{meshes:A,primitives:Q});if(E.length===1)return s.extensions&&fi(n,E[0],s),E[0];const C=new yi;s.extensions&&fi(n,C,s),e.associations.set(C,{meshes:A});for(let Q=0,h=E.length;Q<h;Q++)C.add(E[Q]);return C})}loadCamera(A){let e;const t=this.json.cameras[A],n=t[t.type];if(!n){console.warn("THREE.GLTFLoader: Missing camera parameters.");return}return t.type==="perspective"?e=new Le(Qa.radToDeg(n.yfov),n.aspectRatio||1,n.znear||1,n.zfar||2e6):t.type==="orthographic"&&(e=new pa(-n.xmag,n.xmag,n.ymag,-n.ymag,n.znear,n.zfar)),t.name&&(e.name=this.createUniqueName(t.name)),kt(e,t),Promise.resolve(e)}loadSkin(A){const e=this.json.skins[A],t=[];for(let n=0,s=e.joints.length;n<s;n++)t.push(this._loadNodeShallow(e.joints[n]));return e.inverseBindMatrices!==void 0?t.push(this.getDependency("accessor",e.inverseBindMatrices)):t.push(null),Promise.all(t).then(function(n){const s=n.pop(),o=n,r=[],a=[];for(let g=0,I=o.length;g<I;g++){const E=o[g];if(E){r.push(E);const C=new UA;s!==null&&C.fromArray(s.array,g*16),a.push(C)}else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',e.joints[g])}return new ha(r,a)})}loadAnimation(A){const e=this.json,t=this,n=e.animations[A],s=n.name?n.name:"animation_"+A,o=[],r=[],a=[],g=[],I=[];for(let E=0,C=n.channels.length;E<C;E++){const Q=n.channels[E],h=n.samplers[Q.sampler],l=Q.target,B=l.node,c=n.parameters!==void 0?n.parameters[h.input]:h.input,R=n.parameters!==void 0?n.parameters[h.output]:h.output;l.node!==void 0&&(o.push(this.getDependency("node",B)),r.push(this.getDependency("accessor",c)),a.push(this.getDependency("accessor",R)),g.push(h),I.push(l))}return Promise.all([Promise.all(o),Promise.all(r),Promise.all(a),Promise.all(g),Promise.all(I)]).then(function(E){const C=E[0],Q=E[1],h=E[2],l=E[3],B=E[4],c=[];for(let R=0,p=C.length;R<p;R++){const d=C[R],w=Q[R],S=h[R],F=l[R],N=B[R];if(d===void 0)continue;d.updateMatrix&&d.updateMatrix();const u=t._createAnimationTracks(d,w,S,F,N);if(u)for(let f=0;f<u.length;f++)c.push(u[f])}return new YB(s,void 0,c)})}createNodeMesh(A){const e=this.json,t=this,n=e.nodes[A];return n.mesh===void 0?null:t.getDependency("mesh",n.mesh).then(function(s){const o=t._getNodeRef(t.meshCache,n.mesh,s);return n.weights!==void 0&&o.traverse(function(r){if(r.isMesh)for(let a=0,g=n.weights.length;a<g;a++)r.morphTargetInfluences[a]=n.weights[a]}),o})}loadNode(A){const e=this.json,t=this,n=e.nodes[A],s=t._loadNodeShallow(A),o=[],r=n.children||[];for(let g=0,I=r.length;g<I;g++)o.push(t.getDependency("node",r[g]));const a=n.skin===void 0?Promise.resolve(null):t.getDependency("skin",n.skin);return Promise.all([s,Promise.all(o),a]).then(function(g){const I=g[0],E=g[1],C=g[2];C!==null&&I.traverse(function(Q){Q.isSkinnedMesh&&Q.bind(C,SD)});for(let Q=0,h=E.length;Q<h;Q++)I.add(E[Q]);return I})}_loadNodeShallow(A){const e=this.json,t=this.extensions,n=this;if(this.nodeCache[A]!==void 0)return this.nodeCache[A];const s=e.nodes[A],o=s.name?n.createUniqueName(s.name):"",r=[],a=n._invokeOne(function(g){return g.createNodeMesh&&g.createNodeMesh(A)});return a&&r.push(a),s.camera!==void 0&&r.push(n.getDependency("camera",s.camera).then(function(g){return n._getNodeRef(n.cameraCache,s.camera,g)})),n._invokeAll(function(g){return g.createNodeAttachment&&g.createNodeAttachment(A)}).forEach(function(g){r.push(g)}),this.nodeCache[A]=Promise.all(r).then(function(g){let I;if(s.isBone===!0?I=new NE:g.length>1?I=new yi:g.length===1?I=g[0]:I=new Be,I!==g[0])for(let E=0,C=g.length;E<C;E++)I.add(g[E]);if(s.name&&(I.userData.name=s.name,I.name=o),kt(I,s),s.extensions&&fi(t,I,s),s.matrix!==void 0){const E=new UA;E.fromArray(s.matrix),I.applyMatrix4(E)}else s.translation!==void 0&&I.position.fromArray(s.translation),s.rotation!==void 0&&I.quaternion.fromArray(s.rotation),s.scale!==void 0&&I.scale.fromArray(s.scale);return n.associations.has(I)||n.associations.set(I,{}),n.associations.get(I).nodes=A,I}),this.nodeCache[A]}loadScene(A){const e=this.extensions,t=this.json.scenes[A],n=this,s=new yi;t.name&&(s.name=n.createUniqueName(t.name)),kt(s,t),t.extensions&&fi(e,s,t);const o=t.nodes||[],r=[];for(let a=0,g=o.length;a<g;a++)r.push(n.getDependency("node",o[a]));return Promise.all(r).then(function(a){for(let I=0,E=a.length;I<E;I++)s.add(a[I]);const g=I=>{const E=new Map;for(const[C,Q]of n.associations)(C instanceof ut||C instanceof de)&&E.set(C,Q);return I.traverse(C=>{const Q=n.associations.get(C);Q!=null&&E.set(C,Q)}),E};return n.associations=g(s),s})}_createAnimationTracks(A,e,t,n,s){const o=[],r=A.name?A.name:A.uuid,a=[];ei[s.path]===ei.weights?A.traverse(function(C){C.morphTargetInfluences&&a.push(C.name?C.name:C.uuid)}):a.push(r);let g;switch(ei[s.path]){case ei.weights:g=Cn;break;case ei.rotation:g=Qn;break;case ei.position:case ei.scale:g=Bn;break;default:switch(t.itemSize){case 1:g=Cn;break;case 2:case 3:default:g=Bn;break}break}const I=n.interpolation!==void 0?pD[n.interpolation]:On,E=this._getArrayFromAccessor(t);for(let C=0,Q=a.length;C<Q;C++){const h=new g(a[C]+"."+ei[s.path],e.array,E,I);n.interpolation==="CUBICSPLINE"&&this._createCubicSplineTrackInterpolant(h),o.push(h)}return o}_getArrayFromAccessor(A){let e=A.array;if(A.normalized){const t=ia(e.constructor),n=new Float32Array(e.length);for(let s=0,o=e.length;s<o;s++)n[s]=e[s]*t;e=n}return e}_createCubicSplineTrackInterpolant(A){A.createInterpolant=function(t){const n=this instanceof Qn?fD:vC;return new n(this.times,this.values,this.getValueSize()/3,t)},A.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0}}function ND(i,A,e){const t=A.attributes,n=new rt;if(t.POSITION!==void 0){const r=e.json.accessors[t.POSITION],a=r.min,g=r.max;if(a!==void 0&&g!==void 0){if(n.set(new L(a[0],a[1],a[2]),new L(g[0],g[1],g[2])),r.normalized){const I=ia(tn[r.componentType]);n.min.multiplyScalar(I),n.max.multiplyScalar(I)}}else{console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");return}}else return;const s=A.targets;if(s!==void 0){const r=new L,a=new L;for(let g=0,I=s.length;g<I;g++){const E=s[g];if(E.POSITION!==void 0){const C=e.json.accessors[E.POSITION],Q=C.min,h=C.max;if(Q!==void 0&&h!==void 0){if(a.setX(Math.max(Math.abs(Q[0]),Math.abs(h[0]))),a.setY(Math.max(Math.abs(Q[1]),Math.abs(h[1]))),a.setZ(Math.max(Math.abs(Q[2]),Math.abs(h[2]))),C.normalized){const l=ia(tn[C.componentType]);a.multiplyScalar(l)}r.max(a)}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}n.expandByVector(r)}i.boundingBox=n;const o=new Dt;n.getCenter(o.center),o.radius=n.min.distanceTo(n.max)/2,i.boundingSphere=o}function AE(i,A,e){const t=A.attributes,n=[];function s(o,r){return e.getDependency("accessor",o).then(function(a){i.setAttribute(r,a)})}for(const o in t){const r=ta[o]||o.toLowerCase();r in i.attributes||n.push(s(t[o],r))}if(A.indices!==void 0&&!i.index){const o=e.getDependency("accessor",A.indices).then(function(r){i.setIndex(r)});n.push(o)}return $A.workingColorSpace!==be&&"COLOR_0"in t&&console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${$A.workingColorSpace}" not supported.`),kt(i,A),ND(i,A,e),Promise.all(n).then(function(){return A.targets!==void 0?mD(i,A.targets,e):i})}var kn=function(){var i=0,A=document.createElement("div");A.style.cssText="position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000",A.addEventListener("click",function(I){I.preventDefault(),t(++i%A.children.length)},!1);function e(I){return A.appendChild(I.dom),I}function t(I){for(var E=0;E<A.children.length;E++)A.children[E].style.display=E===I?"block":"none";i=I}var n=(performance||Date).now(),s=n,o=0,r=e(new kn.Panel("FPS","#0ff","#002")),a=e(new kn.Panel("MS","#0f0","#020"));if(self.performance&&self.performance.memory)var g=e(new kn.Panel("MB","#f08","#201"));return t(0),{REVISION:16,dom:A,addPanel:e,showPanel:t,begin:function(){n=(performance||Date).now()},end:function(){o++;var I=(performance||Date).now();if(a.update(I-n,200),I>=s+1e3&&(r.update(o*1e3/(I-s),100),s=I,o=0,g)){var E=performance.memory;g.update(E.usedJSHeapSize/1048576,E.jsHeapSizeLimit/1048576)}return I},update:function(){n=this.end()},domElement:A,setMode:t}};kn.Panel=function(i,A,e){var t=1/0,n=0,s=Math.round,o=s(window.devicePixelRatio||1),r=80*o,a=48*o,g=3*o,I=2*o,E=3*o,C=15*o,Q=74*o,h=30*o,l=document.createElement("canvas");l.width=r,l.height=a,l.style.cssText="width:80px;height:48px";var B=l.getContext("2d");return B.font="bold "+9*o+"px Helvetica,Arial,sans-serif",B.textBaseline="top",B.fillStyle=e,B.fillRect(0,0,r,a),B.fillStyle=A,B.fillText(i,g,I),B.fillRect(E,C,Q,h),B.fillStyle=e,B.globalAlpha=.9,B.fillRect(E,C,Q,h),{dom:l,update:function(c,R){t=Math.min(t,c),n=Math.max(n,c),B.fillStyle=e,B.globalAlpha=1,B.fillRect(0,0,r,C),B.fillStyle=A,B.fillText(s(c)+" "+i+" ("+s(t)+"-"+s(n)+")",g,I),B.drawImage(l,E+o,C,Q-o,h,E,C,Q-o,h),B.fillRect(E+Q-o,C,o,h),B.fillStyle=e,B.globalAlpha=.9,B.fillRect(E+Q-o,C,o,s((1-c/R)*h))}}};const oi=document.getElementById("gsviewer"),it=new RB,te=new Le(45,window.innerWidth/window.innerHeight,.1,1e3),Pt=1,ti=.5;te.position.set(0,Pt,0);const we=new ef({antialias:!1});we.setPixelRatio(.85);we.setSize(oi.clientWidth,oi.clientHeight);oi.appendChild(we.domElement);window.addEventListener("resize",()=>{te.aspect=oi.clientWidth/oi.clientHeight,te.updateProjectionMatrix(),we.setSize(oi.clientWidth,oi.clientHeight)});function xD(){console.log(te.rotation);let i=Qa.radToDeg(-te.rotation.y)+0;document.getElementById("minimap_ind").style.transform=`rotate(${i}deg)`;const A=1,e=8*A,t=-400*A,n=-400*A,s=1e3*A,o=te.position.x,r=te.position.z;document.getElementById("minimap").style.backgroundPosition=`${t-o*e}px ${n-r*e}px`,document.getElementById("minimap").style.backgroundSize=`${s}px ${s}px`}const js=new kn;js.showPanel(0);const dn=document.createElement("div");dn.style.position="absolute";dn.style.top="8px";dn.style.left="8px";dn.style.zIndex="1000";dn.appendChild(js.dom);oi.appendChild(dn);const ro=[{id:"room1",url:"assets/canariensis_800k_TEMP.ply",position:new L(0,Pt,0),exits:[{idExit:"room2",position:new L(-2.55,ti,6.35)}]},{id:"room2",url:"assets/terrazaPalmeras.ply",position:new L(0,Pt,0),exits:[{idExit:"room1",position:new L(-2.55,ti,6.35)},{idExit:"room3",position:new L(-25.75,ti,1.28)}]},{id:"room3",url:"assets/Washingtonia-v2.ply",position:new L(0,Pt,0),exits:[{idExit:"room2",position:new L(-25.75,ti,1.28)},{idExit:"room4",position:new L(-38.21,ti,-2.49)},{idExit:"room5",position:new L(-42.8304,ti,12.8885)}]},{id:"room4",url:"assets/Terraza2.ply",position:new L(0,Pt,0),exits:[{idExit:"room3",position:new L(-38.21,ti,-2.49)}]},{id:"room5",url:"assets/Terraza1_fix.ply",position:new L(0,Pt,0),exits:[{idExit:"room3",position:new L(-42.8304,ti,12.8885)}]}];let Ve=ro[0];const Yn=[];let ji=null,Ps=!1;const FD=Math.PI/4;new L(0,Pt,0);const LD=1,_D=3;function TC(){return new Promise(i=>{const A=document.getElementById("fadeOverlay");A.style.opacity="1",setTimeout(i,100)})}function UD(){const i=document.getElementById("fadeOverlay");i.style.opacity="0"}function bC(i,A,e){if(!ji)return console.warn("Indicator prototype not loaded yet"),null;const t=ji.clone(!0);return t.position.copy(i),t.userData.isIndicator=!0,it.add(t),Yn.push(t),t}function $s(i){i.traverse(A=>{if(A.geometry)try{A.geometry.dispose()}catch(e){console.warn("geometry dispose failed",e)}if(A.material){const e=t=>{if(t){if(t.map)try{t.map.dispose()}catch{}if(t.uniforms)for(const n in t.uniforms){const s=t.uniforms[n];if(s&&s.value&&s.value.dispose)try{s.value.dispose()}catch{}}try{t.dispose()}catch{}}};Array.isArray(A.material)?A.material.forEach(e):e(A.material)}})}function GD(){if(!Ve||!Array.isArray(Ve.exits))return;const i=performance.now();for(const A of Ve.exits){const e=A.position,t=te.position.distanceTo(e);if(t<LD){if(i-A._lastTriggered,!A._locked){A._locked=!0,A._lastTriggered=i;const n=ro.find(s=>s.id===A.idExit);n.exits.forEach(s=>{s._locked=!0,s._lastTriggered=performance.now()}),n&&KD(n).catch(s=>console.error(s));break}}else t>_D&&(A._locked=!1)}}const eE=new cc;new L;function vD(i,A=1200){return new Promise(e=>{if(Ps)return e();Ps=!0,gi.enabled=!1,we.domElement.style.cursor="progress",setTimeout(()=>{TC()},A/2);const t=te.position.clone(),n=te.quaternion.clone(),s=new L(i.x,i.y,i.z),o=new Le;o.position.copy(t),o.lookAt(s);const r=o.quaternion.clone(),a=performance.now();function g(){const I=performance.now(),E=Math.min(1,(I-a)/A),C=E*E*(3-2*E);te.position.lerpVectors(t,i,C);const Q=n.clone().slerp(r,C);te.quaternion.copy(Q),te.updateMatrixWorld(),E<1?requestAnimationFrame(g):(te.position.copy(i),te.quaternion.copy(r),te.updateMatrixWorld(),Ps=!1,gi.enabled=!0,we.domElement.style.cursor="grab",e())}requestAnimationFrame(g)})}function tE(i){if(!i)return new tt({color:16777215});const A=i.map||i.emissiveMap||i.aoMap||i.lightMap||null,e=i.color&&i.color.isColor?i.color.clone():new GA(16777215),t={map:A||null,color:e,side:i.side!==void 0?i.side:ft,transparent:!1,opacity:i.opacity!==void 0?i.opacity:1,alphaTest:i.alphaTest||0,vertexColors:i.vertexColors||!1,depthWrite:!0,depthTest:!0},n=new tt(t);try{A&&A.encoding&&(n.map.encoding=A.encoding)}catch{}return n}function TD(i){i.traverse(A=>{if(A.isMesh){const e=A.material;if(!e)return;if(Array.isArray(e)){const t=e.map(n=>{const s=tE(n);try{n.dispose&&n.dispose()}catch{}return s});A.material=t}else{const t=tE(e);try{e.dispose&&e.dispose()}catch{}A.material=t}}})}function bD(i){const A=FD*i;for(const e of Yn)!e||!e.parent||(e.rotation.y+=A)}const kC=new z0;kC.load("assets/Door.glb",i=>{ji=i.scene,ji.scale.set(1,1,1),ji.position.set(0,Pt,0),TD(ji),Ve&&Array.isArray(Ve.exits)&&Ve.exits.forEach(A=>{A._locked=A._locked||!1,A._lastTriggered=A._lastTriggered||0,bC(A.position)})},void 0,i=>{console.error("Error loading glTF model:",i)});kC.load("assets/floor.glb",i=>{const A=i.scene;A.scale.set(1,1,1),A.position.set(0,0,0),A.visible=!1,it.add(A)},void 0,i=>{console.error("Error loading floor glTF model:",i)});const gi=new Y0(te,we.domElement);it.add(gi.object);gi.enabled=!0;te.rotation.order="YXZ";we.domElement.style.cursor="grab";let Ni=!1,nt={x:0,y:0};const Ao=.002;we.domElement.addEventListener("mousedown",i=>{i.button===0&&(Ni=!0,nt.x=i.clientX,nt.y=i.clientY,we.domElement.style.cursor="grabbing",i.preventDefault())},!1);window.addEventListener("mousemove",i=>{if(!Ni)return;const A=i.movementX!==void 0?i.movementX:i.clientX-nt.x,e=i.movementY!==void 0?i.movementY:i.clientY-nt.y;nt.x=i.clientX,nt.y=i.clientY,te.rotation.y+=A*Ao,te.rotation.x+=e*Ao;const t=Math.PI/2-.01;te.rotation.x=Math.max(-t,Math.min(t,te.rotation.x))},!1);window.addEventListener("mouseup",i=>{i.button===0&&(Ni=!1,we.domElement.style.cursor="grab")},!1);we.domElement.addEventListener("touchstart",i=>{i.touches.length===1&&(Ni=!0,nt.x=i.touches[0].clientX,nt.y=i.touches[0].clientY)},!1);we.domElement.addEventListener("touchmove",i=>{if(!Ni||i.touches.length!==1)return;i.preventDefault();const A=i.touches[0],e=A.clientX-nt.x,t=A.clientY-nt.y;nt.x=A.clientX,nt.y=A.clientY,te.rotation.y-=e*Ao,te.rotation.x-=t*Ao;const n=Math.PI/2-.01;te.rotation.x=Math.max(-n,Math.min(n,te.rotation.x))},{passive:!1});window.addEventListener("touchend",()=>{Ni=!1},!1);we.domElement.addEventListener("click",i=>{if(Ni||Ps)return;const A=we.domElement.getBoundingClientRect(),e=new bA((i.clientX-A.left)/A.width*2-1,-((i.clientY-A.top)/A.height)*2+1);eE.setFromCamera(e,te);const t=eE.intersectObjects(Yn,!0);if(t.length>0){let n=t[0].object;for(;n&&!n.userData.isIndicator&&n.parent;)n=n.parent;if(n&&n.userData.isIndicator){const s=new L(n.position.x,Pt,n.position.z);vD(s,1200).catch(()=>{})}}},!1);const kD=5,st={forward:!1,backward:!1,left:!1,right:!1};document.addEventListener("keydown",i=>{switch(i.code){case"KeyW":st.backward=!0;break;case"KeyS":st.forward=!0;break;case"KeyA":st.left=!0;break;case"KeyD":st.right=!0;break}},!1);document.addEventListener("keyup",i=>{switch(i.code){case"KeyW":st.backward=!1;break;case"KeyS":st.forward=!1;break;case"KeyA":st.left=!1;break;case"KeyD":st.right=!1;break}},!1);function HD(i){const A=kD*i,e=new L;st.forward&&(e.z-=A),st.backward&&(e.z+=A),st.left&&(e.x-=A),st.right&&(e.x+=A),gi.moveRight(e.x),gi.moveForward(e.z)}const PD=new sc,ot=new Map,OD=8;let Os=null;function JD(){for(;ot.size>OD;){const i=ot.keys().next().value,A=ot.get(i);if(A&&A.splat)try{it&&it.children.includes(A.splat)&&it.remove(A.splat),$s(A.splat)}catch(e){console.warn("dispose error",e)}ot.delete(i)}}function HC(i,A=1e3){return new Promise(e=>{const t=performance.now();(function n(){let s=!1;if(i.traverse(o=>{o.isPoints&&(s=!0)}),s)return e(!0);if(performance.now()-t>A)return e(!1);requestAnimationFrame(n)})()})}function PC(i){const A=ot.get(i.id);if(A)return A.loadingPromise;const e=new UC({renderer:we,scene:null,controls:gi,shDegree:1}),t=(async()=>{try{e.addModel({url:i.url});const n=await HC(e,1e3);return it.add(e),e.visible=i.id===Ve.id,console.log("Preloaded room",i.id,"ready:",n),e}catch(n){console.error("Error preloading room",i.id,n);try{$s(e)}catch{}throw n}finally{JD()}})();return ot.set(i.id,{splat:e,ready:!1,loadingPromise:t}),t.then(n=>{const s=ot.get(i.id);return s&&(s.ready=!0),n}).catch(()=>{ot.delete(i.id)}),t}async function KD(i){if(!i||Ve.id===i.id)return;await TC();const A=ot.get(i.id),e=Ve;try{let t;if(A)try{t=await A.loadingPromise}catch{console.warn("Preload promise failed for",i.id,"will attempt fresh load."),ot.delete(i.id)}if(!t){const s=new UC({renderer:we,scene:null,controls:gi});s.addModel({url:i.url}),await HC(s,4e3),s.position.copy(i.position),it.add(s),t=s,ot.set(i.id,{splat:t,ready:!0,loadingPromise:Promise.resolve(t)})}Os&&(Os.visible=!1),t.visible=!0;const n=[];it.traverse(s=>{s.isMesh&&s.geometry&&s.geometry.type==="SphereGeometry"&&n.push(s)});for(const s of n)it.remove(s),$s(s);Yn.forEach(s=>{try{it.remove(s),$s(s)}catch(o){console.warn("indicator cleanup failed",o)}}),Yn.length=0,i.exits&&Array.isArray(i.exits)&&i.exits.forEach(s=>{s._locked=s._locked||!1,s._lastTriggered=s._lastTriggered||0,bC(s.position)}),Os=t,Ve=i,e&&Ve.exits&&Ve.exits.forEach(s=>{s.idExit===e.id&&(s._locked=!0,s._lastTriggered=performance.now())}),ro.forEach(s=>{s.id!==i.id&&PC(s)}),console.log("Switched to room",i.id)}catch(t){console.error("Error switching to room",i.id,t)}UD()}ro.forEach(i=>{PC(i).catch(A=>console.warn("preload failed for",i.id,A))});const iE=ot.get(Ve.id);iE&&iE.loadingPromise.then(i=>{Os=i}).catch(()=>{});function OC(){js.begin(),requestAnimationFrame(OC),xD();const i=PD.getDelta();bD(i),HD(i),GD(),we.render(it,te),js.end(),console.log(`Camera position: x=${te.position.x.toFixed(2)}, y=${te.position.y.toFixed(2)}, z=${te.position.z.toFixed(2)}`)}OC();
